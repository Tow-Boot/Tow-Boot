From 7279fe018196d3c4d8e07acb3eb206738e80e710 Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Mon, 26 Apr 2021 08:12:30 -0400
Subject: [PATCH 1/2] lib/PDCursesMod: Add most pf PDCursesMod outright

At least, the parts we'll be using.

This does not integrate with the build system yet.
---
 lib/PDCursesMod/.gitignore          |   49 +
 lib/PDCursesMod/README.md           |   79 +
 lib/PDCursesMod/ansi/README.md      |    4 +
 lib/PDCursesMod/ansi/pdcansi.h      |   20 +
 lib/PDCursesMod/ansi/pdcclip.c      |   72 +
 lib/PDCursesMod/ansi/pdcdisp.c      |  305 +++
 lib/PDCursesMod/ansi/pdcgetsc.c     |   27 +
 lib/PDCursesMod/ansi/pdckbd.c       |  279 +++
 lib/PDCursesMod/ansi/pdcscrn.c      |  255 +++
 lib/PDCursesMod/ansi/pdcsetsc.c     |   99 +
 lib/PDCursesMod/ansi/pdcutil.c      |   19 +
 lib/PDCursesMod/common/acs_defs.h   |  265 +++
 lib/PDCursesMod/common/font437.h    |  386 ++++
 lib/PDCursesMod/common/icon32.xpm   |   42 +
 lib/PDCursesMod/common/icon64.xpm   |   74 +
 lib/PDCursesMod/common/iconbmp.h    |   24 +
 lib/PDCursesMod/common/libobjs.mif  |   25 +
 lib/PDCursesMod/common/makedist.mif |   19 +
 lib/PDCursesMod/common/pdccolor.c   |  217 ++
 lib/PDCursesMod/common/pdccolor.h   |   14 +
 lib/PDCursesMod/common/pdccolor.txt |   68 +
 lib/PDCursesMod/common/pdcurses.rc  |   35 +
 lib/PDCursesMod/common/version.mif  |    9 +
 lib/PDCursesMod/common/watcom.mif   |  204 ++
 lib/PDCursesMod/curses.h            | 1774 ++++++++++++++++
 lib/PDCursesMod/curspriv.h          |  125 ++
 lib/PDCursesMod/demos/README.md     |   25 +
 lib/PDCursesMod/demos/firework.c    |  149 ++
 lib/PDCursesMod/demos/nctests.mif   |   34 +
 lib/PDCursesMod/demos/newtest.c     |  591 ++++++
 lib/PDCursesMod/demos/ozdemo.c      |  442 ++++
 lib/PDCursesMod/demos/picsview.c    |  489 +++++
 lib/PDCursesMod/demos/ptest.c       |  309 +++
 lib/PDCursesMod/demos/rain.c        |  161 ++
 lib/PDCursesMod/demos/simplemenu.c  |  176 ++
 lib/PDCursesMod/demos/speed.c       |  102 +
 lib/PDCursesMod/demos/test_pan.c    |  188 ++
 lib/PDCursesMod/demos/testcurs.c    | 1612 ++++++++++++++
 lib/PDCursesMod/demos/triangles.c   |   85 +
 lib/PDCursesMod/demos/tui.c         |  820 +++++++
 lib/PDCursesMod/demos/tui.h         |   65 +
 lib/PDCursesMod/demos/tuidemo.c     |  228 ++
 lib/PDCursesMod/demos/version.c     |   65 +
 lib/PDCursesMod/demos/worm.c        |  446 ++++
 lib/PDCursesMod/demos/xmas.c        |  958 +++++++++
 lib/PDCursesMod/docs/CNAME          |    1 +
 lib/PDCursesMod/docs/HISTORY.md     | 2782 ++++++++++++++++++++++++
 lib/PDCursesMod/docs/IMPLEMNT.md    |  323 +++
 lib/PDCursesMod/docs/MANUAL.md      | 3054 +++++++++++++++++++++++++++
 lib/PDCursesMod/docs/README.md      |   45 +
 lib/PDCursesMod/docs/USERS.md       |  359 ++++
 lib/PDCursesMod/docs/index.html     |  112 +
 lib/PDCursesMod/docs/manext.awk     |   15 +
 lib/PDCursesMod/docs/mkman.sh       |    7 +
 lib/PDCursesMod/panel.h             |   58 +
 lib/PDCursesMod/pdcurses/README.md  |   25 +
 lib/PDCursesMod/pdcurses/addch.c    |  697 ++++++
 lib/PDCursesMod/pdcurses/addchstr.c |  247 +++
 lib/PDCursesMod/pdcurses/addstr.c   |  245 +++
 lib/PDCursesMod/pdcurses/attr.c     |  426 ++++
 lib/PDCursesMod/pdcurses/beep.c     |   77 +
 lib/PDCursesMod/pdcurses/bkgd.c     |  232 ++
 lib/PDCursesMod/pdcurses/border.c   |  420 ++++
 lib/PDCursesMod/pdcurses/clear.c    |  163 ++
 lib/PDCursesMod/pdcurses/color.c    |  392 ++++
 lib/PDCursesMod/pdcurses/debug.c    |  110 +
 lib/PDCursesMod/pdcurses/delch.c    |   98 +
 lib/PDCursesMod/pdcurses/deleteln.c |  215 ++
 lib/PDCursesMod/pdcurses/getch.c    |  602 ++++++
 lib/PDCursesMod/pdcurses/getstr.c   |  480 +++++
 lib/PDCursesMod/pdcurses/getyx.c    |  151 ++
 lib/PDCursesMod/pdcurses/inch.c     |  132 ++
 lib/PDCursesMod/pdcurses/inchstr.c  |  216 ++
 lib/PDCursesMod/pdcurses/initscr.c  |  483 +++++
 lib/PDCursesMod/pdcurses/inopts.c   |  389 ++++
 lib/PDCursesMod/pdcurses/insch.c    |  274 +++
 lib/PDCursesMod/pdcurses/insstr.c   |  268 +++
 lib/PDCursesMod/pdcurses/instr.c    |  252 +++
 lib/PDCursesMod/pdcurses/kernel.c   |  312 +++
 lib/PDCursesMod/pdcurses/keyname.c  |  139 ++
 lib/PDCursesMod/pdcurses/mouse.c    |  449 ++++
 lib/PDCursesMod/pdcurses/move.c     |   83 +
 lib/PDCursesMod/pdcurses/outopts.c  |  186 ++
 lib/PDCursesMod/pdcurses/overlay.c  |  221 ++
 lib/PDCursesMod/pdcurses/pad.c      |  283 +++
 lib/PDCursesMod/pdcurses/panel.c    |  670 ++++++
 lib/PDCursesMod/pdcurses/printw.c   |  129 ++
 lib/PDCursesMod/pdcurses/refresh.c  |  304 +++
 lib/PDCursesMod/pdcurses/scanw.c    |  581 +++++
 lib/PDCursesMod/pdcurses/scr_dump.c |  211 ++
 lib/PDCursesMod/pdcurses/scroll.c   |  103 +
 lib/PDCursesMod/pdcurses/slk.c      |  631 ++++++
 lib/PDCursesMod/pdcurses/termattr.c |  176 ++
 lib/PDCursesMod/pdcurses/touch.c    |  208 ++
 lib/PDCursesMod/pdcurses/util.c     |  348 +++
 lib/PDCursesMod/pdcurses/window.c   |  574 +++++
 96 files changed, 30392 insertions(+)
 create mode 100644 lib/PDCursesMod/.gitignore
 create mode 100644 lib/PDCursesMod/README.md
 create mode 100644 lib/PDCursesMod/ansi/README.md
 create mode 100644 lib/PDCursesMod/ansi/pdcansi.h
 create mode 100644 lib/PDCursesMod/ansi/pdcclip.c
 create mode 100644 lib/PDCursesMod/ansi/pdcdisp.c
 create mode 100644 lib/PDCursesMod/ansi/pdcgetsc.c
 create mode 100644 lib/PDCursesMod/ansi/pdckbd.c
 create mode 100644 lib/PDCursesMod/ansi/pdcscrn.c
 create mode 100644 lib/PDCursesMod/ansi/pdcsetsc.c
 create mode 100644 lib/PDCursesMod/ansi/pdcutil.c
 create mode 100644 lib/PDCursesMod/common/acs_defs.h
 create mode 100644 lib/PDCursesMod/common/font437.h
 create mode 100644 lib/PDCursesMod/common/icon32.xpm
 create mode 100644 lib/PDCursesMod/common/icon64.xpm
 create mode 100644 lib/PDCursesMod/common/iconbmp.h
 create mode 100644 lib/PDCursesMod/common/libobjs.mif
 create mode 100644 lib/PDCursesMod/common/makedist.mif
 create mode 100644 lib/PDCursesMod/common/pdccolor.c
 create mode 100644 lib/PDCursesMod/common/pdccolor.h
 create mode 100644 lib/PDCursesMod/common/pdccolor.txt
 create mode 100644 lib/PDCursesMod/common/pdcurses.rc
 create mode 100644 lib/PDCursesMod/common/version.mif
 create mode 100644 lib/PDCursesMod/common/watcom.mif
 create mode 100644 lib/PDCursesMod/curses.h
 create mode 100644 lib/PDCursesMod/curspriv.h
 create mode 100644 lib/PDCursesMod/demos/README.md
 create mode 100644 lib/PDCursesMod/demos/firework.c
 create mode 100644 lib/PDCursesMod/demos/nctests.mif
 create mode 100644 lib/PDCursesMod/demos/newtest.c
 create mode 100644 lib/PDCursesMod/demos/ozdemo.c
 create mode 100644 lib/PDCursesMod/demos/picsview.c
 create mode 100644 lib/PDCursesMod/demos/ptest.c
 create mode 100644 lib/PDCursesMod/demos/rain.c
 create mode 100644 lib/PDCursesMod/demos/simplemenu.c
 create mode 100644 lib/PDCursesMod/demos/speed.c
 create mode 100644 lib/PDCursesMod/demos/test_pan.c
 create mode 100644 lib/PDCursesMod/demos/testcurs.c
 create mode 100644 lib/PDCursesMod/demos/triangles.c
 create mode 100644 lib/PDCursesMod/demos/tui.c
 create mode 100644 lib/PDCursesMod/demos/tui.h
 create mode 100644 lib/PDCursesMod/demos/tuidemo.c
 create mode 100644 lib/PDCursesMod/demos/version.c
 create mode 100644 lib/PDCursesMod/demos/worm.c
 create mode 100644 lib/PDCursesMod/demos/xmas.c
 create mode 100644 lib/PDCursesMod/docs/CNAME
 create mode 100644 lib/PDCursesMod/docs/HISTORY.md
 create mode 100644 lib/PDCursesMod/docs/IMPLEMNT.md
 create mode 100644 lib/PDCursesMod/docs/MANUAL.md
 create mode 100644 lib/PDCursesMod/docs/README.md
 create mode 100644 lib/PDCursesMod/docs/USERS.md
 create mode 100644 lib/PDCursesMod/docs/index.html
 create mode 100755 lib/PDCursesMod/docs/manext.awk
 create mode 100755 lib/PDCursesMod/docs/mkman.sh
 create mode 100644 lib/PDCursesMod/panel.h
 create mode 100644 lib/PDCursesMod/pdcurses/README.md
 create mode 100644 lib/PDCursesMod/pdcurses/addch.c
 create mode 100644 lib/PDCursesMod/pdcurses/addchstr.c
 create mode 100644 lib/PDCursesMod/pdcurses/addstr.c
 create mode 100644 lib/PDCursesMod/pdcurses/attr.c
 create mode 100644 lib/PDCursesMod/pdcurses/beep.c
 create mode 100644 lib/PDCursesMod/pdcurses/bkgd.c
 create mode 100644 lib/PDCursesMod/pdcurses/border.c
 create mode 100644 lib/PDCursesMod/pdcurses/clear.c
 create mode 100644 lib/PDCursesMod/pdcurses/color.c
 create mode 100644 lib/PDCursesMod/pdcurses/debug.c
 create mode 100644 lib/PDCursesMod/pdcurses/delch.c
 create mode 100644 lib/PDCursesMod/pdcurses/deleteln.c
 create mode 100644 lib/PDCursesMod/pdcurses/getch.c
 create mode 100644 lib/PDCursesMod/pdcurses/getstr.c
 create mode 100644 lib/PDCursesMod/pdcurses/getyx.c
 create mode 100644 lib/PDCursesMod/pdcurses/inch.c
 create mode 100644 lib/PDCursesMod/pdcurses/inchstr.c
 create mode 100644 lib/PDCursesMod/pdcurses/initscr.c
 create mode 100644 lib/PDCursesMod/pdcurses/inopts.c
 create mode 100644 lib/PDCursesMod/pdcurses/insch.c
 create mode 100644 lib/PDCursesMod/pdcurses/insstr.c
 create mode 100644 lib/PDCursesMod/pdcurses/instr.c
 create mode 100644 lib/PDCursesMod/pdcurses/kernel.c
 create mode 100644 lib/PDCursesMod/pdcurses/keyname.c
 create mode 100644 lib/PDCursesMod/pdcurses/mouse.c
 create mode 100644 lib/PDCursesMod/pdcurses/move.c
 create mode 100644 lib/PDCursesMod/pdcurses/outopts.c
 create mode 100644 lib/PDCursesMod/pdcurses/overlay.c
 create mode 100644 lib/PDCursesMod/pdcurses/pad.c
 create mode 100644 lib/PDCursesMod/pdcurses/panel.c
 create mode 100644 lib/PDCursesMod/pdcurses/printw.c
 create mode 100644 lib/PDCursesMod/pdcurses/refresh.c
 create mode 100644 lib/PDCursesMod/pdcurses/scanw.c
 create mode 100644 lib/PDCursesMod/pdcurses/scr_dump.c
 create mode 100644 lib/PDCursesMod/pdcurses/scroll.c
 create mode 100644 lib/PDCursesMod/pdcurses/slk.c
 create mode 100644 lib/PDCursesMod/pdcurses/termattr.c
 create mode 100644 lib/PDCursesMod/pdcurses/touch.c
 create mode 100644 lib/PDCursesMod/pdcurses/util.c
 create mode 100644 lib/PDCursesMod/pdcurses/window.c

diff --git a/lib/PDCursesMod/.gitignore b/lib/PDCursesMod/.gitignore
new file mode 100644
index 00000000000..517bc2e4cad
--- /dev/null
+++ b/lib/PDCursesMod/.gitignore
@@ -0,0 +1,49 @@
+*.[oa]
+*.exe
+firework
+manext
+libXCurses.so
+ozdemo
+newtest
+ptest
+rain
+sdltest
+simplemenu
+testcurs
+triangles
+tuidemo
+worm
+xmas
+*.sho
+Makefile
+config.h
+config.log
+config.status
+PDCurses.md
+xcurses-config
+*.dll
+wingui.gif
+wingui.htm
+*.bat
+clock.c
+clock1.c
+fullscrn.c
+hello
+hello.c
+wingui/wcr*
+wingui/wct*
+wingui/wc_*
+wingui/wcw*
+wingui/z*
+wingui/scr2html.c
+wingui/newtest*
+wingui/*.sav
+wingui/*.def
+wincon/*.def
+*.obj
+*.bak
+*.map
+*.lib
+m
+.vscode
+build
diff --git a/lib/PDCursesMod/README.md b/lib/PDCursesMod/README.md
new file mode 100644
index 00000000000..87ea1c0c5db
--- /dev/null
+++ b/lib/PDCursesMod/README.md
@@ -0,0 +1,79 @@
+Welcome to PDCursesMod!
+=======================
+
+Public Domain Curses, aka PDCursesMod, is an implementation of X/Open
+curses for multiple platforms. Relative to the ['official' PDCurses
+project](https://www.github.com/wmcbrine/PDCurses),  this has a variety of improvements,  adding Windows GUI,
+VT-like console,  DOSVGA,  and Plan 9 "flavors" of Curses and expanding
+the capabilities of the other flavors (SDL1,  SDL2,  X11, Win32 console,
+OS/2, and DOS).  Some details and screen shots at
+
+https://www.projectpluto.com/win32a.htm
+
+Much of this was done during a long period in which the 'official'
+PDCurses  was inactive.  Since then,  that version has again been
+somewhat active;  most improvements made there have been taken into
+this project,  and some improvements from here have gone into PDCurses.
+Most programs that compile and run with PDCurses or ncurses will also
+compile with PDCursesMod,  and vice versa, as long as you stick to the
+(substantial) subset of common functionality. However,  the split
+appears to be permanent.
+
+Legal Stuff
+-----------
+
+The core package is in the public domain, but small portions of PDCursesMod
+are subject to copyright under various licenses.  Each directory contains a
+README file, with a section titled "Distribution Status" which describes
+the status of the files in that directory.
+
+If you use PDCursesMod in an application, an acknowledgement would be
+appreciated, but is not mandatory. If you make corrections or
+enhancements to PDCursesMod, please forward them to the current maintainer
+for the benefit of other users.
+
+This software is provided AS IS with NO WARRANTY whatsoever.
+
+Ports
+-----
+
+PDCurses has been ported to DOS, OS/2, Win32, X11 and SDL1 and SDL2.
+PDCursesMod adds DOSVGA,  Windows GUI,  Plan 9,  and VT-like console
+ports. A directory containing the port-specific source files exists
+for each of these platforms.
+
+Build instructions are in the README file for each platform:
+
+-  [DOS](dos/README.md) for use on DOS
+-  [DOSVGA](dosvga/README.md) for use on DOS in graphical modes
+-  [OS/2](os2/README.md) for use on OS/2
+-  [Plan9](plan9/README.md) for use on Plan9 (APE)
+-  [SDL 1.x](sdl1/README.md) for use as separate SDL version 1 window
+-  [SDL 2.x](sdl2/README.md) for use as separate SDL version 2 window
+-  [wincon](wincon/README.md) (formerly win32) for use on Windows Console
+-  [WinGUI](wingui/README.md) for use on Windows Graphics Mode
+-  [X11](x11/README.md) (also called XCurses) for use as separate X11 window
+-  [VT](vt/README.md) for use on terminal
+
+Distribution Status
+-------------------
+
+All files in this directory except configure, config.guess and
+config.sub are released to the Public Domain. config.guess and
+config.sub are under the GPL; configure is under a free license
+described within it.
+
+Build Status
+-------------------
+
+PDCursesMod is automatically build in multiple environments:
+
+[![Build status Travis-CI](https://api.travis-ci.com/Bill-Gray/PDCursesMod.svg?branch=master)](https://travis-ci.com/Bill-Gray/PDCursesMod)
+, also providing artifacts: [![Build status Appveyor](https://ci.appveyor.com/api/projects/status/github/Bill-Gray/PDCursesMod?branch=master&svg=true)](https://ci.appveyor.com/project/Bill-Gray/PDCursesMod)
+
+
+Maintainer
+----------
+
+Bill Gray
+p&#x202e;&ocirc;&#xe7;.&ouml;tulp&#x165;c&eacute;j&ocirc;&#x159;p&#x40;ot&uacute;l&#x202c;m
diff --git a/lib/PDCursesMod/ansi/README.md b/lib/PDCursesMod/ansi/README.md
new file mode 100644
index 00000000000..0877914a681
--- /dev/null
+++ b/lib/PDCursesMod/ansi/README.md
@@ -0,0 +1,4 @@
+PDCurses for ANSI
+=================
+
+This ANSI port is basically a reduced-functionality `vt` port.
diff --git a/lib/PDCursesMod/ansi/pdcansi.h b/lib/PDCursesMod/ansi/pdcansi.h
new file mode 100644
index 00000000000..c55a9f5c0bd
--- /dev/null
+++ b/lib/PDCursesMod/ansi/pdcansi.h
@@ -0,0 +1,20 @@
+#define PACKED_RGB uint32_t
+
+#define Get_BValue( rgb) ((int)( (rgb) >> 16))
+#define Get_GValue( rgb) ((int)( (rgb) >> 8) & 0xff)
+#define Get_RValue( rgb) ((int)((rgb) & 0xff))
+
+#ifdef PDC_WIDE
+   #if !defined( UNICODE)
+      # define UNICODE
+   #endif
+   #if !defined( _UNICODE)
+      # define _UNICODE
+   #endif
+#endif
+
+#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
+# define _CRT_SECURE_NO_DEPRECATE 1   /* kill nonsense warnings */
+#endif
+
+void PDC_puts_to_stdout( const char *buff);        /* pdcdisp.c */
diff --git a/lib/PDCursesMod/ansi/pdcclip.c b/lib/PDCursesMod/ansi/pdcclip.c
new file mode 100644
index 00000000000..634a3c83078
--- /dev/null
+++ b/lib/PDCursesMod/ansi/pdcclip.c
@@ -0,0 +1,72 @@
+/* PDCurses */
+
+#include <curspriv.h>
+
+/*man-start**************************************************************
+
+clipboard
+---------
+
+### Synopsis
+
+    int PDC_getclipboard(char **contents, long *length);
+    int PDC_setclipboard(const char *contents, long length);
+    int PDC_freeclipboard(char *contents);
+    int PDC_clearclipboard(void);
+
+### Description
+
+   PDC_getclipboard() gets the textual contents of the system's
+   clipboard. This function returns the contents of the clipboard in the
+   contents argument. It is the responsibility of the caller to free the
+   memory returned, via PDC_freeclipboard(). The length of the clipboard
+   contents is returned in the length argument.
+
+   PDC_setclipboard copies the supplied text into the system's
+   clipboard, emptying the clipboard prior to the copy.
+
+   PDC_clearclipboard() clears the internal clipboard.
+
+### Return Values
+
+   indicator of success/failure of call.
+   PDC_CLIP_SUCCESS        the call was successful
+   PDC_CLIP_MEMORY_ERROR   unable to allocate sufficient memory for
+                           the clipboard contents
+   PDC_CLIP_EMPTY          the clipboard contains no text
+   PDC_CLIP_ACCESS_ERROR   no clipboard support
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    PDC_getclipboard            -       -       -
+    PDC_setclipboard            -       -       -
+    PDC_freeclipboard           -       -       -
+    PDC_clearclipboard          -       -       -
+
+**man-end****************************************************************/
+
+int PDC_clearclipboard( void)
+{
+   return( 0);
+}
+
+int PDC_freeclipboard( char *contents)
+{
+   INTENTIONALLY_UNUSED_PARAMETER( contents);
+   return( 0);
+}
+
+int PDC_getclipboard( char **contents, long *length)
+{
+   INTENTIONALLY_UNUSED_PARAMETER( contents);
+   INTENTIONALLY_UNUSED_PARAMETER( length);
+   return( 0);
+}
+
+int PDC_setclipboard( const char *contents, long length)
+{
+   INTENTIONALLY_UNUSED_PARAMETER( contents);
+   INTENTIONALLY_UNUSED_PARAMETER( length);
+   return( 0);
+}
+
diff --git a/lib/PDCursesMod/ansi/pdcdisp.c b/lib/PDCursesMod/ansi/pdcdisp.c
new file mode 100644
index 00000000000..387a3f98882
--- /dev/null
+++ b/lib/PDCursesMod/ansi/pdcdisp.c
@@ -0,0 +1,305 @@
+#include <wchar.h>
+#include <assert.h>
+#include <errno.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "curspriv.h"
+#include "pdcansi.h"
+
+#ifdef PDC_WIDE
+   #define USE_UNICODE_ACS_CHARS 1
+#else
+   #define USE_UNICODE_ACS_CHARS 0
+#endif
+
+#include "../common/acs_defs.h"
+#include "../common/pdccolor.h"
+
+                   /* Rarely,  writes to stdout fail if a signal handler is
+                      called.  In which case we just try to write out the
+                      remainder of the buffer until success happens.     */
+
+#define TBUFF_SIZE 512
+
+static void put_to_stdout( const char *buff, size_t bytes_out)
+{
+    static char *tbuff = NULL;
+    static size_t bytes_cached;
+    const int stdout_fd = 1;
+
+    if( !buff && !tbuff)
+        return;
+
+    if( !buff && bytes_out == 1)        /* release memory at shutdown */
+    {
+        free( tbuff);
+        tbuff = NULL;
+        bytes_cached = 0;
+        return;
+    }
+
+    if( buff && !tbuff)
+        tbuff = (char *)malloc( TBUFF_SIZE);
+    while( bytes_out || (!buff && bytes_cached))
+    {
+        if( buff)
+        {
+            size_t n_copy = bytes_out;
+
+            if( n_copy > TBUFF_SIZE - bytes_cached)
+                n_copy = TBUFF_SIZE - bytes_cached;
+            memcpy( tbuff + bytes_cached, buff, n_copy);
+            buff += n_copy;
+            bytes_out -= n_copy;
+            bytes_cached += n_copy;
+        }
+        if( bytes_cached == TBUFF_SIZE || !buff)
+            while( bytes_cached)
+            {
+                const size_t bytes_written = write( stdout_fd, tbuff, bytes_cached);
+
+                bytes_cached -= bytes_written;
+                if( bytes_cached)
+                    memmove( tbuff, tbuff + bytes_written, bytes_cached);
+            }
+    }
+}
+
+void PDC_puts_to_stdout( const char *buff)
+{
+   put_to_stdout( buff, (buff ? strlen( buff) : 1));
+}
+
+void PDC_gotoyx(int y, int x)
+{
+   char tbuff[50];
+
+   snprintf( tbuff, sizeof( tbuff), "\033[%d;%dH", y + 1, x + 1);
+   PDC_puts_to_stdout( tbuff);
+}
+
+#define RESET_ATTRS   "\033[0m"
+#define ITALIC_ON     "\033[3m"
+#define ITALIC_OFF    "\033[23m"
+#define UNDERLINE_ON  "\033[4m"
+#define UNDERLINE_OFF "\033[24m"
+#define BLINK_ON      "\033[5m"
+#define BLINK_OFF     "\033[25m"
+#define BOLD_ON       "\033[1m"
+#define BOLD_OFF      "\033[22m"
+#define DIM_ON        "\033[2m"
+#define DIM_OFF       "\033[22m"
+#define REVERSE_ON    "\033[7m"
+#define STRIKEOUT_ON  "\033[9m"
+
+const chtype MAX_UNICODE = 0x110000;
+
+/* see 'addch.c' for an explanation of how combining chars are handled. */
+
+#ifdef USING_COMBINING_CHARACTER_SCHEME
+   int PDC_expand_combined_characters( const cchar_t c, cchar_t *added);  /* addch.c */
+#endif
+
+static void color_string( char *otext, const PACKED_RGB rgb)
+{
+   const int red = Get_RValue( rgb);
+   const int green = Get_GValue( rgb);
+   const int blue = Get_BValue( rgb);
+
+      {
+      int idx;
+
+      if( red == green && red == blue)   /* gray scale: indices from */
+         {
+         if( red < 27)     /* this would underflow; remap to black */
+            idx = COLOR_BLACK;
+         else if( red >= 243)    /* this would overflow */
+            idx = COLOR_WHITE;
+         else
+            idx = (red - 3) / 10 + 232;     /* 232 to 255 */
+         }
+      else
+         idx = ((blue - 35) / 40) + ((green - 35) / 40) * 6
+                  + ((red - 35) / 40) * 36 + 16;
+
+      sprintf( otext, "5;%dm", idx);
+      }
+}
+
+static int get_sixteen_color_idx( const PACKED_RGB rgb)
+{
+    int rval = 0;
+
+    if( rgb & 0x80)    /* red value >= 128 */
+        rval = 1;
+    if( rgb & 0x8000)      /* green value >= 128 */
+        rval |= 2;
+    if( rgb & 0x800000)        /* blue value >= 128 */
+        rval |= 4;
+    return( rval);
+}
+
+static void reset_color( char *obuff, const chtype ch)
+{
+    static PACKED_RGB prev_bg = (PACKED_RGB)-1;
+    static PACKED_RGB prev_fg = (PACKED_RGB)-1;
+    PACKED_RGB bg, fg;
+
+    if( !obuff)
+        {
+        prev_bg = prev_fg = (PACKED_RGB)-1;
+        return;
+        }
+    PDC_get_rgb_values( ch, &fg, &bg);
+    *obuff = '\0';
+    if( bg != prev_bg)
+        {
+        if( bg == (PACKED_RGB)-1)   /* default background */
+            strcpy( obuff, "\033[49m");
+        else if( !bg)
+            strcpy( obuff, "\033[40m");
+        else if( COLORS == 16)
+            sprintf( obuff, "\033[4%dm", get_sixteen_color_idx( bg));
+        else
+            {
+            strcpy( obuff, "\033[48;");
+            color_string( obuff + 5, bg);
+            }
+        prev_bg = bg;
+        }
+
+    if( fg != prev_fg)
+        {
+        obuff += strlen( obuff);
+        if( fg == (PACKED_RGB)-1)   /* default foreground */
+            strcpy( obuff, "\033[39m");
+        else if( COLORS == 16)
+            sprintf( obuff, "\033[3%dm", get_sixteen_color_idx( fg));
+        else
+            {
+            strcpy( obuff, "\033[38;");
+            color_string( obuff + 5, fg);
+            }
+        prev_fg = fg;
+        }
+}
+
+int PDC_wc_to_utf8( char *dest, const int32_t code);
+
+#define OBUFF_SIZE 100
+
+void PDC_transform_line(int lineno, int x, int len, const chtype *srcp)
+{
+    static chtype prev_ch = 0;
+    static bool force_reset_all_attribs = TRUE;
+    char obuff[OBUFF_SIZE];
+
+    if( !srcp)
+    {
+        prev_ch = 0;
+        force_reset_all_attribs = TRUE;
+        PDC_puts_to_stdout( RESET_ATTRS);
+        return;
+    }
+    assert( x >= 0);
+    assert( len <= SP->cols - x);
+    assert( lineno >= 0);
+    assert( lineno < SP->lines);
+    assert( len > 0);
+    PDC_gotoyx( lineno, x);
+    if( force_reset_all_attribs || (!x && !lineno))
+    {
+        force_reset_all_attribs = FALSE;
+        prev_ch = ~*srcp;
+    }
+    while( len)
+    {
+       int ch = (int)( *srcp & A_CHARTEXT), count = 1;
+       chtype changes = *srcp ^ prev_ch;
+       size_t bytes_out = 0;
+
+       if( (*srcp & A_ALTCHARSET) && ch < 0x80)
+          ch = (int)acs_map[ch & 0x7f];
+       if( ch < (int)' ' || (ch >= 0x80 && ch <= 0x9f))
+          ch = ' ';
+       *obuff = '\0';
+       if( (prev_ch & ~*srcp) & (A_REVERSE | A_STRIKEOUT))
+       {
+          prev_ch = 0;
+          changes = *srcp;
+          strcpy( obuff, RESET_ATTRS);
+          reset_color( NULL, 0);
+       }
+       if( SP->termattrs & changes & A_BOLD)
+          strcat( obuff, (*srcp & A_BOLD) ? BOLD_ON : BOLD_OFF);
+       if( changes & A_UNDERLINE)
+          strcat( obuff, (*srcp & A_UNDERLINE) ? UNDERLINE_ON : UNDERLINE_OFF);
+       if( changes & A_ITALIC)
+          strcat( obuff, (*srcp & A_ITALIC) ? ITALIC_ON : ITALIC_OFF);
+       if( changes & A_REVERSE)
+          strcat( obuff, REVERSE_ON);
+       if( changes & A_STRIKEOUT)
+          strcat( obuff, STRIKEOUT_ON);
+       if( SP->termattrs & changes & A_BLINK)
+          strcat( obuff, (*srcp & A_BLINK) ? BLINK_ON : BLINK_OFF);
+       if( changes & (A_COLOR | A_STANDOUT | A_BLINK | A_REVERSE))
+          reset_color( obuff + strlen( obuff), *srcp & ~A_REVERSE);
+       PDC_puts_to_stdout( obuff);
+#ifdef USING_COMBINING_CHARACTER_SCHEME
+       if( ch > (int)MAX_UNICODE)      /* chars & fullwidth supported */
+       {
+           cchar_t root, newchar;
+
+           root = ch;
+           while( (root = PDC_expand_combined_characters( root,
+                              &newchar)) > MAX_UNICODE)
+               ;
+           bytes_out = PDC_wc_to_utf8( obuff, (wchar_t)root);
+           root = ch;
+           while( (root = PDC_expand_combined_characters( root,
+                              &newchar)) > MAX_UNICODE)
+               {
+               bytes_out += PDC_wc_to_utf8( obuff + bytes_out, (wchar_t)newchar);
+               if( bytes_out > OBUFF_SIZE - 6)
+                  {
+                  put_to_stdout( obuff, bytes_out);
+                  bytes_out = 0;
+                  }
+               }
+           bytes_out += PDC_wc_to_utf8( obuff + bytes_out, (wchar_t)newchar);
+       }
+       else if( ch < (int)MAX_UNICODE)
+#endif
+       {
+           bytes_out = PDC_wc_to_utf8( obuff, (wchar_t)ch);
+           while( count < len && !((srcp[0] ^ srcp[count]) & ~A_CHARTEXT)
+                        && (ch = (srcp[count] & A_CHARTEXT)) < MAX_UNICODE)
+           {
+               if( (srcp[count] & A_ALTCHARSET) && ch < 0x80)
+                  ch = (int)acs_map[ch & 0x7f];
+               if( ch < (int)' ' || (ch >= 0x80 && ch <= 0x9f))
+                  ch = ' ';
+               bytes_out += PDC_wc_to_utf8( obuff + bytes_out, (wchar_t)ch);
+               if( bytes_out > OBUFF_SIZE - 6)
+                  {
+                  put_to_stdout( obuff, bytes_out);
+                  bytes_out = 0;
+                  }
+               count++;
+           }
+       }
+       put_to_stdout( obuff, bytes_out);
+       bytes_out = 0;
+       prev_ch = *srcp;
+       srcp += count;
+       len -= count;
+   }
+}
+
+void PDC_doupdate(void)
+{
+    put_to_stdout( NULL, 0);
+}
diff --git a/lib/PDCursesMod/ansi/pdcgetsc.c b/lib/PDCursesMod/ansi/pdcgetsc.c
new file mode 100644
index 00000000000..664728d71bb
--- /dev/null
+++ b/lib/PDCursesMod/ansi/pdcgetsc.c
@@ -0,0 +1,27 @@
+/* Public Domain Curses */
+
+#include <curspriv.h>
+
+int PDC_get_cursor_mode(void)
+{
+    PDC_LOG(("PDC_get_cursor_mode() - called\n"));
+
+    return SP->visibility;
+}
+
+
+int PDC_get_columns(void)
+{
+    extern int PDC_cols;
+
+    PDC_LOG(("PDC_get_columns() - called\n"));
+    return( PDC_cols);
+}
+
+int PDC_get_rows(void)
+{
+    extern int PDC_rows;
+
+    PDC_LOG(("PDC_get_rows() - called\n"));
+    return( PDC_rows);
+}
diff --git a/lib/PDCursesMod/ansi/pdckbd.c b/lib/PDCursesMod/ansi/pdckbd.c
new file mode 100644
index 00000000000..bc6b3ff1d1f
--- /dev/null
+++ b/lib/PDCursesMod/ansi/pdckbd.c
@@ -0,0 +1,279 @@
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <sys/select.h>
+#include <unistd.h>
+#include "curspriv.h"
+#include "pdcansi.h"
+
+/* Modified from the accepted answer at
+
+https://stackoverflow.com/questions/33025599/move-the-cursor-in-a-c-program
+
+_kbhit( ) returns -1 if no key has been hit,  and the keycode if one
+has been hit.  You can just loop on it until the return value is >= 0.
+Hitting a function or arrow or similar key will cause 27 (escape) to
+be returned,  followed by cryptic codes that depend on what terminal
+emulation is in place.
+
+   Further info on VT100/ANSI control sequences is at
+
+https://www.gnu.org/software/screen/manual/html_node/Control-Sequences.html
+*/
+
+extern bool PDC_resize_occurred;
+
+static bool check_key( int *c)
+{
+    bool rval;
+    const int STDIN = 0;
+    struct timeval timeout;
+    fd_set rdset;
+
+    if( PDC_resize_occurred)
+       return( TRUE);
+    FD_ZERO( &rdset);
+    FD_SET( STDIN, &rdset);
+    timeout.tv_sec = 0;
+    timeout.tv_usec = 0;
+    if( select( STDIN + 1, &rdset, NULL, NULL, &timeout) > 0)
+       {
+       rval = TRUE;
+       if( c)
+          *c = getchar( );
+       }
+    else
+       rval = FALSE;
+    return( rval);
+}
+
+bool PDC_check_key( void)
+{
+   return( check_key( NULL));
+}
+
+void PDC_flushinp( void)
+{
+   int thrown_away_char;
+
+   while( check_key( &thrown_away_char))
+      ;
+}
+
+#define MAX_COUNT 15
+
+typedef struct
+
+{
+   int key_code;
+   const char *xlation;
+} xlate_t;
+
+static int xlate_vt_codes( const int *c, const int count)
+{
+   static const xlate_t xlates[] =  {
+             { KEY_UP,     "[A"   },
+             { KEY_DOWN,   "[B"   },
+             { KEY_LEFT,   "[D"   },
+             { KEY_RIGHT,  "[C"   },
+             { KEY_HOME,   "OH"   },
+             { KEY_HOME,   "[H"   },
+             { KEY_END,    "OF"   },
+             { KEY_END,    "[F"   },
+             { KEY_END,    "[8~"  },         /* rxvt */
+             { KEY_B2,     "[E"   },
+
+             { KEY_BTAB,   "[Z"   },           /* Shift-Tab */
+             { KEY_IC,     "[2~"  },
+             { KEY_DC,     "[3~"  },
+             { KEY_PPAGE,  "[5~"  },
+             { KEY_NPAGE,  "[6~"  },
+
+             { CTL_LEFT,   "[1;5D"  },
+             { CTL_RIGHT,  "[1;5C"  },
+             { CTL_UP,     "[1;5A"  },
+             { CTL_DOWN,   "[1;5B"  },
+
+             { ALT_PGUP,   "[5;3~"  },
+             { ALT_PGDN,   "[6;3~"  },
+
+             { KEY_F(1),    "[[A"   },      /* Linux console */
+             { KEY_F(2),    "[[B"   },
+             { KEY_F(3),    "[[C"   },
+             { KEY_F(4),    "[[D"   },
+             { KEY_F(5),    "[[E"   },
+             { KEY_END,     "[4~"   },
+             { KEY_HOME,    "[1~"   },
+             { KEY_HOME,    "[7~"   },    /* rxvt */
+
+             { KEY_F(1),    "OP"      },
+             { KEY_F(1),    "[11~"    },
+             { KEY_F(2),    "OQ"      },
+             { KEY_F(2),    "[12~"    },
+             { KEY_F(3),    "OR"      },
+             { KEY_F(3),    "[13~"    },
+             { KEY_F(4),    "OS"      },
+             { KEY_F(4),    "[14~"    },
+             { KEY_F(5),    "[15~"    },
+             { KEY_F(6),    "[17~"    },
+             { KEY_F(7),    "[18~"    },
+             { KEY_F(8),    "[19~"    },
+             { KEY_F(9),    "[20~"    },
+             { KEY_F(10),   "[21~"   },
+             { KEY_F(11),   "[23~"   },
+             { KEY_F(12),   "[24~"   },
+             { KEY_F(13),   "[1;2P"  },      /* shift-f1 */
+             { KEY_F(14),   "[1;2Q"  },
+             { KEY_F(15),   "[1;2R"  },
+             { KEY_F(16),   "[1;2S"  },
+             { KEY_F(17),   "[15;2~"   },  /* shift-f5 */
+             { KEY_F(18),   "[17;2~"   },
+             { KEY_F(19),   "[18;2~"   },
+             { KEY_F(20),   "[19;2~"   },
+             { KEY_F(21),   "[20;2~"   },
+             { KEY_F(22),   "[21;2~"   },
+             { KEY_F(23),   "[23;2~"   },  /* shift-f11 */
+             { KEY_F(24),   "[24;2~"   },
+
+             { KEY_F(15),   "[25~"   },    /* shift-f3 on rxvt */
+             { KEY_F(16),   "[26~"   },    /* shift-f4 on rxvt */
+             { KEY_F(17),   "[28~"   },    /* shift-f5 on rxvt */
+             { KEY_F(18),   "[29~"   },    /* shift-f6 on rxvt */
+             { KEY_F(19),   "[31~"   },    /* shift-f7 on rxvt */
+             { KEY_F(20),   "[32~"   },    /* shift-f8 on rxvt */
+             { KEY_F(21),   "[33~"   },    /* shift-f9 on rxvt */
+             { KEY_F(22),   "[34~"   },    /* shift-f10 on rxvt */
+             { KEY_F(23),   "[23$"   },    /* shift-f11 on rxvt */
+             { KEY_F(24),   "[24$"   },    /* shift-f12 on rxvt */
+
+             { ALT_UP,      "[1;3A"   },
+             { ALT_RIGHT,   "[1;3C"   },
+             { ALT_DOWN,    "[1;3B"   },
+             { ALT_LEFT,    "[1;3D"   },
+             { CTL_UP,      "[1;5A"   },
+             { CTL_RIGHT,   "[1;5C"   },
+             { CTL_DOWN,    "[1;5B"   },
+             { CTL_LEFT,    "[1;5D"   },
+             { KEY_SUP,     "[1;2A"   },
+             { KEY_SRIGHT,  "[1;2C"   },
+             { KEY_SDOWN,   "[1;2B"   },
+             { KEY_SLEFT,   "[1;2D"   }  };
+   const size_t n_keycodes = sizeof( xlates) / sizeof( xlates[0]);
+   size_t i;
+   int rval = -1;
+
+   if( count == 1)
+      {
+      if( c[0] >= 'a' && c[0] <= 'z')
+         rval = ALT_A + c[0] - 'a';
+      else if( c[0] >= '0' && c[0] <= '9')
+         rval = ALT_0 + c[0] - '0';
+      else
+         {
+         const char *text = "',./[];`\x1b\\=-\x0a\x7f";
+         const char *tptr = strchr( text, c[0]);
+         const int codes[] = { ALT_FQUOTE, ALT_COMMA, ALT_STOP, ALT_FSLASH,
+                     ALT_LBRACKET, ALT_RBRACKET,
+                     ALT_SEMICOLON, ALT_BQUOTE, ALT_ESC,
+                     ALT_BSLASH, ALT_EQUAL, ALT_MINUS, ALT_ENTER, ALT_BKSP };
+
+         if( tptr)
+             rval = codes[tptr - text];
+         }
+      }
+   if( count >= 2)
+      for( i = 0; rval == -1 && i < n_keycodes; i++)
+         {
+         int j = 0;
+
+         while( j < count && xlates[i].xlation[j]
+                               && xlates[i].xlation[j] == c[j])
+            j++;
+         if( j == count && !xlates[i].xlation[j])
+            rval = xlates[i].key_code;
+         }
+   return( rval);
+}
+
+int PDC_get_key( void)
+{
+   int rval = -1;
+
+   if( PDC_resize_occurred)
+      {
+      PDC_resize_occurred = FALSE;
+      return( KEY_RESIZE);
+      }
+   if( check_key( &rval))
+      {
+      int c[MAX_COUNT];
+
+      SP->key_code = (rval == 27);
+      if( rval == 27)
+         {
+         int count = 0;
+
+         rval = -1;
+         while( rval == -1 && count < MAX_COUNT && check_key( &c[count]))
+            {
+            count++;
+            rval = xlate_vt_codes( c, count);
+            if( rval == ALT_LBRACKET && check_key( NULL))
+               rval = -1;
+            }
+         if( !count)             /* Escape hit */
+            {
+            SP->key_code = 0;
+            rval = 27;
+            }
+         count--;
+         }
+      else if( (rval & 0xc0) == 0xc0)      /* start of UTF-8 */
+         {
+         check_key( &c[0]);
+         assert( (c[0] & 0xc0) == 0x80);
+         c[0] &= 0x3f;
+         if( !(rval & 0x20))      /* two-byte : U+0080 to U+07ff */
+            rval = c[0] | ((rval & 0x1f) << 6);
+         else
+            {
+            check_key( &c[1]);
+            assert( (c[1] & 0xc0) == 0x80);
+            c[1] &= 0x3f;
+            if( !(rval & 0x10))   /* three-byte : U+0800 - U+ffff */
+               rval = (c[1] | (c[0] << 6) | ((rval & 0xf) << 12));
+            else              /* four-byte : U+FFFF - U+10FFFF : SMP */
+               {              /* (Supplemental Multilingual Plane) */
+               check_key( &c[2]);
+               assert( (c[2] & 0xc0) == 0x80);
+               c[2] &= 0x3f;
+               rval = (c[2] | (c[1] << 6) | (c[0] << 12) | ((rval & 0xf) << 18));
+               }
+            }
+         }
+      else if( rval == 127)
+         rval = 8;
+      }
+   return( rval);
+}
+
+int PDC_modifiers_set( void)
+{
+   return( OK);
+}
+
+bool PDC_has_mouse( void)
+{
+    return FALSE;
+}
+
+int PDC_mouse_set( void)
+{
+   return(  OK);
+}
+
+void PDC_set_keyboard_binary( bool on)
+{
+   INTENTIONALLY_UNUSED_PARAMETER( on);
+   return;
+}
diff --git a/lib/PDCursesMod/ansi/pdcscrn.c b/lib/PDCursesMod/ansi/pdcscrn.c
new file mode 100644
index 00000000000..9afccf814d1
--- /dev/null
+++ b/lib/PDCursesMod/ansi/pdcscrn.c
@@ -0,0 +1,255 @@
+// #define USE_TERMIOS
+
+#ifdef USE_TERMIOS
+#include <string.h>
+#include <signal.h>
+#include <unistd.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+
+static struct termios orig_term;
+#endif
+
+#include <assert.h>
+#include "curspriv.h"
+#include "pdcansi.h"
+#include "../common/pdccolor.h"
+#include "../common/pdccolor.c"
+
+#ifdef USING_COMBINING_CHARACTER_SCHEME
+int PDC_expand_combined_characters( const cchar_t c, cchar_t *added);
+#endif
+
+int PDC_rows = -1, PDC_cols = -1;
+bool PDC_resize_occurred = FALSE;
+const int STDIN = 0;
+chtype PDC_capabilities = 0;
+static mmask_t _stored_trap_mbe;
+
+/* COLOR_PAIR to attribute encoding table. */
+
+void PDC_reset_prog_mode( void)
+{
+#ifdef USE_TERMIOS
+    struct termios term;
+
+    tcgetattr( STDIN, &orig_term);
+    memcpy( &term, &orig_term, sizeof( term));
+    term.c_lflag &= ~(ICANON | ECHO);
+    tcsetattr( STDIN, TCSANOW, &term);
+#endif
+    PDC_puts_to_stdout( "\033[?47h");      /* Save screen */
+    PDC_puts_to_stdout( "\033" "7");         /* save cursor & attribs (VT100) */
+
+    SP->_trap_mbe = _stored_trap_mbe;
+    PDC_mouse_set( );          /* clear any mouse event captures */
+    PDC_resize_occurred = FALSE;
+}
+
+void PDC_reset_shell_mode( void)
+{
+}
+
+static int initial_PDC_rows, initial_PDC_cols;
+
+int PDC_resize_screen(int nlines, int ncols)
+{
+   if( PDC_rows == -1)     /* initscr( ) hasn't been called;  we're just */
+      {                    /* setting desired size at startup */
+      initial_PDC_rows = nlines;
+      initial_PDC_cols = ncols;
+      }
+   return( 0);
+}
+
+void PDC_restore_screen_mode(int i)
+{
+    INTENTIONALLY_UNUSED_PARAMETER( i);
+}
+
+void PDC_save_screen_mode(int i)
+{
+    INTENTIONALLY_UNUSED_PARAMETER( i);
+}
+
+void PDC_scr_close( void)
+{
+   PDC_puts_to_stdout( "\033" "8");         /* restore cursor & attribs (VT100) */
+   PDC_puts_to_stdout( "\033[m");         /* set default screen attributes */
+   PDC_puts_to_stdout( "\033[?47l");      /* restore screen */
+   PDC_curs_set( 2);          /* blinking block cursor */
+   PDC_gotoyx( PDC_cols - 1, 0);
+   _stored_trap_mbe = SP->_trap_mbe;
+   SP->_trap_mbe = 0;
+   PDC_mouse_set( );          /* clear any mouse event captures */
+#ifdef USE_TERMIOS
+   tcsetattr( STDIN, TCSANOW, &orig_term);
+#endif
+   PDC_doupdate( );
+   PDC_puts_to_stdout( NULL);      /* free internal cache */
+   return;
+}
+
+void PDC_scr_free( void)
+{
+    PDC_free_palette( );
+#ifdef USING_COMBINING_CHARACTER_SCHEME
+    PDC_expand_combined_characters( 0, NULL);
+#endif
+}
+
+#ifdef USE_TERMIOS
+static void sigwinchHandler( int sig)
+{
+   struct winsize ws;
+
+   INTENTIONALLY_UNUSED_PARAMETER( sig);
+   if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) != -1)
+      if( PDC_rows != ws.ws_row || PDC_cols != ws.ws_col)
+         {
+         PDC_rows = ws.ws_row;
+         PDC_cols = ws.ws_col;
+         PDC_resize_occurred = TRUE;
+         if (SP)
+            SP->resized = TRUE;
+         }
+}
+
+static void sigintHandler( int sig)
+{
+    INTENTIONALLY_UNUSED_PARAMETER( sig);
+    if( !SP->raw_inp)
+    {
+        PDC_scr_close( );
+        PDC_scr_free( );
+        exit( 0);
+    }
+}
+#endif
+
+#define MAX_LINES 1000
+#define MAX_COLUMNS 1000
+
+int PDC_scr_open(void)
+{
+#ifdef USE_TERMIOS
+    struct sigaction sa;
+#endif
+
+    PDC_LOG(("PDC_scr_open called\n"));
+    COLORS = 16;
+    assert( SP);
+    if (!SP || PDC_init_palette( ))
+        return ERR;
+
+    setbuf( stdin, NULL);
+#ifdef USE_TERMIOS
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+    sa.sa_handler = sigwinchHandler;
+    if (sigaction(SIGWINCH, &sa, NULL) == -1)
+    {
+        fprintf( stderr, "Sigaction failed\n");
+        return( -1);
+    }
+    sigwinchHandler( 0);
+
+    sa.sa_handler = sigintHandler;
+    if (sigaction(SIGINT, &sa, NULL) == -1)
+    {
+        fprintf( stderr, "Sigaction (INT) failed\n");
+        return( -1);
+    }
+#else
+    {
+        const char *env = getenv("PDC_LINES");
+
+        PDC_rows = (env ? atoi( env) : 25);
+        env = getenv( "PDC_COLS");
+        PDC_cols = (env ? atoi( env) : 80);
+    }
+#endif
+    SP->mouse_wait = PDC_CLICK_PERIOD;
+    SP->visibility = 0;                /* no cursor,  by default */
+    SP->curscol = SP->cursrow = 0;
+    SP->audible = TRUE;
+    SP->mono = FALSE;
+    SP->orig_attr = TRUE;
+    SP->orig_fore = SP->orig_back = -1;
+    SP->termattrs = PDC_capabilities & ~A_BLINK;
+
+    while( PDC_get_rows( ) < 1 && PDC_get_columns( ) < 1)
+      ;     /* wait for screen to be drawn and size determined */
+    if( initial_PDC_rows > 1 && initial_PDC_cols > 1)
+    {
+        PDC_resize_screen( initial_PDC_rows, initial_PDC_cols);
+        while( PDC_get_rows( ) != initial_PDC_rows
+            && PDC_get_columns( ) != initial_PDC_rows)
+           ;
+    }
+
+    SP->lines = PDC_get_rows();
+    SP->cols = PDC_get_columns();
+
+    if (SP->lines < 2 || SP->lines > MAX_LINES
+       || SP->cols < 2 || SP->cols > MAX_COLUMNS)
+    {
+        fprintf(stderr, "LINES value must be >= 2 and <= %d: got %d\n",
+                MAX_LINES, SP->lines);
+        fprintf(stderr, "COLS value must be >= 2 and <= %d: got %d\n",
+                MAX_COLUMNS, SP->cols);
+
+        return ERR;
+    }
+
+    PDC_reset_prog_mode();
+    PDC_LOG(("PDC_scr_open exit\n"));
+    return( 0);
+}
+
+int PDC_set_function_key( const unsigned function, const int new_key)
+{
+   INTENTIONALLY_UNUSED_PARAMETER( function);
+   INTENTIONALLY_UNUSED_PARAMETER( new_key);
+   return( 0);
+}
+
+void PDC_set_resize_limits( const int new_min_lines,
+                            const int new_max_lines,
+                            const int new_min_cols,
+                            const int new_max_cols)
+{
+   INTENTIONALLY_UNUSED_PARAMETER( new_min_lines);
+   INTENTIONALLY_UNUSED_PARAMETER( new_max_lines);
+   INTENTIONALLY_UNUSED_PARAMETER( new_min_cols);
+   INTENTIONALLY_UNUSED_PARAMETER( new_max_cols);
+   return;
+}
+
+
+bool PDC_can_change_color(void)
+{
+    return TRUE;
+}
+
+int PDC_color_content( int color, int *red, int *green, int *blue)
+{
+    const PACKED_RGB col = PDC_get_palette_entry( color);
+
+    *red = DIVROUND( Get_RValue(col) * 1000, 255);
+    *green = DIVROUND( Get_GValue(col) * 1000, 255);
+    *blue = DIVROUND( Get_BValue(col) * 1000, 255);
+
+    return OK;
+}
+
+int PDC_init_color( int color, int red, int green, int blue)
+{
+    const PACKED_RGB new_rgb = PACK_RGB(DIVROUND(red * 255, 1000),
+                                 DIVROUND(green * 255, 1000),
+                                 DIVROUND(blue * 255, 1000));
+
+    if( !PDC_set_palette_entry( color, new_rgb))
+        curscr->_clear = TRUE;
+    return OK;
+}
diff --git a/lib/PDCursesMod/ansi/pdcsetsc.c b/lib/PDCursesMod/ansi/pdcsetsc.c
new file mode 100644
index 00000000000..12bca5bb2d2
--- /dev/null
+++ b/lib/PDCursesMod/ansi/pdcsetsc.c
@@ -0,0 +1,99 @@
+#include <stdio.h>
+#include <curspriv.h>
+#include "pdcansi.h"
+
+/*man-start**************************************************************
+
+pdcsetsc
+--------
+
+### Synopsis
+
+    int PDC_set_blink(bool blinkon);
+    int PDC_set_bold(bool boldon);
+    void PDC_set_title(const char *title);
+
+### Description
+
+   PDC_set_blink() toggles whether the A_BLINK attribute sets an actual
+   blink mode (TRUE), or sets the background color to high intensity
+   (FALSE). The default is platform-dependent (FALSE in most cases). It
+   returns OK if it could set the state to match the given parameter,
+   ERR otherwise.
+
+   PDC_set_bold() toggles whether the A_BOLD attribute selects an actual
+   bold font (TRUE), or sets the foreground color to high intensity
+   (FALSE). It returns OK if it could set the state to match the given
+   parameter, ERR otherwise.
+
+   PDC_set_title() sets the title of the window in which the curses
+   program is running. This function may not do anything on some
+   platforms.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    PDC_set_blink               -       -       -
+    PDC_set_title               -       -       -
+
+**man-end****************************************************************/
+
+    /* #define BLINKING_CURSOR   "\033[?12h"    */
+#define BLINKING_BLOCK      "\033[1 q"
+#define STEADY_BLOCK        "\033[2 q"
+#define BLINKING_UNDERLINE  "\033[3 q"
+#define STEADY_UNDERLINE    "\033[4 q"
+      /* "bar" = "vertical line".  xterm only. */
+#define BLINKING_BAR        "\033[5 q"
+#define STEADY_BAR          "\033[6 q"
+#define CURSOR_ON           "\033[?25h"
+#define CURSOR_OFF          "\033[?25l"
+
+void PDC_puts_to_stdout( const char *buff);
+
+int PDC_curs_set( int visibility)
+{
+    int ret_vis;
+
+    PDC_LOG(("PDC_curs_set() - called: visibility=%d\n", visibility));
+
+    ret_vis = SP->visibility;
+
+    if( !SP->visibility && visibility)    /* turn cursor back on */
+        PDC_puts_to_stdout( CURSOR_ON);
+    else if( SP->visibility && !visibility)
+        PDC_puts_to_stdout( CURSOR_OFF);
+    SP->visibility = visibility;
+    return ret_vis;
+}
+
+static int reset_attr( const attr_t attr, const bool attron)
+{
+    attr_t prev_termattrs;
+
+    if (!SP)
+        return ERR;
+    prev_termattrs = SP->termattrs;
+    if( attron)
+        SP->termattrs |= attr;
+    else
+        SP->termattrs &= ~attr;
+    if( prev_termattrs != SP->termattrs)
+       curscr->_clear = TRUE;
+    return OK;
+}
+
+int PDC_set_blink(bool blinkon)
+{
+   return( reset_attr( A_BLINK, blinkon));
+}
+
+int PDC_set_bold(bool boldon)
+{
+   return( reset_attr( A_BOLD, boldon));
+}
+
+void PDC_set_title( const char *title)
+{
+    (void)title;
+    PDC_LOG(("PDC_set_title() - called:<%s>\n", title));
+}
diff --git a/lib/PDCursesMod/ansi/pdcutil.c b/lib/PDCursesMod/ansi/pdcutil.c
new file mode 100644
index 00000000000..271d2880292
--- /dev/null
+++ b/lib/PDCursesMod/ansi/pdcutil.c
@@ -0,0 +1,19 @@
+#include <unistd.h>
+#include "curspriv.h"
+
+void PDC_beep(void)
+{
+}
+
+void PDC_napms(int ms)
+{
+    usleep(1000 * ms);
+}
+
+
+const char *PDC_sysname(void)
+{
+   return( "ANSI");
+}
+
+enum PDC_port PDC_port_val = PDC_PORT_ANSI;
diff --git a/lib/PDCursesMod/common/acs_defs.h b/lib/PDCursesMod/common/acs_defs.h
new file mode 100644
index 00000000000..58be1518619
--- /dev/null
+++ b/lib/PDCursesMod/common/acs_defs.h
@@ -0,0 +1,265 @@
+/* Many of the following #defines are completely unused for the
+nonce.  For each character,  its code point in code page 437,
+Unicode,  and page 8859-1 are given.  The first is used for
+non-wide builds in Win32 console,  DOS,  SDL,  and OS/2.
+Unicode is used for all wide builds,  and for the non-wide
+build of WinGUI.  Code page 8859-1 is used for non-wide X11.
+
+   All of these characters exist in CP437 and Unicode.  Some
+don't exist in 8859-1,  in which case the last column is 'TBD'.
+Only 32 are used in ncurses.  So caution is advised. */
+
+#ifdef USE_ISO8859_CHARSET
+   #define CHOOSE( A, B, C)   (C)
+   #define TBD '!'
+#else
+   #define CHOOSE( A, B, C) (USE_UNICODE_ACS_CHARS ? B : A)
+#endif
+
+/* Codes found from https://en.wikipedia.org/wiki/Code_page_437 */
+
+#define SMILE                             CHOOSE( 0x01,  0x263a,  'O')
+#define REV_SMILE                         CHOOSE( 0x02,  0x263b,  'O')
+#define HEART                             CHOOSE( 0x03,  0x2665,  'H')
+#define DIAMOND                           CHOOSE( 0x04,  0x2666, 0x01)
+#define CLUB                              CHOOSE( 0x05,  0x2663,  'C')
+#define SPADE                             CHOOSE( 0x06,  0x2660,  'S')
+#define MEDIUM_BULLET                     CHOOSE( 0x07,  0x2022, 0xb7)
+#define REV_BULLET                        CHOOSE( 0x08,  0x2508, 0xb7)
+#define WHITE_BULLET                      CHOOSE( 0x09,  0x25cb,    7)
+#define REV_WHITE_BULLET                  CHOOSE( 0x0a,  0x25D9,    7)
+#define MALE_SYM                          CHOOSE( 0x0b,  0x2642,  'm')
+#define FEMALE_SYM                        CHOOSE( 0x0c,  0x2640,  'f')
+#define QTR_NOTE                          CHOOSE( 0x0d,  0x266a, 0xbc)
+#define EIGHTH_NOTE                       CHOOSE( 0x0e,  0x266b, 0xbd)
+#define SPLAT                             CHOOSE( 0x0f,  0xa4  , 0xa4)
+#define RIGHT_TRIANGLE                    CHOOSE( 0x10,  0x25b6,  '>')
+#define LEFT_TRIANGLE                     CHOOSE( 0x11,  0x25c0,  '<')
+#define UP_DOWN_ARROW                     CHOOSE( 0x12,  0x2195, 0x19)
+#define DBL_BANG                          CHOOSE( 0x13,  0x203c,  '!')
+#define PILCROW                           CHOOSE( 0x14,  0xb6  , 0xb6)
+#define SECTION_SIGN                      CHOOSE( 0x15,  0xa7  , 0xa7)
+#define LOW_QTR_BLOCK                     CHOOSE( 0x16,  0x25b2,  '_')
+#define UP_DOWN_ARROW_UNDERSCORED         CHOOSE( 0x17,  0x21ab, 0x19)
+#define UP_ARROW                          CHOOSE( 0x18,  0x2191,  '^')
+#define DOWN_ARROW                        CHOOSE( 0x19,  0x2193,  'v')
+#define RIGHT_ARROW                       CHOOSE( 0x1a,  0x2192,  '>')
+#define LEFT_ARROW                        CHOOSE( 0x1b,  0x2190,  '<')
+#define RIGHT_ANGLE                       CHOOSE( 0x1c,  0x221f,  0xe)
+#define LEFT_RIGHT_ARROW                  CHOOSE( 0x1d,  0x2194,  '-')
+#define UP_TRIANGLE                       CHOOSE( 0x1e,  0x25b2,  '^')
+#define DOWN_TRIANGLE                     CHOOSE( 0x1f,  0x25bc,  'v')
+
+#define UPPERCASE_C_CEDILLA               CHOOSE( 0x80,  0xc7  , 0xc7)
+#define LOWERCASE_U_UMLAUT                CHOOSE( 0x81,  0xfc  , 0xfc)
+#define LOWERCASE_E_ACUTE                 CHOOSE( 0x82,  0xe9  , 0xe9)
+#define LOWERCASE_A_CIRCUMFLEX            CHOOSE( 0x83,  0xe2  , 0xe2)
+#define LOWERCASE_A_UMLAUT                CHOOSE( 0x84,  0xe4  , 0xe4)
+#define LOWERCASE_A_GRAVE                 CHOOSE( 0x85,  0xe0  , 0xea)
+#define LOWERCASE_A_RING                  CHOOSE( 0x86,  0xe5  , 0xe5)
+#define LOWERCASE_C_CEDILLA               CHOOSE( 0x87,  0xe7  , 0xe7)
+#define LOWERCASE_E_CIRCUMFLEX            CHOOSE( 0x88,  0xea  , 0xea)
+#define LOWERCASE_E_UMLAUT                CHOOSE( 0x89,  0xeb  , 0xeb)
+#define LOWERCASE_E_GRAVE                 CHOOSE( 0x8a,  0xe8  , 0xe8)
+#define LOWERCASE_I_UMLAUT                CHOOSE( 0x8b,  0xef  , 0xef)
+#define LOWERCASE_I_CIRCUMFLEX            CHOOSE( 0x8c,  0xee  , 0xee)
+#define LOWERCASE_I_GRAVE                 CHOOSE( 0x8d,  0xec  , 0xce)
+#define UPPERCASE_A_UMLAUT                CHOOSE( 0x8e,  0xc4  , 0xc4)
+#define UPPERCASE_A_RING                  CHOOSE( 0x8f,  0xc5  , 0xc5)
+
+#define UPPERCASE_E_ACUTE                 CHOOSE( 0x90,  0xc9  , 0xc9)
+#define LOWERCASE_AE_LIGATURE             CHOOSE( 0x91,  0xe6  , 0xe6)
+#define UPPERCASE_AE_LIGATURE             CHOOSE( 0x92,  0xc6  , 0xc6)
+#define LOWERCASE_O_CIRCUMFLEX            CHOOSE( 0x93,  0xf4  , 0xf4)
+#define LOWERCASE_O_UMLAUT                CHOOSE( 0x94,  0xf6  , 0xf6)
+#define LOWERCASE_O_GRAVE                 CHOOSE( 0x95,  0xf2  , 0xf2)
+#define LOWERCASE_U_CIRCUMFLEX            CHOOSE( 0x96,  0xfb  , 0xfb)
+#define LOWERCASE_U_GRAVE                 CHOOSE( 0x97,  0xf9  , 0xf9)
+#define LOWERCASE_Y_UMLAUT                CHOOSE( 0x98,  0xff  , 0xff)
+#define UPPERCASE_O_UMLAUT                CHOOSE( 0x99,  0xd6  , 0xd6)
+#define UPPERCASE_U_UMLAUT                CHOOSE( 0x9a,  0xdc  , 0xdc)
+#define CENT_SIGN                         CHOOSE( 0x9b,  0xa2  , 0xa2)
+#define STERLING_SIGN                     CHOOSE( 0x9c,  0xa3  ,   30)
+#define YEN_SIGN                          CHOOSE( 0x9d,  0xa5  , 0xa5)
+#define PESETA_SIGN                       CHOOSE( 0x9e,  0x20a7,  TBD)
+#define F_WITH_HOOK                       CHOOSE( 0x9f,  0x0192,  TBD)
+
+#define LOWERCASE_A_ACUTE                 CHOOSE( 0xa0,  0xe1  , 0xe1)
+#define LOWERCASE_I_ACUTE                 CHOOSE( 0xa1,  0xed  , 0xed)
+#define LOWERCASE_O_ACUTE                 CHOOSE( 0xa2,  0xf3  , 0xf3)
+#define LOWERCASE_U_ACUTE                 CHOOSE( 0xa3,  0xfa  , 0xfa)
+#define LOWERCASE_N_TILDE                 CHOOSE( 0xa4,  0xf1  , 0xf1)
+#define UPPERCASE_N_TILDE                 CHOOSE( 0xa5,  0xd1  , 0xd1)
+#define A_ORDINAL                         CHOOSE( 0xa6,  0xaa  , 0xaa)
+#define O_ORDINAL                         CHOOSE( 0xa7,  0xba  , 0xba)
+#define INVERTED_QUESTION_MARK            CHOOSE( 0xa8,  0xbf  , 0xbf)
+#define REVERSED_NOT_SIGN                 CHOOSE( 0xa9,  0x2310,  TBD)
+#define NOT_SIGN                          CHOOSE( 0xaa,  0xac  , 0xac)
+#define VULGAR_HALF                       CHOOSE( 0xab,  0xbd  , 0xbd)
+#define VULGAR_QUARTER                    CHOOSE( 0xac,  0xbc  , 0xbc)
+#define INVERTED_EXCLAMATION_MARK         CHOOSE( 0xad,  0xa1  , 0xa1)
+#define LEFT_ANGLE_QUOTE_MARK             CHOOSE( 0xae,  0xab  , 0xab)
+#define RIGHT_ANGLE_QUOTE_MARK            CHOOSE( 0xaf,  0xbb  , 0xbb)
+
+#define LIGHT_SHADE                       CHOOSE( 0xb0,  0x2591, '#' )
+#define MEDIUM_SHADE                      CHOOSE( 0xb1,  0x2592,    2)
+#define DARK_SHADE                        CHOOSE( 0xb2,  0x2593,  TBD)
+#define BOX_VLINE                         CHOOSE( 0xb3,  0x2502,   25)
+#define BOX_RTEE                          CHOOSE( 0xb4,  0x2524,   22)
+#define BOX_SD_RTEE                       CHOOSE( 0xb5,  0x2561,   22)
+#define BOX_DS_RTEE                       CHOOSE( 0xb6,  0x2562,   22)
+#define BOX_DS_URCORNER                   CHOOSE( 0xb7,  0x2556,   12)
+#define BOX_SD_URCORNER                   CHOOSE( 0xb8,  0x2555,   12)
+#define BOX_D_RTEE                        CHOOSE( 0xb9,  0x2563,   22)
+#define BOX_D_VLINE                       CHOOSE( 0xba,  0x2551,   25)
+#define BOX_D_URCORNER                    CHOOSE( 0xbb,  0x2557,   12)
+#define BOX_D_LRCORNER                    CHOOSE( 0xbc,  0x255D,   11)
+#define BOX_DS_LRCORNER                   CHOOSE( 0xbd,  0x255c,   11)
+#define BOX_SD_LRCORNER                   CHOOSE( 0xbe,  0x255b,   11)
+#define BOX_URCORNER                      CHOOSE( 0xbf,  0x2510,   12)
+
+#define BOX_LLCORNER                      CHOOSE( 0xc0,  0x2514,   14)
+#define BOX_BTEE                          CHOOSE( 0xc1,  0x2534,   23)
+#define BOX_TTEE                          CHOOSE( 0xc2,  0x252c,   24)
+#define BOX_LTEE                          CHOOSE( 0xc3,  0x251c,   21)
+#define BOX_HLINE                         CHOOSE( 0xc4,  0x2500,   18)
+#define BOX_PLUS                          CHOOSE( 0xc5,  0x253c,   15)
+#define BOX_SD_LTEE                       CHOOSE( 0xc6,  0x255e,   21)
+#define BOX_DS_LTEE                       CHOOSE( 0xc7,  0x255f,   21)
+#define BOX_D_LLCORNER                    CHOOSE( 0xc8,  0x255A,   14)
+#define BOX_D_ULCORNER                    CHOOSE( 0xc9,  0x2554,   13)
+#define BOX_D_BTEE                        CHOOSE( 0xca,  0x2569,   23)
+#define BOX_D_TTEE                        CHOOSE( 0xcb,  0x2566,   24)
+#define BOX_D_LTEE                        CHOOSE( 0xcc,  0x2560,   21)
+#define BOX_D_HLINE                       CHOOSE( 0xcd,  0x2550,   18)
+#define BOX_D_PLUS                        CHOOSE( 0xce,  0x256C,   15)
+#define BOX_SD_BTEE                       CHOOSE( 0xcf,  0x2567,   23)
+
+#define BOX_DS_BTEE                       CHOOSE( 0xd0,  0x2568,   23)
+#define BOX_SD_TTEE                       CHOOSE( 0xd1,  0x2564,   24)
+#define BOX_DS_TTEE                       CHOOSE( 0xd2,  0x2565,   24)
+#define BOX_DS_LLCORNER                   CHOOSE( 0xd3,  0x2559,   14)
+#define BOX_SD_LLCORNER                   CHOOSE( 0xd4,  0x2558,   14)
+#define BOX_SD_ULCORNER                   CHOOSE( 0xd5,  0x2552,   13)
+#define BOX_DS_ULCORNER                   CHOOSE( 0xd6,  0x2553,   13)
+#define BOX_DS_PLUS                       CHOOSE( 0xd7,  0x256b,   15)
+#define BOX_SD_PLUS                       CHOOSE( 0xd8,  0x256a,   15)
+#define BOX_LRCORNER                      CHOOSE( 0xd9,  0x2518,   11)
+#define BOX_ULCORNER                      CHOOSE( 0xda,  0x250c,   13)
+#define FULL_BLOCK                        CHOOSE( 0xdb,  0x2588,    0)
+#define LOWER_HALF_BLOCK                  CHOOSE( 0xdc,  0x2584,  TBD)
+#define LEFT_HALF_BLOCK                   CHOOSE( 0xdd,  0x258c,  TBD)
+#define RIGHT_HALF_BLOCK                  CHOOSE( 0xde,  0x2590,  TBD)
+#define UPPER_HALF_BLOCK                  CHOOSE( 0xdf,  0x2580,  TBD)
+
+#define ALPHA                             CHOOSE( 0xe0,  0x03b1,  TBD)
+#define BETA                              CHOOSE( 0xe1,  0x00df,  TBD)
+#define GAMMA                             CHOOSE( 0xe2,  0x0393,  TBD)
+#define PI                                CHOOSE( 0xe3,  0x03c0,   28)
+#define UPPERCASE_SIGMA                   CHOOSE( 0xe4,  0x03a3,  TBD)
+#define LOWERCASE_SIGMA                   CHOOSE( 0xe5,  0x03c3,  TBD)
+#define MU                                CHOOSE( 0xe6,  0x00b5, 0xb5)
+#define TAU                               CHOOSE( 0xe7,  0x03c4,  TBD)
+#define UPPERCASE_PHI                     CHOOSE( 0xe8,  0x03a6,  TBD)
+#define THETA                             CHOOSE( 0xe9,  0x0398,  TBD)
+#define OMEGA                             CHOOSE( 0xea,  0x03a9,  TBD)
+#define DELTA                             CHOOSE( 0xeb,  0x03b4,  TBD)
+#define INFINITY_SIGN                     CHOOSE( 0xec,  0x221e,  TBD)
+#define LOWERCASE_PHI                     CHOOSE( 0xed,  0x03c6,  TBD)
+#define EPSILON                           CHOOSE( 0xee,  0x03b5,  TBD)
+#define INTERSECTION                      CHOOSE( 0xef,  0x2229,  TBD)
+
+#define TRIPLE_BAR                        CHOOSE( 0xf0,  0x2261,  TBD)
+#define PLUS_OR_MINUS                     CHOOSE( 0xf1,  0x00b1,    8)
+#define GREATER_THAN_OR_EQUAL_TO          CHOOSE( 0xf2,  0x2265,   27)
+#define LESSER_THAN_OR_EQUAL_TO           CHOOSE( 0xf3,  0x2264,   26)
+#define UPPER_HALF_INTEGRAL_SIGN          CHOOSE( 0xf4,  0x2320,  TBD)
+#define LOWER_HALF_INTEGRAL_SIGN          CHOOSE( 0xf5,  0x2321,  TBD)
+#define DIVISION_SIGN                     CHOOSE( 0xf6,  0x00f7, 0xf7)
+#define APPROXIMATELY_EQUALS_SIGN         CHOOSE( 0xf7,  0x2248,  TBD)
+#define DEGREE_SIGN                       CHOOSE( 0xf8,  0x00b0, 0xb0)
+#define LARGE_BULLET                      CHOOSE( 0xf9,  0x2219,    7)
+#define SMALL_BULLET                      CHOOSE( 0xfa,  0x00b7, 0xb7)
+#define SQUARE_ROOT                       CHOOSE( 0xfb,  0x221a,  TBD)
+#define SUPERSCRIPT_N                     CHOOSE( 0xfc,  0x207f,  TBD)
+#define SUPERSCRIPT_2                     CHOOSE( 0xfd,  0x00b2, 0xb2)
+#define CENTERED_SQUARE                   CHOOSE( 0xfe,  0x25a0,  TBD)
+#define NON_BREAKING_SPACE                CHOOSE( 0xff,  0x00a0, 0xa0)
+
+
+
+      /* It says at http://unicode.org/charts/PDF/U2300.pdf */
+      /* that '...the scan line numbers here refer to old,  */
+      /* low-resolution technology for terminals, with only */
+      /* nine scan lines per fixed-size character glyph.    */
+      /* Even-numbered scan lines are unified with box      */
+      /* drawing graphics."                                 */
+      /*  The utility of these is questionable;  they'd     */
+      /* work Just Fine in wingdi (_if_ the appropriate     */
+      /* glyphs are available),  but not elsewhere.         */
+#define HORIZ_SCAN_LINE_1                 CHOOSE( 0x2d,  0x23ba,   16)
+#define HORIZ_SCAN_LINE_3                 CHOOSE( 0x2d,  0x23bb,   17)
+#define HORIZ_SCAN_LINE_7                 CHOOSE( 0x2d,  0x23bc,   19)
+#define HORIZ_SCAN_LINE_9                 CHOOSE(  '_',  0x23bd,   20)
+
+      /* Code page 437 lacks a 'for real' not-equals,  so for that, */
+      /* we use the double-horizontal single-vertical box drawing : */
+#define NOT_EQUALS_SIGN                   CHOOSE( 0xd8, 0x2260,    29)
+
+# define A(x) ((chtype)x | A_ALTCHARSET)
+
+chtype acs_map[128] =
+{
+   A(0), A(1), A(2), A(3), A(4), A(5), A(6), A(7), A(8),
+   A(9), A(10),
+   CLUB, HEART, SPADE, SMILE, REV_SMILE,                      /* 11 12 13 14 15 */
+   MEDIUM_BULLET, WHITE_BULLET, PILCROW, SECTION_SIGN,        /* 16 17 18 19 */
+   A_ORDINAL, O_ORDINAL, LOWERCASE_PHI,                       /* 20 21 22 */
+   INVERTED_EXCLAMATION_MARK, INVERTED_QUESTION_MARK,         /* 23 24 */
+   REVERSED_NOT_SIGN, NOT_SIGN,                               /* 25 26 */
+   UPPER_HALF_INTEGRAL_SIGN, LOWER_HALF_INTEGRAL_SIGN,        /* 27 28   */
+   SUPERSCRIPT_N, CENTERED_SQUARE, F_WITH_HOOK,               /* 29 30 31 */
+
+   RIGHT_ARROW, LEFT_ARROW, UP_ARROW, DOWN_ARROW,             /* 32 !"# */
+
+   PI, NOT_EQUALS_SIGN,  VULGAR_HALF, VULGAR_QUARTER,         /* $%&' */
+   '(',
+   LEFT_ANGLE_QUOTE_MARK, RIGHT_ANGLE_QUOTE_MARK,             /* )* */
+   DARK_SHADE, SUPERSCRIPT_2, INFINITY_SIGN,                  /* +,- */
+   ALPHA, BETA, GAMMA, UPPERCASE_SIGMA, LOWERCASE_SIGMA,      /* ./012  */
+   '3',
+   MU, TAU, UPPERCASE_PHI, THETA, OMEGA, DELTA, EPSILON,      /* 456789: */
+
+   BOX_SD_LRCORNER, BOX_SD_URCORNER, BOX_SD_ULCORNER,         /* ;<= */
+   BOX_SD_LLCORNER, BOX_SD_PLUS,                              /* >? */
+   BOX_SD_LTEE, BOX_SD_RTEE, BOX_SD_BTEE, BOX_SD_TTEE,        /* @ABC */
+
+   BOX_D_LRCORNER, BOX_D_URCORNER, BOX_D_ULCORNER,             /* DEF */
+   BOX_D_LLCORNER, BOX_D_PLUS,                                 /* GH */
+   BOX_D_LTEE, BOX_D_RTEE, BOX_D_BTEE, BOX_D_TTEE,             /* IJKL */
+
+   BOX_DS_LRCORNER, BOX_DS_URCORNER, BOX_DS_ULCORNER,          /* MNO */
+   BOX_DS_LLCORNER, BOX_DS_PLUS,                               /* PQ */
+   BOX_DS_LTEE, BOX_DS_RTEE, BOX_DS_BTEE, BOX_DS_TTEE,         /* RSTU */
+
+   BOX_LRCORNER, BOX_URCORNER, BOX_ULCORNER,                   /* VWX */
+   BOX_LLCORNER, BOX_PLUS,                                     /* YZ */
+   BOX_LTEE, BOX_RTEE, BOX_BTEE, BOX_TTEE,                     /* [\]^ */
+
+   BOX_HLINE, BOX_VLINE, BOX_D_HLINE, BOX_D_VLINE,             /* _`ab */
+
+   DIVISION_SIGN, APPROXIMATELY_EQUALS_SIGN,                   /* cd */
+   INTERSECTION, TRIPLE_BAR,                                   /* ef */
+   SMALL_BULLET, LARGE_BULLET, SQUARE_ROOT,                    /* ghi */
+   DIAMOND, MEDIUM_SHADE,                                      /* jk */
+   HORIZ_SCAN_LINE_1, HORIZ_SCAN_LINE_3,                       /* lm */
+   HORIZ_SCAN_LINE_7, HORIZ_SCAN_LINE_9,                       /* no */
+   UPPER_HALF_BLOCK, LOWER_HALF_BLOCK,                         /* pq */
+   LEFT_HALF_BLOCK, RIGHT_HALF_BLOCK, FULL_BLOCK,              /* rst */
+   LESSER_THAN_OR_EQUAL_TO, GREATER_THAN_OR_EQUAL_TO,          /* uv */
+   DEGREE_SIGN, PLUS_OR_MINUS, LIGHT_SHADE, SPLAT,             /* wxyz */
+   CENT_SIGN, YEN_SIGN, PESETA_SIGN, STERLING_SIGN,            /* {|}~ */
+    A(127)
+};
+
+# undef A
diff --git a/lib/PDCursesMod/common/font437.h b/lib/PDCursesMod/common/font437.h
new file mode 100644
index 00000000000..1157953beb2
--- /dev/null
+++ b/lib/PDCursesMod/common/font437.h
@@ -0,0 +1,386 @@
+/* Default font for SDL (narrow build) -- this is simply a 256x128x1
+   BMP, in #include'able form. The font is 8x16, code page 437, and is
+   based on the pc8x16s.bdf font from the vgafonts.tar.gz package, by
+   "Myrlin". */
+
+unsigned char font437[] =
+{
+    0x42, 0x4d, 0x3e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e,
+    0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
+    0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x10, 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x12, 0x0b,
+    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
+    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x60,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x76, 0xf8, 0xc0, 0x6c, 0xfe, 0x70, 0x7c, 0x18,
+    0x7e, 0x38, 0xee, 0x3c, 0x00, 0xc0, 0x1c, 0xc6, 0x00, 0x7e, 0x7e,
+    0x7e, 0x18, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00,
+    0x00, 0x00, 0xdc, 0xcc, 0xc0, 0x6c, 0xc6, 0xd8, 0x66, 0x18, 0x18,
+    0x6c, 0x6c, 0x66, 0x00, 0x60, 0x30, 0xc6, 0xfe, 0x00, 0x00, 0x00,
+    0x18, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x7e,
+    0x00, 0xd8, 0xcc, 0xc0, 0x6c, 0x60, 0xd8, 0x66, 0x18, 0x3c, 0xc6,
+    0x6c, 0x66, 0x7e, 0x7e, 0x60, 0xc6, 0x00, 0x00, 0x30, 0x0c, 0x18,
+    0xd8, 0x18, 0xdc, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x7e, 0x00,
+    0xd8, 0xcc, 0xc0, 0x6c, 0x30, 0xd8, 0x66, 0x18, 0x66, 0xc6, 0x6c,
+    0x66, 0xdb, 0xf3, 0x60, 0xc6, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18,
+    0x00, 0x76, 0x00, 0x18, 0x00, 0x6c, 0x00, 0x00, 0x7e, 0x00, 0xd8,
+    0xc8, 0xc0, 0x6c, 0x18, 0xd8, 0x66, 0x18, 0x66, 0xc6, 0x6c, 0x66,
+    0xdb, 0xdb, 0x60, 0xc6, 0xfe, 0x18, 0x0c, 0x30, 0x18, 0x18, 0x7e,
+    0x00, 0x00, 0x18, 0x18, 0xec, 0x00, 0x00, 0x7e, 0x00, 0xdc, 0xdc,
+    0xc0, 0x6c, 0x18, 0xd8, 0x66, 0x18, 0x66, 0xfe, 0xc6, 0x3e, 0xdb,
+    0xdb, 0x7c, 0xc6, 0x00, 0x7e, 0x06, 0x60, 0x18, 0x18, 0x00, 0xdc,
+    0x00, 0x00, 0x00, 0x0c, 0x36, 0x7e, 0x7e, 0x00, 0x76, 0xce, 0xc0,
+    0xfe, 0x30, 0x7e, 0x66, 0xdc, 0x66, 0xc6, 0xc6, 0x0c, 0x7e, 0x7e,
+    0x60, 0xc6, 0x00, 0x18, 0x0c, 0x30, 0x18, 0x18, 0x18, 0x76, 0x00,
+    0x00, 0x00, 0x0c, 0x36, 0x32, 0x7e, 0x00, 0x00, 0xc6, 0xc6, 0x00,
+    0x60, 0x00, 0x00, 0x76, 0x3c, 0xc6, 0xc6, 0x18, 0x00, 0x06, 0x60,
+    0xc6, 0xfe, 0x18, 0x18, 0x18, 0x1b, 0x18, 0x00, 0x00, 0x38, 0x00,
+    0x00, 0x0c, 0x36, 0x18, 0x7e, 0x00, 0x00, 0xce, 0xc6, 0x00, 0xc6,
+    0x00, 0x00, 0x00, 0x18, 0x6c, 0x6c, 0x30, 0x00, 0x03, 0x30, 0x7c,
+    0x00, 0x00, 0x30, 0x0c, 0x1b, 0x18, 0x00, 0x00, 0x6c, 0x00, 0x00,
+    0x0c, 0x36, 0x0c, 0x00, 0x00, 0x00, 0x7c, 0xfe, 0x00, 0xfe, 0x00,
+    0x00, 0x00, 0x7e, 0x38, 0x38, 0x1e, 0x00, 0x00, 0x1c, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x0e, 0x18, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x0c,
+    0x36, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x38, 0x00, 0x00, 0x0f, 0x6c,
+    0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x36, 0x00,
+    0x36, 0x00, 0x36, 0x36, 0x00, 0x36, 0x00, 0x00, 0x18, 0x36, 0x00,
+    0x00, 0x18, 0x36, 0x36, 0x18, 0x00, 0x18, 0xff, 0xff, 0xf0, 0x0f,
+    0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x36, 0x00, 0x36,
+    0x00, 0x36, 0x36, 0x00, 0x36, 0x00, 0x00, 0x18, 0x36, 0x00, 0x00,
+    0x18, 0x36, 0x36, 0x18, 0x00, 0x18, 0xff, 0xff, 0xf0, 0x0f, 0x00,
+    0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x36, 0x00, 0x36, 0x00,
+    0x36, 0x36, 0x00, 0x36, 0x00, 0x00, 0x18, 0x36, 0x00, 0x00, 0x18,
+    0x36, 0x36, 0x18, 0x00, 0x18, 0xff, 0xff, 0xf0, 0x0f, 0x00, 0x00,
+    0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x36, 0x00, 0x36, 0x00, 0x36,
+    0x36, 0x00, 0x36, 0x00, 0x00, 0x18, 0x36, 0x00, 0x00, 0x18, 0x36,
+    0x36, 0x18, 0x00, 0x18, 0xff, 0xff, 0xf0, 0x0f, 0x00, 0x00, 0x00,
+    0x18, 0x18, 0x00, 0x18, 0x18, 0x36, 0x00, 0x36, 0x00, 0x36, 0x36,
+    0x00, 0x36, 0x00, 0x00, 0x18, 0x36, 0x00, 0x00, 0x18, 0x36, 0x36,
+    0x18, 0x00, 0x18, 0xff, 0xff, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x18,
+    0x18, 0x00, 0x18, 0x18, 0x36, 0x00, 0x36, 0x00, 0x36, 0x36, 0x00,
+    0x36, 0x00, 0x00, 0x18, 0x36, 0x00, 0x00, 0x18, 0x36, 0x36, 0x18,
+    0x00, 0x18, 0xff, 0xff, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x18, 0x18,
+    0x00, 0x18, 0x18, 0x36, 0x00, 0x36, 0x00, 0x36, 0x36, 0x00, 0x36,
+    0x00, 0x00, 0x18, 0x36, 0x00, 0x00, 0x18, 0x36, 0x36, 0x18, 0x00,
+    0x18, 0xff, 0xff, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
+    0x18, 0x18, 0x36, 0x00, 0x36, 0x00, 0x36, 0x36, 0x00, 0x36, 0x00,
+    0x00, 0x18, 0x36, 0x00, 0x00, 0x18, 0x36, 0x36, 0x18, 0x00, 0x18,
+    0xff, 0xff, 0xf0, 0x0f, 0x00, 0x1f, 0xff, 0xff, 0x1f, 0xff, 0xff,
+    0x1f, 0x37, 0x3f, 0x37, 0xff, 0xf7, 0x37, 0xff, 0xf7, 0xff, 0xff,
+    0xff, 0xff, 0x3f, 0x1f, 0x1f, 0x3f, 0xff, 0xff, 0xf8, 0x1f, 0xff,
+    0xff, 0xf0, 0x0f, 0x00, 0x18, 0x18, 0x00, 0x18, 0x00, 0x18, 0x18,
+    0x36, 0x30, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x36, 0x00,
+    0x00, 0x36, 0x18, 0x18, 0x00, 0x36, 0x18, 0x18, 0x00, 0xff, 0x00,
+    0xf0, 0x0f, 0xff, 0x18, 0x18, 0x00, 0x18, 0x00, 0x18, 0x1f, 0x36,
+    0x37, 0x3f, 0xf7, 0xff, 0x37, 0xff, 0xf7, 0xff, 0x36, 0xff, 0x00,
+    0x36, 0x1f, 0x1f, 0x00, 0x36, 0xff, 0x18, 0x00, 0xff, 0x00, 0xf0,
+    0x0f, 0xff, 0x18, 0x18, 0x00, 0x18, 0x00, 0x18, 0x18, 0x36, 0x36,
+    0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 0x18, 0x36, 0x00, 0x00, 0x36,
+    0x18, 0x00, 0x00, 0x36, 0x18, 0x18, 0x00, 0xff, 0x00, 0xf0, 0x0f,
+    0xff, 0x18, 0x18, 0x00, 0x18, 0x00, 0x18, 0x18, 0x36, 0x36, 0x00,
+    0x36, 0x00, 0x36, 0x00, 0x36, 0x18, 0x36, 0x00, 0x00, 0x36, 0x18,
+    0x00, 0x00, 0x36, 0x18, 0x18, 0x00, 0xff, 0x00, 0xf0, 0x0f, 0xff,
+    0x18, 0x18, 0x00, 0x18, 0x00, 0x18, 0x18, 0x36, 0x36, 0x00, 0x36,
+    0x00, 0x36, 0x00, 0x36, 0x18, 0x36, 0x00, 0x00, 0x36, 0x18, 0x00,
+    0x00, 0x36, 0x18, 0x18, 0x00, 0xff, 0x00, 0xf0, 0x0f, 0xff, 0x18,
+    0x18, 0x00, 0x18, 0x00, 0x18, 0x18, 0x36, 0x36, 0x00, 0x36, 0x00,
+    0x36, 0x00, 0x36, 0x18, 0x36, 0x00, 0x00, 0x36, 0x18, 0x00, 0x00,
+    0x36, 0x18, 0x18, 0x00, 0xff, 0x00, 0xf0, 0x0f, 0xff, 0x18, 0x18,
+    0x00, 0x18, 0x00, 0x18, 0x18, 0x36, 0x36, 0x00, 0x36, 0x00, 0x36,
+    0x00, 0x36, 0x18, 0x36, 0x00, 0x00, 0x36, 0x18, 0x00, 0x00, 0x36,
+    0x18, 0x18, 0x00, 0xff, 0x00, 0xf0, 0x0f, 0xff, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x44, 0xaa, 0x77, 0x18, 0x18, 0x18, 0x36, 0x36, 0x18,
+    0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x11, 0x55, 0xdd, 0x18, 0x18, 0x18, 0x36, 0x36, 0x18, 0x36,
+    0x36, 0x36, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x06, 0x00, 0x00, 0x00,
+    0x44, 0xaa, 0x77, 0x18, 0x18, 0x18, 0x36, 0x36, 0x18, 0x36, 0x36,
+    0x36, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x06, 0x00, 0x00, 0x00, 0x11,
+    0x55, 0xdd, 0x18, 0x18, 0x18, 0x36, 0x36, 0x18, 0x36, 0x36, 0x36,
+    0x00, 0x00, 0x00, 0x18, 0x76, 0x18, 0x7c, 0x78, 0x66, 0xc6, 0x00,
+    0x00, 0x7c, 0x00, 0x00, 0x0c, 0x3f, 0x18, 0x00, 0x00, 0x44, 0xaa,
+    0x77, 0x18, 0x18, 0x18, 0x36, 0x36, 0x18, 0x36, 0x36, 0x36, 0x00,
+    0x00, 0x00, 0x18, 0xcc, 0x18, 0xc6, 0xcc, 0x66, 0xc6, 0x00, 0x00,
+    0xc6, 0xc0, 0x06, 0x86, 0x9a, 0x3c, 0x00, 0x00, 0x11, 0x55, 0xdd,
+    0x18, 0x18, 0x18, 0x36, 0x36, 0x18, 0x36, 0x36, 0x36, 0x00, 0x00,
+    0x00, 0x18, 0xcc, 0x18, 0xc6, 0xcc, 0x66, 0xc6, 0x00, 0x00, 0xc6,
+    0xc0, 0x06, 0xdc, 0xce, 0x3c, 0x36, 0xd8, 0x44, 0xaa, 0x77, 0x18,
+    0x18, 0x18, 0x36, 0x36, 0x18, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00,
+    0x18, 0xcc, 0x18, 0xc6, 0xcc, 0x66, 0xce, 0x00, 0x00, 0xc0, 0xc0,
+    0x06, 0x60, 0x66, 0x3c, 0x6c, 0x6c, 0x11, 0x55, 0xdd, 0x18, 0x18,
+    0x18, 0x36, 0x36, 0x18, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x18,
+    0x7c, 0x18, 0xc6, 0xcc, 0x66, 0xde, 0x7e, 0x7c, 0x60, 0xc0, 0x06,
+    0x30, 0x30, 0x18, 0xd8, 0x36, 0x44, 0xaa, 0x77, 0x18, 0xf8, 0xf8,
+    0xf6, 0xfe, 0xf8, 0xf6, 0x36, 0xf6, 0xfe, 0xfe, 0xf8, 0xf8, 0x0c,
+    0x18, 0xc6, 0xcc, 0x66, 0xfe, 0x00, 0x00, 0x30, 0xfe, 0xfe, 0x18,
+    0x18, 0x18, 0x6c, 0x6c, 0x11, 0x55, 0xdd, 0x18, 0x18, 0x18, 0x36,
+    0x00, 0x18, 0x06, 0x36, 0x06, 0x06, 0x36, 0x18, 0x00, 0x78, 0x38,
+    0x7c, 0xcc, 0x5c, 0xf6, 0x3e, 0x38, 0x30, 0x00, 0x00, 0x6c, 0x6c,
+    0x18, 0x36, 0xd8, 0x44, 0xaa, 0x77, 0x18, 0x18, 0xf8, 0x36, 0x00,
+    0xf8, 0xf6, 0x36, 0xfe, 0xf6, 0x36, 0xf8, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0xe6, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x66, 0x66, 0x00,
+    0x00, 0x00, 0x11, 0x55, 0xdd, 0x18, 0x18, 0x18, 0x36, 0x00, 0x00,
+    0x36, 0x36, 0x00, 0x36, 0x36, 0x18, 0x00, 0x60, 0x30, 0x60, 0x60,
+    0xdc, 0xc6, 0x6c, 0x6c, 0x30, 0x00, 0x00, 0x62, 0x62, 0x18, 0x00,
+    0x00, 0x44, 0xaa, 0x77, 0x18, 0x18, 0x18, 0x36, 0x00, 0x00, 0x36,
+    0x36, 0x00, 0x36, 0x36, 0x18, 0x00, 0x30, 0x18, 0x30, 0x30, 0x76,
+    0x00, 0x3c, 0x38, 0x30, 0x00, 0x00, 0xe0, 0xe0, 0x18, 0x00, 0x00,
+    0x11, 0x55, 0xdd, 0x18, 0x18, 0x18, 0x36, 0x00, 0x00, 0x36, 0x36,
+    0x00, 0x36, 0x36, 0x18, 0x00, 0x18, 0x0c, 0x18, 0x18, 0x00, 0xdc,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x44,
+    0xaa, 0x77, 0x18, 0x18, 0x18, 0x36, 0x00, 0x00, 0x36, 0x36, 0x00,
+    0x36, 0x36, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x55,
+    0xdd, 0x18, 0x18, 0x18, 0x36, 0x00, 0x00, 0x36, 0x36, 0x00, 0x36,
+    0x36, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
+    0x78, 0x7c, 0x76, 0x76, 0x76, 0x76, 0x7c, 0x7c, 0x7c, 0x7c, 0x18,
+    0x18, 0x18, 0xc6, 0xc6, 0xfc, 0x6e, 0xce, 0x7c, 0x7c, 0x7c, 0x78,
+    0x78, 0x76, 0x7c, 0x7c, 0x18, 0xfe, 0x18, 0xc6, 0x70, 0x3c, 0xcc,
+    0xc2, 0xcc, 0xcc, 0xcc, 0xcc, 0xc6, 0xc2, 0xc2, 0xc2, 0x18, 0x18,
+    0x18, 0xc6, 0xc6, 0xc0, 0xd8, 0xcc, 0xc6, 0xc6, 0xc6, 0xcc, 0xcc,
+    0xce, 0xc6, 0xc6, 0x18, 0x60, 0x7e, 0xcc, 0xd8, 0x66, 0xcc, 0xc0,
+    0xcc, 0xcc, 0xcc, 0xcc, 0xc0, 0xc0, 0xc0, 0xc0, 0x18, 0x18, 0x18,
+    0xc6, 0xc6, 0xc0, 0xd8, 0xcc, 0xc6, 0xc6, 0xc6, 0xcc, 0xcc, 0xc6,
+    0xc6, 0xc6, 0x7c, 0x60, 0x18, 0xcc, 0x18, 0xc6, 0xcc, 0xc0, 0xcc,
+    0xcc, 0xcc, 0xcc, 0xc0, 0xc0, 0xc0, 0xc0, 0x18, 0x18, 0x18, 0xfe,
+    0xc6, 0xc0, 0x7e, 0xcc, 0xc6, 0xc6, 0xc6, 0xcc, 0xcc, 0xc6, 0xc6,
+    0xc6, 0xc6, 0x60, 0x7e, 0xcc, 0x18, 0xc0, 0xcc, 0xfe, 0x7c, 0x7c,
+    0x7c, 0x7c, 0xc0, 0xfe, 0xfe, 0xfe, 0x18, 0x18, 0x18, 0xc6, 0xfe,
+    0xf0, 0x36, 0xcc, 0xc6, 0xc6, 0xc6, 0xcc, 0xcc, 0xc6, 0xc6, 0xc6,
+    0xc0, 0x60, 0x18, 0xde, 0x18, 0xc0, 0xcc, 0xc6, 0x0c, 0x0c, 0x0c,
+    0x0c, 0xc6, 0xc6, 0xc6, 0xc6, 0x18, 0x18, 0x18, 0xc6, 0xc6, 0xc0,
+    0x36, 0xfe, 0xc6, 0xc6, 0xc6, 0xcc, 0xcc, 0xc6, 0xc6, 0xc6, 0xc0,
+    0xf8, 0x3c, 0xcc, 0x7e, 0xc0, 0xcc, 0x7c, 0x78, 0x78, 0x78, 0x78,
+    0x7c, 0x7c, 0x7c, 0x7c, 0x38, 0x38, 0x38, 0x6c, 0x6c, 0xc0, 0xec,
+    0xcc, 0x7c, 0x7c, 0x7c, 0xcc, 0xcc, 0xc6, 0xc6, 0xc6, 0xc0, 0x60,
+    0x66, 0xc4, 0x18, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0xc0, 0x00, 0xcc,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x60, 0x66,
+    0xf8, 0x18, 0x3c, 0xcc, 0x30, 0x6c, 0x00, 0x18, 0x38, 0x00, 0x6c,
+    0x00, 0x18, 0x00, 0x66, 0x18, 0x10, 0x10, 0xfc, 0x00, 0x6c, 0x6c,
+    0x00, 0x18, 0xcc, 0x18, 0x00, 0x7c, 0xc6, 0x7c, 0x62, 0x66, 0xcc,
+    0x18, 0x00, 0xcc, 0x18, 0x38, 0xcc, 0x30, 0x6c, 0x00, 0x38, 0xc6,
+    0x30, 0x66, 0x3c, 0x30, 0x00, 0x38, 0x00, 0x00, 0x3e, 0x38, 0xc6,
+    0x30, 0x78, 0x30, 0xc6, 0x00, 0x00, 0x18, 0x3c, 0x66, 0xcc, 0x1b,
+    0x00, 0x00, 0x0c, 0x10, 0x00, 0x60, 0x38, 0x00, 0x10, 0x00, 0x60,
+    0x00, 0x18, 0x60, 0xc6, 0x6c, 0x30, 0x00, 0x00, 0x10, 0x00, 0x60,
+    0x30, 0x60, 0x00, 0xc6, 0xc6, 0x18, 0x00, 0x00, 0xf8, 0x0e, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x38, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0xc0, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xc0, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x0c, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xc0, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xf8, 0x78, 0x7c, 0x7c,
+    0x30, 0x7c, 0xcc, 0x18, 0x0c, 0xcc, 0x18, 0xc6, 0xcc, 0x78, 0xf8,
+    0x7c, 0xc0, 0x7c, 0x30, 0x78, 0x10, 0x6c, 0xc6, 0x76, 0xfe, 0x0e,
+    0x18, 0x70, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xc4, 0xcc, 0xc2, 0x30,
+    0xcc, 0xcc, 0x18, 0x0c, 0xcc, 0x18, 0xd6, 0xcc, 0xcc, 0xcc, 0xcc,
+    0xc0, 0x86, 0x30, 0xcc, 0x6c, 0xfe, 0x6c, 0xce, 0xc0, 0x18, 0x18,
+    0x18, 0x00, 0xfe, 0x00, 0xcc, 0xcc, 0xc0, 0xcc, 0xc0, 0x30, 0xcc,
+    0xcc, 0x18, 0x0c, 0xd8, 0x18, 0xd6, 0xcc, 0xcc, 0xcc, 0xcc, 0xc0,
+    0x06, 0x30, 0xcc, 0xc6, 0xd6, 0x38, 0xc6, 0x60, 0x18, 0x18, 0x18,
+    0x00, 0xc6, 0x00, 0xcc, 0xcc, 0xc0, 0xcc, 0xc0, 0x30, 0xcc, 0xcc,
+    0x18, 0x0c, 0xf0, 0x18, 0xd6, 0xcc, 0xcc, 0xcc, 0xcc, 0xc0, 0x1c,
+    0x30, 0xcc, 0xc6, 0xd6, 0x38, 0xc6, 0x30, 0x18, 0x18, 0x18, 0x00,
+    0xc6, 0x00, 0x7c, 0xcc, 0xc0, 0xcc, 0xfe, 0x30, 0xcc, 0xcc, 0x18,
+    0x0c, 0xf0, 0x18, 0xd6, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x70, 0x30,
+    0xcc, 0xc6, 0xd6, 0x38, 0xc6, 0x18, 0x18, 0x18, 0x18, 0x00, 0xc6,
+    0x00, 0x0c, 0xcc, 0xc4, 0xcc, 0xc6, 0x78, 0xcc, 0xec, 0x18, 0x0c,
+    0xd8, 0x18, 0xfe, 0xcc, 0xcc, 0xcc, 0xcc, 0xec, 0xc2, 0x30, 0xcc,
+    0xc6, 0xc6, 0x6c, 0xc6, 0x0c, 0x70, 0x18, 0x0e, 0x00, 0x6c, 0x00,
+    0x78, 0xf8, 0x78, 0x7c, 0x7c, 0x30, 0x7c, 0xd8, 0x38, 0x0c, 0xcc,
+    0x18, 0xec, 0xb8, 0x78, 0xf8, 0x7c, 0xb8, 0x7c, 0xfc, 0xcc, 0xc6,
+    0xc6, 0xc6, 0xc6, 0xfe, 0x18, 0x18, 0x18, 0x00, 0x38, 0x00, 0x00,
+    0xc0, 0x00, 0x0c, 0x00, 0x32, 0x00, 0xc0, 0x00, 0x00, 0xc0, 0x18,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x10, 0x0c, 0x00, 0xc0,
+    0x00, 0x0c, 0x00, 0x36, 0x00, 0xc0, 0x18, 0x0c, 0xc0, 0x18, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00, 0xc0, 0x00,
+    0x0c, 0x00, 0x1c, 0x00, 0xc0, 0x18, 0x0c, 0xc0, 0x38, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x0e, 0x18, 0x70, 0xdc, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x7c, 0xc6, 0xfc, 0x3c, 0xf8, 0xfc, 0xc0, 0x3e, 0xc6, 0x18, 0x78,
+    0xc2, 0xfc, 0xc6, 0xc6, 0x7c, 0xc0, 0x7c, 0xc6, 0x7c, 0x18, 0x7c,
+    0x10, 0x6c, 0xc6, 0x18, 0xfe, 0x3c, 0x02, 0x3c, 0x00, 0x00, 0xc0,
+    0xc6, 0xc6, 0x66, 0xdc, 0xc0, 0xc0, 0x66, 0xc6, 0x18, 0xcc, 0xc6,
+    0xc0, 0xc6, 0xc6, 0xc6, 0xc0, 0xde, 0xc6, 0x86, 0x18, 0xc6, 0x38,
+    0xee, 0xc6, 0x18, 0xc0, 0x30, 0x06, 0x0c, 0x00, 0x00, 0xdc, 0xc6,
+    0xc6, 0xc2, 0xce, 0xc0, 0xc0, 0xc6, 0xc6, 0x18, 0xcc, 0xcc, 0xc0,
+    0xc6, 0xc6, 0xc6, 0xc0, 0xd6, 0xcc, 0x06, 0x18, 0xc6, 0x6c, 0xfe,
+    0x6c, 0x18, 0xc0, 0x30, 0x0e, 0x0c, 0x00, 0x00, 0xde, 0xc6, 0xc6,
+    0xc0, 0xc6, 0xc0, 0xc0, 0xc6, 0xc6, 0x18, 0xcc, 0xd8, 0xc0, 0xc6,
+    0xc6, 0xc6, 0xc0, 0xc6, 0xcc, 0x06, 0x18, 0xc6, 0xc6, 0xd6, 0x7c,
+    0x18, 0x60, 0x30, 0x1c, 0x0c, 0x00, 0x00, 0xde, 0xfe, 0xc6, 0xc0,
+    0xc6, 0xc0, 0xc0, 0xde, 0xc6, 0x18, 0x0c, 0xf0, 0xc0, 0xc6, 0xce,
+    0xc6, 0xc0, 0xc6, 0xd8, 0x0c, 0x18, 0xc6, 0xc6, 0xd6, 0x38, 0x18,
+    0x30, 0x30, 0x38, 0x0c, 0x00, 0x00, 0xde, 0xc6, 0xfc, 0xc0, 0xc6,
+    0xf8, 0xf8, 0xc0, 0xfe, 0x18, 0x0c, 0xf0, 0xc0, 0xd6, 0xde, 0xc6,
+    0xfc, 0xc6, 0xfc, 0x38, 0x18, 0xc6, 0xc6, 0xd6, 0x38, 0x3c, 0x18,
+    0x30, 0x70, 0x0c, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc0, 0xc6, 0xc0,
+    0xc0, 0xc0, 0xc6, 0x18, 0x0c, 0xd8, 0xc0, 0xfe, 0xfe, 0xc6, 0xc6,
+    0xc6, 0xc6, 0x60, 0x18, 0xc6, 0xc6, 0xc6, 0x7c, 0x66, 0x0c, 0x30,
+    0xe0, 0x0c, 0x00, 0x00, 0xc6, 0x6c, 0xc6, 0xc2, 0xce, 0xc0, 0xc0,
+    0xc0, 0xc6, 0x18, 0x0c, 0xcc, 0xc0, 0xfe, 0xf6, 0xc6, 0xc6, 0xc6,
+    0xc6, 0xc0, 0x18, 0xc6, 0xc6, 0xc6, 0x6c, 0x66, 0x06, 0x30, 0xc0,
+    0x0c, 0x00, 0x00, 0x7c, 0x38, 0xc6, 0x66, 0xdc, 0xc0, 0xc0, 0x62,
+    0xc6, 0x18, 0x0c, 0xc6, 0xc0, 0xee, 0xe6, 0xc6, 0xc6, 0xc6, 0xc6,
+    0xc2, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0x66, 0x06, 0x30, 0x80, 0x0c,
+    0xc6, 0x00, 0x00, 0x10, 0xfc, 0x3c, 0xf8, 0xfc, 0xfc, 0x3c, 0xc6,
+    0x18, 0x1e, 0xc2, 0xc0, 0xc6, 0xc6, 0x7c, 0xfc, 0x7c, 0xfc, 0x7c,
+    0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0x66, 0xfe, 0x3c, 0x00, 0x3c, 0x6c,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x6c, 0x7c,
+    0x86, 0x76, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x18, 0x00, 0x18, 0x80,
+    0x38, 0x18, 0xfe, 0x7c, 0x0c, 0x7c, 0x7c, 0x30, 0x7c, 0x78, 0x00,
+    0x30, 0x06, 0x00, 0x60, 0x18, 0x00, 0x18, 0x00, 0x6c, 0xc6, 0xc6,
+    0xcc, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00, 0x18, 0xc0, 0x6c,
+    0x18, 0xc0, 0x86, 0x0c, 0x86, 0xc6, 0x30, 0xc6, 0x8c, 0x18, 0x18,
+    0x0c, 0x00, 0x30, 0x18, 0x00, 0x00, 0x00, 0xfe, 0x86, 0x60, 0xcc,
+    0x00, 0x30, 0x0c, 0x66, 0x18, 0x18, 0x00, 0x00, 0x60, 0xc6, 0x18,
+    0xc0, 0x06, 0x0c, 0x06, 0xc6, 0x30, 0xc6, 0x06, 0x18, 0x18, 0x18,
+    0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x6c, 0x06, 0x30, 0xcc, 0x00,
+    0x30, 0x0c, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x30, 0xe6, 0x18, 0x60,
+    0x06, 0x0c, 0x06, 0xc6, 0x30, 0xc6, 0x06, 0x00, 0x00, 0x30, 0x7e,
+    0x0c, 0x18, 0x00, 0x18, 0x00, 0x6c, 0x06, 0x18, 0xdc, 0x00, 0x30,
+    0x0c, 0xff, 0x7e, 0x00, 0xfe, 0x00, 0x18, 0xf6, 0x18, 0x30, 0x06,
+    0xfe, 0x06, 0xe6, 0x18, 0xc6, 0x06, 0x00, 0x00, 0x60, 0x00, 0x06,
+    0x18, 0x00, 0x18, 0x00, 0x6c, 0x7c, 0x0c, 0x76, 0x00, 0x30, 0x0c,
+    0x3c, 0x18, 0x00, 0x00, 0x00, 0x0c, 0xde, 0x18, 0x18, 0x3c, 0xcc,
+    0xfc, 0xdc, 0x0c, 0x7c, 0x7e, 0x00, 0x00, 0x30, 0x00, 0x0c, 0x18,
+    0x00, 0x3c, 0x00, 0xfe, 0xc0, 0xc6, 0x38, 0x00, 0x30, 0x0c, 0x66,
+    0x18, 0x00, 0x00, 0x00, 0x06, 0xce, 0x18, 0x0c, 0x06, 0x6c, 0xc0,
+    0xc0, 0x06, 0xc6, 0xc6, 0x18, 0x18, 0x18, 0x7e, 0x18, 0x0c, 0x00,
+    0x3c, 0x24, 0x6c, 0xc2, 0xc2, 0x6c, 0x60, 0x30, 0x0c, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x02, 0xc6, 0x78, 0x06, 0x06, 0x3c, 0xc0, 0xc0,
+    0x06, 0xc6, 0xc6, 0x18, 0x18, 0x0c, 0x00, 0x30, 0xc6, 0x00, 0x3c,
+    0x66, 0x6c, 0xc6, 0x00, 0x6c, 0x30, 0x18, 0x18, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x6c, 0x38, 0xc6, 0x86, 0x1c, 0xc0, 0x60, 0x06,
+    0xc6, 0xc6, 0x00, 0x00, 0x06, 0x00, 0x60, 0xc6, 0x00, 0x18, 0x66,
+    0x00, 0x7c, 0x00, 0x38, 0x30, 0x0c, 0x30, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x38, 0x18, 0x7c, 0x7c, 0x0c, 0xfe, 0x3c, 0xfe, 0x7c,
+    0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x66, 0x00,
+    0x18, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
+    0x00, 0xff, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x7e, 0x7e, 0x10, 0x00, 0x3c, 0x3c, 0x00, 0xff, 0x00,
+    0xff, 0x78, 0x18, 0xe0, 0xe6, 0x18, 0x80, 0x02, 0x00, 0x66, 0x1b,
+    0xc6, 0xfe, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x81, 0xff, 0x38, 0x10, 0x18, 0x18, 0x00, 0xff, 0x3c, 0xc3,
+    0xcc, 0x18, 0xf0, 0xe7, 0x18, 0xc0, 0x06, 0x18, 0x66, 0x1b, 0x0c,
+    0xfe, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x10, 0x00,
+    0x81, 0xff, 0x7c, 0x38, 0x18, 0x18, 0x18, 0xe7, 0x66, 0x99, 0xcc,
+    0x7e, 0x70, 0x67, 0xdb, 0xe0, 0x0e, 0x3c, 0x00, 0x1b, 0x38, 0xfe,
+    0x3c, 0x18, 0x7e, 0x18, 0x30, 0xfe, 0x28, 0xfe, 0x38, 0x00, 0x99,
+    0xe7, 0xfe, 0x7c, 0xe7, 0x7e, 0x3c, 0xc3, 0x42, 0xbd, 0xcc, 0x18,
+    0x30, 0x63, 0x3c, 0xf0, 0x1e, 0x7e, 0x66, 0x1b, 0x6c, 0xfe, 0x7e,
+    0x18, 0x18, 0x0c, 0x60, 0xc0, 0x6c, 0x7c, 0x38, 0x00, 0xbd, 0xc3,
+    0xfe, 0xfe, 0xe7, 0xff, 0x3c, 0xc3, 0x42, 0xbd, 0xcc, 0x3c, 0x30,
+    0x63, 0xe7, 0xf8, 0x3e, 0x18, 0x66, 0x1b, 0xc6, 0x00, 0x18, 0x18,
+    0x18, 0xfe, 0xfe, 0xc0, 0xfe, 0x7c, 0x7c, 0x00, 0x81, 0xff, 0xfe,
+    0x7c, 0xe7, 0xff, 0x18, 0xe7, 0x66, 0x99, 0x78, 0x66, 0x30, 0x63,
+    0x3c, 0xfe, 0xfe, 0x18, 0x66, 0x7b, 0xc6, 0x00, 0x18, 0x18, 0x18,
+    0x0c, 0x60, 0xc0, 0x6c, 0x38, 0x7c, 0x00, 0x81, 0xff, 0xfe, 0x38,
+    0x3c, 0x7e, 0x00, 0xff, 0x3c, 0xc3, 0x32, 0x66, 0x30, 0x63, 0xdb,
+    0xf8, 0x3e, 0x18, 0x66, 0xdb, 0x6c, 0x00, 0x18, 0x18, 0x18, 0x18,
+    0x30, 0x00, 0x28, 0x38, 0xfe, 0x00, 0xa5, 0xdb, 0x6c, 0x10, 0x3c,
+    0x3c, 0x00, 0xff, 0x00, 0xff, 0x1a, 0x66, 0x3f, 0x7f, 0x18, 0xf0,
+    0x1e, 0x7e, 0x66, 0xdb, 0x38, 0x00, 0x7e, 0x7e, 0x18, 0x00, 0x00,
+    0x00, 0x00, 0x10, 0xfe, 0x00, 0x81, 0xff, 0x00, 0x00, 0x18, 0x18,
+    0x00, 0xff, 0x00, 0xff, 0x0e, 0x66, 0x33, 0x63, 0x18, 0xe0, 0x0e,
+    0x3c, 0x66, 0xdb, 0x60, 0x00, 0x3c, 0x3c, 0x18, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0xff, 0x00, 0xff, 0x1e, 0x3c, 0x3f, 0x7f, 0x00, 0xc0, 0x06, 0x18,
+    0x66, 0x7f, 0xc6, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
+    0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00,
+    0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
+    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
diff --git a/lib/PDCursesMod/common/icon32.xpm b/lib/PDCursesMod/common/icon32.xpm
new file mode 100644
index 00000000000..24f64e427ce
--- /dev/null
+++ b/lib/PDCursesMod/common/icon32.xpm
@@ -0,0 +1,42 @@
+/* XPM */
+static char *icon32[] = {
+/* width height ncolors chars_per_pixel */
+"32 32 3 1",
+/* colors */
+"  c #000",
+". c #FFF",
+"X c None",
+/* pixels */
+"................................",
+"................................",
+"................................",
+"..........      ....  ..........",
+"..........       ...  ..........",
+"..........  ...   ..  ..........",
+"..........  ....  ..  ..........",
+"..........  ....  ..  ..........",
+"..........  ...   ..  ..........",
+"..........  ..   ..   ..........",
+"..........  .   ..    ..........",
+"..........     ..     ..........",
+"..........    ..   .  ..........",
+"..........   ..   ..  ..........",
+"..........  ..   ...  ..........",
+"..........  ..  ....  ..........",
+"..........  ..  ....  ..........",
+"..........  ..   ...  ..........",
+"..........  ...       ..........",
+"..........  ....      ..........",
+"................................",
+"................................",
+"..  .. .. . . ...  ...  ...  ...",
+". .. . .. .  . . .. . .. . .. ..",
+". .... .. . .... .... .. . .....",
+". .... .. . .....  ..   ...  ...",
+". .... .. . ....... . ....... ..",
+". .. . .. . .... .. . .. . .. ..",
+"..  ...  .. .....  ...  ...  ...",
+"................................",
+"................................",
+"................................"
+};
diff --git a/lib/PDCursesMod/common/icon64.xpm b/lib/PDCursesMod/common/icon64.xpm
new file mode 100644
index 00000000000..55e8b590302
--- /dev/null
+++ b/lib/PDCursesMod/common/icon64.xpm
@@ -0,0 +1,74 @@
+/* XPM */
+static char *icon64[] = {
+/* width height ncolors chars_per_pixel */
+"64 64 3 1",
+/* colors */
+"  c #000",
+". c #FFF",
+"X c None",
+/* pixels */
+"................................................................",
+"................................................................",
+"................................................................",
+"................................................................",
+"................................................................",
+"................................................................",
+"................................................................",
+"....................            ......    ......................",
+"....................             .....    ......................",
+"....................              ....    ......................",
+"....................              ....    ......................",
+"....................    ......     ...    ......................",
+"....................    .......    ...    ......................",
+"....................    .......    ...    ......................",
+"....................    .......    ...    ......................",
+"....................    .......    ...    ......................",
+"....................    ......     ...    ......................",
+"....................    .....     ....    ......................",
+"....................    ....      ...     ......................",
+"....................    ...      ...      ......................",
+"....................    ..      ...       ......................",
+"....................    .      ...        ......................",
+"....................          ...         ......................",
+"....................         ...          ......................",
+"....................        ...      .    ......................",
+"....................       ...      ..    ......................",
+"....................      ...      ...    ......................",
+"....................     ...      ....    ......................",
+"....................    ....     .....    ......................",
+"....................    ...     ......    ......................",
+"....................    ...    .......    ......................",
+"....................    ...    .......    ......................",
+"....................    ...    .......    ......................",
+"....................    ...    .......    ......................",
+"....................    ...     ......    ......................",
+"....................    ....              ......................",
+"....................    ....              ......................",
+"....................    .....             ......................",
+"....................    ......            ......................",
+"................................................................",
+"................................................................",
+"................................................................",
+"................................................................",
+"......    ... ...... . ..    .....     .....    .....     ......",
+".....  ..  .. ...... . .  ..  ...  ...  ...  ..  ...  ...  .....",
+"....  ....  . ...... .   ....  .  .....  .  ....  .  .....  ....",
+".... ...... . ...... .  ...... . ....... . ...... . ....... ....",
+".... ........ ...... . ......... ....... . ...... . ....... ....",
+".... ........ ...... . .........  ........ ...... .  ...........",
+".... ........ ...... . ..........  ....... ...... ..  ..........",
+".... ........ ...... . ...........     ...        ...     ......",
+".... ........ ...... . ...............  .. ..............  .....",
+".... ........ ...... . ................  . ...............  ....",
+".... ........ ...... . ......... ....... . ...... . ....... ....",
+".... ...... . ...... . ......... ....... . ...... . ....... ....",
+"....  ....  .  ....  . .........  .....  .  ....  .  .....  ....",
+".....  ..  ...  ..  .. ..........  ...  ...  ..  ...  ...  .....",
+"......    .....    ... ...........     .....    .....     ......",
+"................................................................",
+"................................................................",
+"................................................................",
+"................................................................",
+"................................................................",
+"................................................................"
+};
diff --git a/lib/PDCursesMod/common/iconbmp.h b/lib/PDCursesMod/common/iconbmp.h
new file mode 100644
index 00000000000..51f6cb11cf9
--- /dev/null
+++ b/lib/PDCursesMod/common/iconbmp.h
@@ -0,0 +1,24 @@
+/* The PDCurses logo as #include'able BMP (from icon32.xpm),
+   for use by SDL. */
+
+unsigned char iconbmp[] =
+{
+    0x42, 0x4d, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e,
+    0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
+    0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0x0b, 0x00, 0x00, 0x13, 0x0b,
+    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xce, 0x6f, 0x9c,
+    0xe7, 0xb5, 0xaf, 0x6b, 0x5b, 0xbd, 0xaf, 0xeb, 0xfb, 0xbd, 0xaf,
+    0x98, 0xe7, 0xbd, 0xaf, 0x7b, 0x5f, 0xb5, 0xa5, 0x6b, 0x5b, 0xcd,
+    0xab, 0x9c, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xcf, 0x03, 0xff, 0xff, 0xce, 0x03, 0xff, 0xff, 0xcc, 0x73,
+    0xff, 0xff, 0xcc, 0xf3, 0xff, 0xff, 0xcc, 0xf3, 0xff, 0xff, 0xcc,
+    0x73, 0xff, 0xff, 0xc6, 0x33, 0xff, 0xff, 0xc3, 0x13, 0xff, 0xff,
+    0xc1, 0x83, 0xff, 0xff, 0xc8, 0xc3, 0xff, 0xff, 0xcc, 0x63, 0xff,
+    0xff, 0xce, 0x33, 0xff, 0xff, 0xcf, 0x33, 0xff, 0xff, 0xcf, 0x33,
+    0xff, 0xff, 0xce, 0x33, 0xff, 0xff, 0xc0, 0x73, 0xff, 0xff, 0xc0,
+    0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff
+};
diff --git a/lib/PDCursesMod/common/libobjs.mif b/lib/PDCursesMod/common/libobjs.mif
new file mode 100644
index 00000000000..cf117889e2f
--- /dev/null
+++ b/lib/PDCursesMod/common/libobjs.mif
@@ -0,0 +1,25 @@
+# Common elements for most of the DOS, OS/2 and Windows
+# makefiles (not Watcom)
+
+PDCURSES_CURSES_H	= $(PDCURSES_SRCDIR)/curses.h
+PDCURSES_CURSPRIV_H	= $(PDCURSES_SRCDIR)/curspriv.h
+PDCURSES_HEADERS	= $(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		= $(PDCURSES_SRCDIR)/panel.h
+
+srcdir	= $(PDCURSES_SRCDIR)/pdcurses
+demodir	= $(PDCURSES_SRCDIR)/demos
+
+LIBOBJS = addch.$(O) addchstr.$(O) addstr.$(O) attr.$(O) beep.$(O) \
+bkgd.$(O) border.$(O) clear.$(O) color.$(O) delch.$(O) deleteln.$(O) \
+getch.$(O) getstr.$(O) getyx.$(O) inch.$(O) inchstr.$(O) \
+initscr.$(O) inopts.$(O) insch.$(O) insstr.$(O) instr.$(O) kernel.$(O) \
+keyname.$(O) mouse.$(O) move.$(O) outopts.$(O) overlay.$(O) pad.$(O) \
+panel.$(O) printw.$(O) refresh.$(O) scanw.$(O) scr_dump.$(O) scroll.$(O) \
+slk.$(O) termattr.$(O) touch.$(O) util.$(O) window.$(O) debug.$(O)
+
+PDCOBJS = pdcclip.$(O) pdcdisp.$(O) pdcgetsc.$(O) pdckbd.$(O) pdcscrn.$(O) \
+pdcsetsc.$(O) pdcutil.$(O)
+
+DEMOS =     firework$(E) newtest$(E) ozdemo$(E) picsview$(E) ptest$(E) \
+rain$(E) speed$(E) test_pan$(E) testcurs$(E) tuidemo$(E) worm$(E) xmas$(E) \
+triangles$(E) simplemenu$(E)
diff --git a/lib/PDCursesMod/common/makedist.mif b/lib/PDCursesMod/common/makedist.mif
new file mode 100644
index 00000000000..b4896c1dc3b
--- /dev/null
+++ b/lib/PDCursesMod/common/makedist.mif
@@ -0,0 +1,19 @@
+# Makefile include: build a binary archive with Info-ZIP
+# under DOS, OS/2 or Win32
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for $(PLATFORM1) > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo $(PLATFORM2). >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	echo $(PDCURSES_SRCDIR)/README.md > flist
+	echo $(PDCURSES_SRCDIR)/docs/HISTORY.md >> flist
+	echo $(PDCURSES_SRCDIR)/curses.h >> flist
+	echo $(PDCURSES_SRCDIR)/panel.h >> flist
+	echo $(LIBCURSES) >> flist
+	echo file_id.diz >> flist
+	zip -9jX $(ARCNAME) -@ <flist
+	del flist
+	del file_id.diz
diff --git a/lib/PDCursesMod/common/pdccolor.c b/lib/PDCursesMod/common/pdccolor.c
new file mode 100644
index 00000000000..76671ca9b9b
--- /dev/null
+++ b/lib/PDCursesMod/common/pdccolor.c
@@ -0,0 +1,217 @@
+/* PDCurses */
+
+/* Palette management code used by VT and WinGUI for 'full color'
+(24-bit).  It will be used eventually by X11,  SDL1/2,  and DOSVGA,
+all of which are full-color capable.  See 'pdccolor.txt' for a
+rationale of how this works.    */
+
+#ifdef NO_STDINT_H
+   #define uint64_t unsigned long long
+   #define uint32_t unsigned long
+   #define uint16_t unsigned short
+#else
+   #include <stdint.h>
+#endif
+   #include <stdlib.h>
+   #include <assert.h>
+
+#define PACKED_RGB uint32_t
+
+#ifndef PACK_RGB
+   #define PACK_RGB( red, green, blue) ((red) | ((green)<<8) | ((PACKED_RGB)(blue) << 16))
+#endif
+
+#include <curspriv.h>
+#include "pdccolor.h"
+
+int PDC_blink_state = 0;
+
+static PACKED_RGB *rgbs;   /* the 'standard' 256-color palette,  plus any allocated */
+static int palette_size;
+
+PACKED_RGB PDC_default_color( int idx)
+{
+    PACKED_RGB rval;
+
+    assert( idx >= 0);
+    if( idx < 16)
+    {
+        const int intensity = ((idx & 8) ? 0xff : 0xc0);
+
+        rval = PACK_RGB( ((idx & COLOR_RED) ? intensity : 0),
+                          ((idx & COLOR_GREEN) ? intensity : 0),
+                          ((idx & COLOR_BLUE) ? intensity : 0));
+    }
+    else if( idx < 216 + 16)
+    {                    /* colors 16-231 are a 6x6x6 color cube */
+        int r, g, b;
+
+        idx -= 16;
+        r = idx / 36;
+        g = (idx / 6) % 6;
+        b = idx % 6;
+        rval = PACK_RGB( r ? r * 40 + 55 : 0,
+                         g ? g * 40 + 55 : 0,
+                         b ? b * 40 + 55 : 0);
+    }
+    else if( idx < 256)    /* colors 232-255 are 24 shades of gray */
+    {
+        const int intensity = (idx - 232) * 10 + 8;
+
+        rval = PACK_RGB( intensity, intensity, intensity);
+    }
+    else             /* colors 256 to 256+2^24 are RGB values */
+        rval = idx - 256;
+    return( rval);
+}
+
+int PDC_init_palette( void)
+{
+    return( 0);
+}
+
+void PDC_free_palette( void)
+{
+   if( rgbs)
+      free( rgbs);
+   rgbs = NULL;
+}
+
+PACKED_RGB PDC_get_palette_entry( const int idx)
+{
+   PACKED_RGB rval;
+
+   if( idx < palette_size)
+      rval = rgbs[idx];
+   else
+      rval = PDC_default_color( idx);
+   return( rval);
+}
+
+/* Return value is -1 if no palette could be allocated,  0 if the color
+didn't change (new RGB matched the old one),  and 1 if the color changed. */
+
+int PDC_set_palette_entry( const int idx, const PACKED_RGB rgb)
+{
+   int rval, i;
+
+   if( idx >= palette_size)
+      {
+      int new_size = palette_size;
+      const int initial_palette_size = 8;
+
+      if( !new_size)
+         new_size = initial_palette_size;
+      while( new_size <= idx)
+         new_size *= 2;
+      rgbs = realloc( rgbs, new_size * sizeof( PACKED_RGB));
+      assert( rgbs);
+      if( !rgbs)
+         return( -1);
+      for( i = palette_size; i < new_size; i++)
+         rgbs[i] = PDC_default_color( i);
+      palette_size = new_size;
+      }
+   rval = (rgbs[idx] == rgb ? 1 : 0);
+   rgbs[idx] = rgb;
+   return( rval);
+}
+
+    /* This function 'intensifies' a color by shifting it toward white. */
+    /* It used to average the input color with white.  Then it did a    */
+    /* weighted average:  2/3 of the input color,  1/3 white,   for a   */
+    /* lower "intensification" level.                                   */
+    /*    Then Mark Hessling suggested that the output level should     */
+    /* remap zero to 85 (= 255 / 3, so one-third intensity),  and input */
+    /* of 192 or greater should be remapped to 255 (full intensity).    */
+    /* Assuming we want a linear response between zero and 192,  that   */
+    /* leads to output = 85 + input * (255-85)/192.                     */
+    /*    This should lead to proper handling of bold text in legacy    */
+    /* apps,  where "bold" means "high intensity".                      */
+
+static PACKED_RGB intensified_color( PACKED_RGB ival)
+{
+    int rgb, i;
+    PACKED_RGB oval = 0;
+
+    for( i = 0; i < 3; i++, ival >>= 8)
+    {
+        rgb = (int)( ival & 0xff);
+        if( rgb >= 192)
+            rgb = 255;
+        else
+            rgb = 85 + rgb * (255 - 85) / 192;
+        oval |= ((PACKED_RGB)rgb << (i * 8));
+    }
+    return( oval);
+}
+
+   /* For use in adjusting colors for A_DIMmed characters.  Just */
+   /* knocks down the intensity of R, G, and B by 1/3.           */
+
+static PACKED_RGB dimmed_color( PACKED_RGB ival)
+{
+    unsigned i;
+    PACKED_RGB oval = 0;
+
+    for( i = 0; i < 3; i++, ival >>= 8)
+    {
+        unsigned rgb = (unsigned)( ival & 0xff);
+
+        rgb -= (rgb / 3);
+        oval |= ((PACKED_RGB)rgb << (i * 8));
+    }
+    return( oval);
+}
+
+
+void PDC_get_rgb_values( const chtype srcp,
+            PACKED_RGB *foreground_rgb, PACKED_RGB *background_rgb)
+{
+    const int color = (int)(( srcp & A_COLOR) >> PDC_COLOR_SHIFT);
+    bool reverse_colors = ((srcp & A_REVERSE) ? TRUE : FALSE);
+    bool intensify_backgnd = FALSE;
+    bool default_foreground = FALSE, default_background = FALSE;
+
+    {
+        int foreground_index, background_index;
+
+        extended_pair_content( color, &foreground_index, &background_index);
+        if( foreground_index < 0 && SP->orig_attr)
+            default_foreground = TRUE;
+        else
+            *foreground_rgb = PDC_get_palette_entry( foreground_index);
+        if( background_index < 0 && SP->orig_attr)
+            default_background = TRUE;
+        else
+            *background_rgb = PDC_get_palette_entry( background_index);
+    }
+
+    if( srcp & A_BLINK)
+    {
+        if( !(SP->termattrs & A_BLINK))   /* convert 'blinking' to 'bold' */
+            intensify_backgnd = TRUE;
+        else if( PDC_blink_state)
+            reverse_colors ^= 1;
+    }
+    if( srcp & A_BOLD & ~SP->termattrs)
+        *foreground_rgb = intensified_color( *foreground_rgb);
+    if( intensify_backgnd)
+        *background_rgb = intensified_color( *background_rgb);
+    if( srcp & A_DIM)
+    {
+        *foreground_rgb = dimmed_color( *foreground_rgb);
+        *background_rgb = dimmed_color( *background_rgb);
+    }
+    if( default_foreground)
+        *foreground_rgb = (PACKED_RGB)-1;
+    if( default_background)
+        *background_rgb = (PACKED_RGB)-1;
+    if( reverse_colors)
+    {
+        const PACKED_RGB temp = *foreground_rgb;
+
+        *foreground_rgb = *background_rgb;
+        *background_rgb = temp;
+    }
+}
diff --git a/lib/PDCursesMod/common/pdccolor.h b/lib/PDCursesMod/common/pdccolor.h
new file mode 100644
index 00000000000..b4cd7d32e73
--- /dev/null
+++ b/lib/PDCursesMod/common/pdccolor.h
@@ -0,0 +1,14 @@
+#ifndef PDCCOLOR_H
+
+#define PDCCOLOR_H
+extern int PDC_blink_state;
+
+typedef uint32_t PACKED_RGB;
+
+int PDC_init_palette( void);
+void PDC_get_rgb_values( const chtype srcp,
+            PACKED_RGB *foreground_rgb, PACKED_RGB *background_rgb);
+int PDC_set_palette_entry( const int idx, const PACKED_RGB rgb);
+PACKED_RGB PDC_get_palette_entry( const int idx);
+void PDC_free_palette( void);
+#endif
diff --git a/lib/PDCursesMod/common/pdccolor.txt b/lib/PDCursesMod/common/pdccolor.txt
new file mode 100644
index 00000000000..d616b83f3ba
--- /dev/null
+++ b/lib/PDCursesMod/common/pdccolor.txt
@@ -0,0 +1,68 @@
+   The VT,  WinGUI,  and (eventually) SDL2,  SDL1,  and X11 models all
+have the ability to support 'full' RGB,  16 million colors.  ncurses
+currently supports this with the xterm-direct model,  in which you
+get 2^24 colors and can't change them.
+
+   The problem with the ncurses solution is that it breaks existing
+palette-based code.  I've found a few people complaining about this.
+It's true that one should not blindly assume you'll have a color
+palette and can change it,  nor should you assume a particular
+color palette. There's no promise of that sort in Curses.  The
+can_change_color() function exists for good reason.  (The Linux
+console is a good example of a place where you can't change colors.)
+
+   However,  many people (me included) have written code that
+assumes that init_color() will actually change the color. I think
+a lot of people do.  If somebody complains that it doesn't work in
+the Linux console,  we say : "Don't do that."
+
+   Fortunately,  PDCurses has been revised so that it uses the
+the existing Curses model  _and_ can access a changeable palette
+of 16-million colors,  have 2^20 = 1048576 color pairs, and not
+require much code or memory.  (Actually, slightly less.)
+
+   As the 'PDC_default_color' function in 'pdccolor.c' shows,  the
+first 256 palette entries are the traditional ones : 8 primary
+colors,  8 "intensified" primary colors,  a 6x6x6=216 color cube,
+and 24 shades of gray.  (Re-defining the first 256 colors would have
+broken backward de facto compatibility.)  This is now followed by
+2^24 colors,  so COLORS = 2^24 + 2^8.  By default,  palette indices
+past 256 have color components
+
+r =  (index - 256) & 0xff
+g = ((index - 256) >> 8) & 0xff
+b = ((index - 256) >> 16) & 0xff
+
+   All of these colors can be easily computed algorithmically.
+Unless a palette entry is deliberately set,  we need allocate no
+memory at all,  even though we have a palette of 2^24 + 2^8 colors.
+The 'picsview' demo illustrates how this can be done;  color
+0xdeadbe, (blue 0xde, green 0xad, blue 0xbe)  for example,  is at
+palette index 0xdeadbe + 256 = 0xdeaebe.
+
+   Resetting of palette entries is relatively rare,  especially
+because most PDCurses/ncurses programs don't expect more than 256
+colors anyway.  'testcurs' resets colors beyond this,  but that's
+explicitly to test the above code.  As palette entries are set,
+the array of entries ('rgbs' in pdccolor.c) is reallocated to be
+the smallest power of two capable of handling all entries.
+
+   The vast majority of programs which either never use color
+indices past 256,  or which decide to use them at the default
+values, will never cause rgbs[] to be allocated.  If you decide
+to use a palette of,  say,  1024 colors,  then fine;  rgbs[] will
+be extended to consume 1024 COLOR_PAIR structures (2048 integers,
+so 8K of memory with 32-bit integers).  So this doesn't devour a
+lot of memory.  (At present,  only 'testcurs' sets colors beyond
+256,  in its 'colors beyond 256' section... but this was done
+specifically to verify that the code works.)
+
+   If you look in pdcurses/color.c,  you will see that the color
+pairs are similarly dynamically reallocated when new pairs are
+set.  One can have 2^20 = 1048576 color pairs,  consuming 8
+MBytes assuming 32-bit ints. But few applications use more than a
+few color pairs.  Again, 'testcurs' does so in the same 'colors
+beyond 256' section.  I have run 'picsview' full-screen with a
+tiny font to get it to allocate over 100K color pairs... indeed,
+that sort of "picture drawing" is the only case I can think of
+where one might use really large numbers of colors.
diff --git a/lib/PDCursesMod/common/pdcurses.rc b/lib/PDCursesMod/common/pdcurses.rc
new file mode 100644
index 00000000000..5d3afaa4bac
--- /dev/null
+++ b/lib/PDCursesMod/common/pdcurses.rc
@@ -0,0 +1,35 @@
+#include <windows.h>
+#include "../curses.h"
+
+VS_VERSION_INFO    VERSIONINFO
+FILEVERSION        PDC_VER_MAJOR,PDC_VER_MINOR,PDC_VER_CHANGE,0
+PRODUCTVERSION     PDC_VER_MAJOR,PDC_VER_MINOR,PDC_VER_CHANGE,0
+FILEFLAGSMASK      VS_FFI_FILEFLAGSMASK
+#ifdef _DEBUG
+  FILEFLAGS        VS_FF_DEBUG | VS_FF_PRERELEASE
+#else
+  FILEFLAGS        0
+#endif
+FILEOS             VOS_NT_WINDOWS32
+FILETYPE           VFT_DLL
+FILESUBTYPE        VFT2_UNKNOWN
+BEGIN
+  BLOCK "StringFileInfo"
+  BEGIN
+    BLOCK "04090000"
+    BEGIN
+      VALUE "CompanyName", "PDCurses.org"
+      VALUE "FileDescription", "PDCurses Library"
+      VALUE "FileVersion", PDC_VERDOT
+      VALUE "InternalName", "PDCurses"
+      VALUE "LegalCopyright", "Public Domain"
+      VALUE "OriginalFilename", "pdcurses.dll"
+      VALUE "ProductName", "PDCurses"
+      VALUE "ProductVersion", PDC_VERDOT
+    END
+  END
+  BLOCK "VarFileInfo"
+  BEGIN
+    VALUE "Translation", 0x409, 0
+  END
+END
diff --git a/lib/PDCursesMod/common/version.mif b/lib/PDCursesMod/common/version.mif
new file mode 100644
index 00000000000..53393637634
--- /dev/null
+++ b/lib/PDCursesMod/common/version.mif
@@ -0,0 +1,9 @@
+# Version number macros for inclusion from makefiles
+
+VER = 420
+VERDOT = 4.2.0
+ABI_MAJOR = 4
+ABI_MINOR = 2
+ABI_CHANGE = 0
+ABI_BUILD = 0
+ABI = $(ABI_MAJOR).$(ABI_MINOR).$(ABI_CHANGE).$(ABI_BUILD)
diff --git a/lib/PDCursesMod/common/watcom.mif b/lib/PDCursesMod/common/watcom.mif
new file mode 100644
index 00000000000..3c32b717d33
--- /dev/null
+++ b/lib/PDCursesMod/common/watcom.mif
@@ -0,0 +1,204 @@
+# Common elements for the Watcom makefiles
+
+!ifeq TARGET dos
+!ifneq MODEL f
+TARGET16 = 1
+!endif
+!endif
+
+!ifdef __UNIX__
+DEL	= rm -f
+COPY	= cp
+!else
+DEL	= del
+COPY	= copy
+!endif
+
+!ifeq TARGET linux
+!else
+E = .exe
+!endif
+
+.EXTENSIONS :
+!ifeq TARGET linux
+.EXTENSIONS : . .lib .obj .h .c
+!else
+.EXTENSIONS : $(E) .dll .lib .res .obj .rc .h .c
+!endif
+
+!ifdef TARGET16
+CC = *wcc
+!else
+CC = *wcc386
+MODEL = f
+!endif
+
+LIBEXE = *wlib -q -n -b -c -t -pa
+
+LINK = *wlink
+
+RC = *wrc
+
+!ifdef DLL
+cflags_dll_nt      = -bd
+cflags_dll_os2     = -bd -DPDC_DLL_BUILD
+cflags_dll_imp_nt  = -DPDC_DLL_BUILD
+!endif
+
+CFLAGS += -bt=$(TARGET) -m$(MODEL) -wx -zq -i=$(PDCURSES_SRCDIR)
+!ifeq DEBUG Y
+CFLAGS += -d2 -DDEBUG -DPDCDEBUG
+!ifdef TARGET16
+CFLAGS += -hw
+!else
+CFLAGS += -hd
+!endif
+!else
+CFLAGS += -s -oneatx -DNDEBUG
+!endif
+!ifdef CHTYPE_32
+CFLAGS += -DCHTYPE_32
+!endif
+!ifeq WIDE Y
+CFLAGS += -DPDC_WIDE
+!endif
+!ifeq UTF8 Y
+CFLAGS += -DPDC_FORCE_UTF8
+!endif
+!ifeq TARGET dos
+CFLAGS += -DDOS
+!endif
+!ifdef cflags_dll_$(TARGET)
+CFLAGS += $(cflags_dll_imp_$(TARGET))
+DLL_CFLAGS_ = $(cflags_dll_$(TARGET))
+!endif
+
+!ifdef DLL
+ltarget_dll_nt    = nt_dll
+ltarget_dll_os2   = os2v2_dll
+!endif
+
+LDFLAGS = op q, noext
+!ifeq DEBUG Y
+!ifdef TARGET16
+LDFLAGS += debug watcom all
+!else
+LDFLAGS += debug dwarf all
+!endif
+!endif
+
+srcdir = $(PDCURSES_SRCDIR)/pdcurses
+demodir = $(PDCURSES_SRCDIR)/demos
+
+LIBOBJS = addch.obj addchstr.obj addstr.obj attr.obj beep.obj bkgd.obj &
+    border.obj clear.obj color.obj delch.obj deleteln.obj &
+    getch.obj getstr.obj getyx.obj inch.obj inchstr.obj initscr.obj inopts.obj &
+    insch.obj insstr.obj instr.obj kernel.obj keyname.obj mouse.obj move.obj &
+    outopts.obj overlay.obj pad.obj panel.obj printw.obj refresh.obj &
+    scanw.obj scr_dump.obj scroll.obj slk.obj termattr.obj &
+    touch.obj util.obj window.obj debug.obj
+
+PDCOBJS = pdcclip.obj pdcdisp.obj pdcgetsc.obj pdckbd.obj pdcscrn.obj &
+    pdcsetsc.obj pdcutil.obj
+
+DEMOS = firework$(E) newtest$(E) ozdemo$(E) picsview$(E) ptest$(E) &
+    rain$(E) speed$(E) test_pan$(E) testcurs$(E) tuidemo$(E) worm$(E) xmas$(E)
+
+PDCNAME = pdcurses
+
+!ifdef __LOADDLL__
+! loaddll wcc    wccd
+! loaddll wcc386 wccd386
+! loaddll wlink  wlinkd
+! loaddll wlib   wlibd
+!endif
+
+all:	$(PDCNAME).lib
+
+.c: $(srcdir);$(PDCURSES_SRCDIR)/$(osdir);$(demodir)
+.c.obj: .autodepend
+!ifeq TARGET dos
+    @set INCLUDE=$(%WATCOM)/h
+!else ifeq TARGET os2
+    @set INCLUDE=$(%WATCOM)/h;$(%WATCOM)/h/os2
+!else ifeq TARGET nt
+    @set INCLUDE=$(%WATCOM)/h;$(%WATCOM)/h/nt
+!else ifeq TARGET linux
+    @set INCLUDE=$(%WATCOM)/lh
+!endif
+    $(CC) $(CFLAGS) $(DLL_CFLAGS_$(build_dll_$^&)) -fo=$@ $<
+
+!ifeq TARGET linux
+.obj.:
+!else
+.obj$(E):
+!endif
+    $(LINK) $(LDFLAGS) name $@ sys $(LTARGET) file $*.obj lib $(PDCNAME).lib $(ADDED_LIBS)
+
+build_dll_firework	= no
+build_dll_newtest	= no
+build_dll_ozdemo	= no
+build_dll_picsview	= no
+build_dll_ptest	= no
+build_dll_rain		= no
+build_dll_test_pan	= no
+build_dll_testcurs	= no
+build_dll_tui		= no
+build_dll_tuidemo	= no
+build_dll_worm		= no
+build_dll_xmas		= no
+
+firework$(E):	firework.obj $(PDCNAME).lib
+newtest$(E):	newtest.obj $(PDCNAME).lib
+ozdemo$(E):	ozdemo.obj $(PDCNAME).lib
+picsview$(E): picsview.obj $(PDCNAME).lib
+ptest$(E):	ptest.obj $(PDCNAME).lib
+rain$(E):	rain.obj $(PDCNAME).lib
+testcurs$(E):	testcurs.obj $(PDCNAME).lib
+test_pan$(E):	test_pan.obj $(PDCNAME).lib
+worm$(E):	worm.obj $(PDCNAME).lib
+xmas$(E):	xmas.obj $(PDCNAME).lib
+
+tuidemo$(E):	tuidemo.obj tui.obj $(PDCNAME).lib
+    $(LINK) $(LDFLAGS) name $@ sys $(LTARGET) file {tuidemo.obj tui.obj} lib $(PDCNAME).lib $(ADDED_LIBS)
+
+!ifdef ltarget_dll_$(TARGET)
+version_res_nt = $(PDCNAME).res
+
+.rc: $(PDCURSES_SRCDIR)/common
+.rc.res:
+!ifeq TARGET nt
+    @set INCLUDE=$(%WATCOM)/h;$(%WATCOM)/h/nt
+!endif
+    $(RC) -r -bt=$(TARGET) $< -fo=$@
+!endif
+
+$(PDCNAME).lbc : $(LIBOBJS) $(PDCOBJS) $(version_res_$(TARGET))
+!ifdef ltarget_dll_$(TARGET)
+    $(LINK) $(LDFLAGS) name $(PDCNAME).dll sys $(ltarget_dll_$(TARGET)) opt impfile=$@ file {$(LIBOBJS) $(PDCOBJS)} $(ADDED_LIBS_FOR_DLL)
+!ifdef version_res_$(TARGET)
+    $(RC) -k -bt=$(TARGET) $(version_res_$(TARGET)) $(PDCNAME).dll
+!endif
+!else
+    %write $@ $(LIBOBJS) $(PDCOBJS)
+!endif
+
+$(PDCNAME).lib : $(PDCNAME).lbc
+    $(LIBEXE) $@ @$<
+!ifdef EXTRA_LIB_CMD
+    $(EXTRA_LIB_CMD)
+!endif
+
+demos: $(DEMOS)
+
+dist: .symbolic
+
+clean: .symbolic
+    @if exist *.obj -$(DEL) *.obj
+    @if exist *.lib -$(DEL) *.lib
+    @if exist *.dll -$(DEL) *.dll
+    @for %f in ($(DEMOS)) do @if exist %f -$(DEL) %f
+    @if exist *.err -$(DEL) *.err
+    @if exist *.map -$(DEL) *.map
+    @if exist *.res -$(DEL) *.res
+    @if exist *.lbc -$(DEL) *.lbc
diff --git a/lib/PDCursesMod/curses.h b/lib/PDCursesMod/curses.h
new file mode 100644
index 00000000000..b858f85110b
--- /dev/null
+++ b/lib/PDCursesMod/curses.h
@@ -0,0 +1,1774 @@
+/*----------------------------------------------------------------------*
+ *                              PDCurses                                *
+ *----------------------------------------------------------------------*/
+
+#ifndef __PDCURSES__
+#define __PDCURSES__ 1
+
+/*man-start**************************************************************
+
+Define before inclusion (only those needed):
+
+    XCURSES         if building / built for X11
+    PDC_RGB         if you want to use RGB color definitions
+                    (Red = 1, Green = 2, Blue = 4) instead of BGR
+    PDC_WIDE        if building / built with wide-character support
+    PDC_DLL_BUILD   if building / built as a Windows DLL
+    PDC_NCMOUSE     to use the ncurses mouse API instead
+                    of PDCurses' traditional mouse API
+
+Defined by this header:
+
+    PDCURSES        PDCurses-only features are available
+    PDC_BUILD       API build version
+    PDC_VER_MAJOR   major version number
+    PDC_VER_MINOR   minor version number
+    PDC_VERDOT      version string
+
+**man-end****************************************************************/
+
+#define PDCURSES        1
+#define PDC_BUILD (PDC_VER_MAJOR*1000 + PDC_VER_MINOR *100 + PDC_VER_CHANGE)
+#define PDC_VER_MAJOR    4
+#define PDC_VER_MINOR    2
+#define PDC_VER_CHANGE   3
+#define PDC_VER_YEAR   2021
+#define PDC_VER_MONTH    04
+#define PDC_VER_DAY      20
+
+#define PDC_STRINGIZE( x) #x
+#define PDC_stringize( x) PDC_STRINGIZE( x)
+
+#define PDC_VERDOT PDC_stringize( PDC_VER_MAJOR) "." \
+                   PDC_stringize( PDC_VER_MINOR) "." \
+                   PDC_stringize( PDC_VER_CHANGE)
+
+#define PDC_VER_YMD PDC_stringize( PDC_VER_YEAR) "-" \
+                    PDC_stringize( PDC_VER_MONTH) "-" \
+                    PDC_stringize( PDC_VER_DAY)
+
+#define CHTYPE_LONG     1      /* chtype >= 32 bits */
+
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+# define PDC_99         1
+#endif
+
+#if defined(__cplusplus) && __cplusplus >= 199711L
+# define PDC_PP98       1
+#endif
+
+/*----------------------------------------------------------------------*/
+
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>
+
+#ifdef PDC_WIDE
+# include <wchar.h>
+#endif
+
+#if defined(PDC_99) && !defined(__bool_true_false_are_defined)
+# include <stdbool.h>
+#endif
+
+#ifdef __cplusplus
+extern "C"
+{
+# ifndef PDC_PP98
+#  define bool _bool
+# endif
+#endif
+
+#ifdef NO_STDINT_H
+   #define uint64_t unsigned __int64
+   #define uint32_t unsigned long
+   #define uint16_t unsigned short
+#else
+   #include <stdint.h>
+#endif
+
+/*----------------------------------------------------------------------
+ *
+ *  Constants and Types
+ *
+ */
+
+#undef FALSE
+#define FALSE 0
+
+#undef TRUE
+#define TRUE 1
+
+#undef ERR
+#define ERR (-1)
+
+#undef OK
+#define OK 0
+
+#if !defined(PDC_PP98) && !defined(__bool_true_false_are_defined)
+typedef unsigned char bool;
+#endif
+
+#if defined( CHTYPE_32)
+   #if defined( CHTYPE_64)
+       #error CHTYPE cannot be both CHTYPE_32 and CHTYPE_64
+   #endif
+   typedef uint32_t chtype;       /* chtypes will be 32 bits */
+#else
+   #define CHTYPE_64
+   typedef uint64_t chtype;       /* chtypes will be 64 bits */
+   #ifdef PDC_WIDE
+      #define USING_COMBINING_CHARACTER_SCHEME
+   #endif
+#endif
+
+#ifdef PDC_WIDE
+typedef chtype cchar_t;
+#endif
+
+typedef chtype attr_t;
+
+/*----------------------------------------------------------------------
+ *
+ *  Version Info
+ *
+ */
+
+enum PDC_port
+{
+    PDC_PORT_X11 = 0,
+    PDC_PORT_WINCON = 1,
+    PDC_PORT_WINGUI = 2,
+    PDC_PORT_DOS = 3,
+    PDC_PORT_OS2 = 4,
+    PDC_PORT_SDL1 = 5,
+    PDC_PORT_SDL2 = 6,
+    PDC_PORT_VT = 7,
+    PDC_PORT_DOSVGA = 8,
+	PDC_PORT_PLAN9 = 9,
+    PDC_PORT_ANSI = 10
+};
+
+/* Use this structure with PDC_get_version() for run-time info about the
+   way the library was built, in case it doesn't match the header. */
+
+typedef struct
+{
+    short flags;          /* flags OR'd together (see below) */
+    short build;          /* PDC_BUILD at compile time */
+    unsigned char major;  /* PDC_VER_MAJOR */
+    unsigned char minor;  /* PDC_VER_MINOR */
+    unsigned char change; /* PDC_VER_CHANGE */
+    unsigned char csize;  /* sizeof chtype */
+    unsigned char bsize;  /* sizeof bool */
+    enum PDC_port port;
+} PDC_VERSION;
+
+enum
+{
+    PDC_VFLAG_DEBUG = 1,  /* set if built with -DPDCDEBUG */
+    PDC_VFLAG_WIDE  = 2,  /* -DPDC_WIDE */
+    PDC_VFLAG_UTF8  = 4,  /* -DPDC_FORCE_UTF8 */
+    PDC_VFLAG_DLL   = 8,  /* -DPDC_DLL_BUILD */
+    PDC_VFLAG_RGB   = 16  /* -DPDC_RGB */
+};
+
+/*----------------------------------------------------------------------
+ *
+ *  Mouse Interface -- SYSVR4, with extensions
+ *
+ */
+
+#define PDC_MAX_MOUSE_BUTTONS          9
+
+#if _LP64
+typedef unsigned int mmask_t;
+#else
+typedef unsigned long mmask_t;
+#endif
+
+typedef struct
+{
+    int x;           /* absolute column, 0 based, measured in characters */
+    int y;           /* absolute row, 0 based, measured in characters */
+    short button[PDC_MAX_MOUSE_BUTTONS];         /* state of each button */
+    int changes;     /* flags indicating what has changed with the mouse */
+} MOUSE_STATUS;
+
+#define BUTTON_RELEASED         0x0000
+#define BUTTON_PRESSED          0x0001
+#define BUTTON_CLICKED          0x0002
+#define BUTTON_DOUBLE_CLICKED   0x0003
+#define BUTTON_TRIPLE_CLICKED   0x0004
+#define BUTTON_MOVED            0x0005  /* PDCurses */
+#define WHEEL_SCROLLED          0x0006  /* PDCurses */
+#define BUTTON_ACTION_MASK      0x0007  /* PDCurses */
+
+#define PDC_BUTTON_SHIFT        0x0008  /* PDCurses */
+#define PDC_BUTTON_CONTROL      0x0010  /* PDCurses */
+#define PDC_BUTTON_ALT          0x0020  /* PDCurses */
+#define BUTTON_MODIFIER_MASK    0x0038  /* PDCurses */
+
+#define MOUSE_X_POS             (Mouse_status.x)
+#define MOUSE_Y_POS             (Mouse_status.y)
+
+/*
+ * Bits associated with the .changes field:
+ *   3         2         1         0
+ * 210987654321098765432109876543210
+ *                                 1 <- button 1 has changed   0
+ *                                10 <- button 2 has changed   1
+ *                               100 <- button 3 has changed   2
+ *                              1000 <- mouse has moved        3
+ *                             10000 <- mouse position report  4
+ *                            100000 <- mouse wheel up         5
+ *                           1000000 <- mouse wheel down       6
+ *                          10000000 <- mouse wheel left       7
+ *                         100000000 <- mouse wheel right      8
+ *                        1000000000 <- button 4 has changed   9
+ * (NOTE: buttons 6 to   10000000000 <- button 5 has changed  10
+ * 9 aren't implemented 100000000000 <- button 6 has changed  11
+ * in any flavor of    1000000000000 <- button 7 has changed  12
+ * PDCurses yet!)     10000000000000 <- button 8 has changed  13
+ *                   100000000000000 <- button 9 has changed  14
+ */
+
+#define PDC_MOUSE_MOVED         0x0008
+#define PDC_MOUSE_POSITION      0x0010
+#define PDC_MOUSE_WHEEL_UP      0x0020
+#define PDC_MOUSE_WHEEL_DOWN    0x0040
+#define PDC_MOUSE_WHEEL_LEFT    0x0080
+#define PDC_MOUSE_WHEEL_RIGHT   0x0100
+
+#define A_BUTTON_CHANGED        (Mouse_status.changes & 7)
+#define MOUSE_MOVED             (Mouse_status.changes & PDC_MOUSE_MOVED)
+#define MOUSE_POS_REPORT        (Mouse_status.changes & PDC_MOUSE_POSITION)
+#define BUTTON_CHANGED(x)       (Mouse_status.changes & (1 << ((x) - ((x)<4 ? 1 : -5))))
+#define BUTTON_STATUS(x)        (Mouse_status.button[(x) - 1])
+#define MOUSE_WHEEL_UP          (Mouse_status.changes & PDC_MOUSE_WHEEL_UP)
+#define MOUSE_WHEEL_DOWN        (Mouse_status.changes & PDC_MOUSE_WHEEL_DOWN)
+#define MOUSE_WHEEL_LEFT        (Mouse_status.changes & PDC_MOUSE_WHEEL_LEFT)
+#define MOUSE_WHEEL_RIGHT       (Mouse_status.changes & PDC_MOUSE_WHEEL_RIGHT)
+
+/* mouse bit-masks */
+
+#define BUTTON1_RELEASED        0x00000001L
+#define BUTTON1_PRESSED         0x00000002L
+#define BUTTON1_CLICKED         0x00000004L
+#define BUTTON1_DOUBLE_CLICKED  0x00000008L
+#define BUTTON1_TRIPLE_CLICKED  0x00000010L
+#define BUTTON1_MOVED           0x00000010L /* PDCurses */
+
+#define BUTTON2_RELEASED        0x00000020L
+#define BUTTON2_PRESSED         0x00000040L
+#define BUTTON2_CLICKED         0x00000080L
+#define BUTTON2_DOUBLE_CLICKED  0x00000100L
+#define BUTTON2_TRIPLE_CLICKED  0x00000200L
+#define BUTTON2_MOVED           0x00000200L /* PDCurses */
+
+#define BUTTON3_RELEASED        0x00000400L
+#define BUTTON3_PRESSED         0x00000800L
+#define BUTTON3_CLICKED         0x00001000L
+#define BUTTON3_DOUBLE_CLICKED  0x00002000L
+#define BUTTON3_TRIPLE_CLICKED  0x00004000L
+#define BUTTON3_MOVED           0x00004000L /* PDCurses */
+
+/* For the ncurses-compatible functions only, BUTTON4_PRESSED and
+   BUTTON5_PRESSED are returned for mouse scroll wheel up and down;
+   otherwise PDCurses doesn't support buttons 4 and 5... except
+   as described above for WinGUI,  and perhaps to be extended to
+   other PDCurses flavors  */
+
+#define BUTTON4_RELEASED        0x00008000L
+#define BUTTON4_PRESSED         0x00010000L
+#define BUTTON4_CLICKED         0x00020000L
+#define BUTTON4_DOUBLE_CLICKED  0x00040000L
+#define BUTTON4_TRIPLE_CLICKED  0x00080000L
+
+#define BUTTON5_RELEASED        0x00100000L
+#define BUTTON5_PRESSED         0x00200000L
+#define BUTTON5_CLICKED         0x00400000L
+#define BUTTON5_DOUBLE_CLICKED  0x00800000L
+#define BUTTON5_TRIPLE_CLICKED  0x01000000L
+
+#define MOUSE_WHEEL_SCROLL      0x02000000L /* PDCurses */
+#define BUTTON_MODIFIER_SHIFT   0x04000000L /* PDCurses */
+#define BUTTON_MODIFIER_CONTROL 0x08000000L /* PDCurses */
+#define BUTTON_MODIFIER_ALT     0x10000000L /* PDCurses */
+
+#define ALL_MOUSE_EVENTS        0x1fffffffL
+#define REPORT_MOUSE_POSITION   0x20000000L
+
+/* ncurses mouse interface */
+
+typedef struct
+{
+    short id;       /* unused, always 0 */
+    int x, y, z;    /* x, y same as MOUSE_STATUS; z unused */
+    mmask_t bstate; /* equivalent to changes + button[], but
+                       in the same format as used for mousemask() */
+} MEVENT;
+
+#if defined(PDC_NCMOUSE) && !defined(NCURSES_MOUSE_VERSION)
+# define NCURSES_MOUSE_VERSION 2
+#endif
+
+#ifdef NCURSES_MOUSE_VERSION
+# define BUTTON_SHIFT   BUTTON_MODIFIER_SHIFT
+# define BUTTON_CONTROL BUTTON_MODIFIER_CONTROL
+# define BUTTON_CTRL    BUTTON_MODIFIER_CONTROL
+# define BUTTON_ALT     BUTTON_MODIFIER_ALT
+#else
+# define BUTTON_SHIFT   PDC_BUTTON_SHIFT
+# define BUTTON_CONTROL PDC_BUTTON_CONTROL
+# define BUTTON_ALT     PDC_BUTTON_ALT
+#endif
+
+/*----------------------------------------------------------------------
+ *
+ *  Window and Screen Structures
+ *
+ */
+
+typedef struct _win       /* definition of a window */
+{
+    int   _cury;          /* current pseudo-cursor */
+    int   _curx;
+    int   _maxy;          /* max window coordinates */
+    int   _maxx;
+    int   _begy;          /* origin on screen */
+    int   _begx;
+    int   _flags;         /* window properties */
+    chtype _attrs;        /* standard attributes and colors */
+    chtype _bkgd;         /* background, normally blank */
+    bool  _clear;         /* causes clear at next refresh */
+    bool  _leaveit;       /* leaves cursor where it is */
+    bool  _scroll;        /* allows window scrolling */
+    bool  _nodelay;       /* input character wait flag */
+    bool  _immed;         /* immediate update flag */
+    bool  _sync;          /* synchronise window ancestors */
+    bool  _use_keypad;    /* flags keypad key mode active */
+    chtype **_y;          /* pointer to line pointer array */
+    int   *_firstch;      /* first changed character in line */
+    int   *_lastch;       /* last changed character in line */
+    int   _tmarg;         /* top of scrolling region */
+    int   _bmarg;         /* bottom of scrolling region */
+    int   _delayms;       /* milliseconds of delay for getch() */
+    int   _parx, _pary;   /* coords relative to parent (0,0) */
+    struct _win *_parent; /* subwin's pointer to parent win */
+} WINDOW;
+
+/* Color pair structure */
+
+typedef struct
+{
+    int f;                /* foreground color */
+    int b;                /* background color */
+} PDC_PAIR;
+
+/* Avoid using the SCREEN struct directly -- use the corresponding
+   functions if possible. This struct may eventually be made private. */
+
+typedef struct
+{
+    bool  alive;          /* if initscr() called, and not endwin() */
+    bool  autocr;         /* if cr -> lf */
+    bool  cbreak;         /* if terminal unbuffered */
+    bool  echo;           /* if terminal echo */
+    bool  raw_inp;        /* raw input mode (v. cooked input) */
+    bool  raw_out;        /* raw output mode (7 v. 8 bits) */
+    bool  audible;        /* FALSE if the bell is visual */
+    bool  mono;           /* TRUE if current screen is mono */
+    bool  resized;        /* TRUE if TERM has been resized */
+    bool  orig_attr;      /* TRUE if we have the original colors */
+    short orig_fore;      /* original screen foreground color */
+    short orig_back;      /* original screen foreground color */
+    int   cursrow;        /* position of physical cursor */
+    int   curscol;        /* position of physical cursor */
+    int   visibility;     /* visibility of cursor */
+    int   orig_cursor;    /* original cursor size */
+    int   lines;          /* new value for LINES */
+    int   cols;           /* new value for COLS */
+    mmask_t _trap_mbe;             /* trap these mouse button events */
+    int   mouse_wait;              /* time to wait (in ms) for a
+                                      button release after a press, in
+                                      order to count it as a click */
+    int   slklines;                /* lines in use by slk_init() */
+    WINDOW *slk_winptr;            /* window for slk */
+    int   linesrippedoff;          /* lines ripped off via ripoffline() */
+    int   linesrippedoffontop;     /* lines ripped off on
+                                      top via ripoffline() */
+    int   delaytenths;             /* 1/10ths second to wait block
+                                      getch() for */
+    bool  _preserve;               /* TRUE if screen background
+                                      to be preserved */
+    int   _restore;                /* specifies if screen background
+                                      to be restored, and how */
+    unsigned long key_modifiers;   /* key modifiers (SHIFT, CONTROL, etc.)
+                                      on last key press */
+    bool  return_key_modifiers;    /* TRUE if modifier keys are
+                                      returned as "real" keys */
+    bool  key_code;                /* TRUE if last key is a special key;
+                                      used internally by get_wch() */
+    MOUSE_STATUS mouse_status;     /* last returned mouse status */
+    short line_color;     /* color of line attributes - default -1 */
+    attr_t termattrs;     /* attribute capabilities */
+    WINDOW *lastscr;      /* the last screen image */
+    FILE *dbfp;           /* debug trace file pointer */
+    bool  color_started;  /* TRUE after start_color() */
+    bool  dirty;          /* redraw on napms() after init_color() */
+    int   sel_start;      /* start of selection (y * COLS + x) */
+    int   sel_end;        /* end of selection */
+    int  *c_buffer;       /* character buffer */
+    int   c_pindex;       /* putter index */
+    int   c_gindex;       /* getter index */
+    int  *c_ungch;        /* array of ungotten chars */
+    int   c_ungind;       /* ungetch() push index */
+    int   c_ungmax;       /* allocated size of ungetch() buffer */
+    PDC_PAIR *atrtab;     /* table of color pairs */
+} SCREEN;
+
+/*----------------------------------------------------------------------
+ *
+ *  External Variables
+ *
+ */
+
+#ifdef PDC_DLL_BUILD
+# ifdef CURSES_LIBRARY
+#  define PDCEX __declspec(dllexport) extern
+# else
+#  define PDCEX __declspec(dllimport)
+# endif
+#else
+# define PDCEX extern
+#endif
+
+PDCEX  int          LINES;        /* terminal height */
+PDCEX  int          COLS;         /* terminal width */
+PDCEX  WINDOW       *stdscr;      /* the default screen window */
+PDCEX  WINDOW       *curscr;      /* the current screen image */
+PDCEX  SCREEN       *SP;          /* curses variables */
+PDCEX  MOUSE_STATUS Mouse_status;
+PDCEX  int          COLORS;
+PDCEX  int          COLOR_PAIRS;
+PDCEX  int          TABSIZE;
+PDCEX  chtype       acs_map[];    /* alternate character set map */
+PDCEX  char         ttytype[];    /* terminal name/description */
+
+/*man-start**************************************************************
+
+Text Attributes
+===============
+
+If CHTYPE_32 is #defined,  PDCurses uses a 32-bit integer for its chtype:
+
+    +--------------------------------------------------------------------+
+    |31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|..| 2| 1| 0|
+    +--------------------------------------------------------------------+
+          color pair        |     modifiers         |   character eg 'a'
+
+There are 256 color pairs (8 bits), 8 bits for modifiers, and 16 bits
+for character data. The modifiers are bold, underline, right-line,
+left-line, italic, reverse and blink, plus the alternate character set
+indicator.
+
+   By default,  a 64-bit chtype is used :
+
+-------------------------------------------------------------------------------
+|63|62|..|53|52|..|34|33|32|31|30|29|28|..|22|21|20|19|18|17|16|..| 3| 2| 1| 0|
+-------------------------------------------------------------------------------
+  unused    |color pair |        modifiers      |         character eg 'a'
+
+   We take five more bits for the character (thus allowing Unicode values
+past 64K;  the full range of Unicode goes up to 0x10ffff,  requiring 21 bits
+total),  and four more bits for attributes.  Three are currently used as
+A_OVERLINE, A_DIM, and A_STRIKEOUT;  one more is reserved for future use.
+Bits 33-52 are used to specify a color pair.  In theory,  there can be
+2^20 = 1048576 color pairs; as of 2021 Apr 20,  only WinGUI,  VT and X11
+have COLOR_PAIRS = 1048576.  Other platforms may join them,  but some
+(DOS,  OS/2) simply do not have full-color capability.
+
+   Bits 53-63 are currently unused.
+
+**man-end****************************************************************/
+
+/*** Video attribute macros ***/
+
+#define A_NORMAL      (chtype)0
+
+#ifdef CHTYPE_64
+    # define PDC_CHARTEXT_BITS   21
+    # define A_CHARTEXT   (chtype)( ((chtype)0x1 << PDC_CHARTEXT_BITS) - 1)
+    # define A_ALTCHARSET ((chtype)0x001 << PDC_CHARTEXT_BITS)
+    # define A_RIGHT      ((chtype)0x002 << PDC_CHARTEXT_BITS)
+    # define A_LEFT       ((chtype)0x004 << PDC_CHARTEXT_BITS)
+    # define A_INVIS      ((chtype)0x008 << PDC_CHARTEXT_BITS)
+    # define A_UNDERLINE  ((chtype)0x010 << PDC_CHARTEXT_BITS)
+    # define A_REVERSE    ((chtype)0x020 << PDC_CHARTEXT_BITS)
+    # define A_BLINK      ((chtype)0x040 << PDC_CHARTEXT_BITS)
+    # define A_BOLD       ((chtype)0x080 << PDC_CHARTEXT_BITS)
+    # define A_OVERLINE   ((chtype)0x100 << PDC_CHARTEXT_BITS)
+    # define A_STRIKEOUT  ((chtype)0x200 << PDC_CHARTEXT_BITS)
+    # define A_DIM        ((chtype)0x400 << PDC_CHARTEXT_BITS)
+    # define PDC_COLOR_SHIFT (PDC_CHARTEXT_BITS + 12)
+    # define A_COLOR      ((chtype)0xfffff << PDC_COLOR_SHIFT)
+    # define A_ATTRIBUTES (((chtype)0xfff << PDC_CHARTEXT_BITS) | A_COLOR)
+# else         /* plain ol' 32-bit chtypes */
+    # define PDC_CHARTEXT_BITS      16
+    # define A_ALTCHARSET (chtype)0x00010000
+    # define A_RIGHT      (chtype)0x00020000
+    # define A_LEFT       (chtype)0x00040000
+    # define A_INVIS      (chtype)0x00080000
+    # define A_UNDERLINE  (chtype)0x00100000
+    # define A_REVERSE    (chtype)0x00200000
+    # define A_BLINK      (chtype)0x00400000
+    # define A_BOLD       (chtype)0x00800000
+    # define A_COLOR      (chtype)0xff000000
+    # define PDC_COLOR_SHIFT 24
+#ifdef PDC_WIDE
+    # define A_CHARTEXT   (chtype)0x0000ffff
+    # define A_ATTRIBUTES (chtype)0xffff0000
+    # define A_DIM        A_NORMAL
+    # define A_OVERLINE   A_NORMAL
+    # define A_STRIKEOUT  A_NORMAL
+#else          /* with 8-bit chars,  we have bits for these attribs : */
+    # define A_CHARTEXT   (chtype)0x000000ff
+    # define A_ATTRIBUTES (chtype)0xffffe000
+    # define A_DIM        (chtype)0x00008000
+    # define A_OVERLINE   (chtype)0x00004000
+    # define A_STRIKEOUT  (chtype)0x00002000
+#endif
+#endif
+
+#define A_ITALIC      A_INVIS
+#define A_PROTECT    (A_UNDERLINE | A_LEFT | A_RIGHT)
+#define A_STANDOUT    (A_REVERSE | A_BOLD) /* X/Open */
+
+#define CHR_MSK       A_CHARTEXT           /* Obsolete */
+#define ATR_MSK       A_ATTRIBUTES         /* Obsolete */
+#define ATR_NRM       A_NORMAL             /* Obsolete */
+
+#define A_LEFTLINE    A_LEFT
+#define A_RIGHTLINE   A_RIGHT
+
+/* For use with attr_t -- X/Open says, "these shall be distinct", so
+   this is a non-conforming implementation. */
+
+#define WA_NORMAL     A_NORMAL
+
+#define WA_ALTCHARSET A_ALTCHARSET
+#define WA_BLINK      A_BLINK
+#define WA_BOLD       A_BOLD
+#define WA_DIM        A_DIM
+#define WA_INVIS      A_INVIS
+#define WA_ITALIC     A_ITALIC
+#define WA_LEFT       A_LEFT
+#define WA_PROTECT    A_PROTECT
+#define WA_REVERSE    A_REVERSE
+#define WA_RIGHT      A_RIGHT
+#define WA_STANDOUT   A_STANDOUT
+#define WA_UNDERLINE  A_UNDERLINE
+
+#define WA_HORIZONTAL A_HORIZONTAL
+#define WA_LOW        A_LOW
+#define WA_TOP        A_TOP
+#define WA_VERTICAL   A_VERTICAL
+
+#define WA_ATTRIBUTES A_ATTRIBUTES
+
+/*** Alternate character set macros ***/
+
+#define PDC_ACS(w) ((chtype)w | A_ALTCHARSET)
+
+/* VT100-compatible symbols -- box chars */
+
+#define ACS_LRCORNER      PDC_ACS('V')
+#define ACS_URCORNER      PDC_ACS('W')
+#define ACS_ULCORNER      PDC_ACS('X')
+#define ACS_LLCORNER      PDC_ACS('Y')
+#define ACS_PLUS          PDC_ACS('Z')
+#define ACS_LTEE          PDC_ACS('[')
+#define ACS_RTEE          PDC_ACS('\\')
+#define ACS_BTEE          PDC_ACS(']')
+#define ACS_TTEE          PDC_ACS('^')
+#define ACS_HLINE         PDC_ACS('_')
+#define ACS_VLINE         PDC_ACS('`')
+
+/* PDCurses-only ACS chars.  Don't use if ncurses compatibility matters.
+Some won't work in non-wide X11 builds (see 'acs_defs.h' for details). */
+
+#define ACS_CENT          PDC_ACS('{')
+#define ACS_YEN           PDC_ACS('|')
+#define ACS_PESETA        PDC_ACS('}')
+#define ACS_HALF          PDC_ACS('&')
+#define ACS_QUARTER       PDC_ACS('\'')
+#define ACS_LEFT_ANG_QU   PDC_ACS(')')
+#define ACS_RIGHT_ANG_QU  PDC_ACS('*')
+#define ACS_D_HLINE       PDC_ACS('a')
+#define ACS_D_VLINE       PDC_ACS('b')
+#define ACS_CLUB          PDC_ACS( 11)
+#define ACS_HEART         PDC_ACS( 12)
+#define ACS_SPADE         PDC_ACS( 13)
+#define ACS_SMILE         PDC_ACS( 14)
+#define ACS_REV_SMILE     PDC_ACS( 15)
+#define ACS_MED_BULLET    PDC_ACS( 16)
+#define ACS_WHITE_BULLET  PDC_ACS( 17)
+#define ACS_PILCROW       PDC_ACS( 18)
+#define ACS_SECTION       PDC_ACS( 19)
+
+#define ACS_SUP2          PDC_ACS(',')
+#define ACS_ALPHA         PDC_ACS('.')
+#define ACS_BETA          PDC_ACS('/')
+#define ACS_GAMMA         PDC_ACS('0')
+#define ACS_UP_SIGMA      PDC_ACS('1')
+#define ACS_LO_SIGMA      PDC_ACS('2')
+#define ACS_MU            PDC_ACS('4')
+#define ACS_TAU           PDC_ACS('5')
+#define ACS_UP_PHI        PDC_ACS('6')
+#define ACS_THETA         PDC_ACS('7')
+#define ACS_OMEGA         PDC_ACS('8')
+#define ACS_DELTA         PDC_ACS('9')
+#define ACS_INFINITY      PDC_ACS('-')
+#define ACS_LO_PHI        PDC_ACS( 22)
+#define ACS_EPSILON       PDC_ACS(':')
+#define ACS_INTERSECT     PDC_ACS('e')
+#define ACS_TRIPLE_BAR    PDC_ACS('f')
+#define ACS_DIVISION      PDC_ACS('c')
+#define ACS_APPROX_EQ     PDC_ACS('d')
+#define ACS_SM_BULLET     PDC_ACS('g')
+#define ACS_SQUARE_ROOT   PDC_ACS('i')
+#define ACS_UBLOCK        PDC_ACS('p')
+#define ACS_BBLOCK        PDC_ACS('q')
+#define ACS_LBLOCK        PDC_ACS('r')
+#define ACS_RBLOCK        PDC_ACS('s')
+
+#define ACS_A_ORDINAL     PDC_ACS(20)
+#define ACS_O_ORDINAL     PDC_ACS(21)
+#define ACS_INV_QUERY     PDC_ACS(24)
+#define ACS_REV_NOT       PDC_ACS(25)
+#define ACS_NOT           PDC_ACS(26)
+#define ACS_INV_BANG      PDC_ACS(23)
+#define ACS_UP_INTEGRAL   PDC_ACS(27)
+#define ACS_LO_INTEGRAL   PDC_ACS(28)
+#define ACS_SUP_N         PDC_ACS(29)
+#define ACS_CENTER_SQU    PDC_ACS(30)
+#define ACS_F_WITH_HOOK   PDC_ACS(31)
+
+#define ACS_SD_LRCORNER   PDC_ACS(';')
+#define ACS_SD_URCORNER   PDC_ACS('<')
+#define ACS_SD_ULCORNER   PDC_ACS('=')
+#define ACS_SD_LLCORNER   PDC_ACS('>')
+#define ACS_SD_PLUS       PDC_ACS('?')
+#define ACS_SD_LTEE       PDC_ACS('@')
+#define ACS_SD_RTEE       PDC_ACS('A')
+#define ACS_SD_BTEE       PDC_ACS('B')
+#define ACS_SD_TTEE       PDC_ACS('C')
+
+#define ACS_D_LRCORNER    PDC_ACS('D')
+#define ACS_D_URCORNER    PDC_ACS('E')
+#define ACS_D_ULCORNER    PDC_ACS('F')
+#define ACS_D_LLCORNER    PDC_ACS('G')
+#define ACS_D_PLUS        PDC_ACS('H')
+#define ACS_D_LTEE        PDC_ACS('I')
+#define ACS_D_RTEE        PDC_ACS('J')
+#define ACS_D_BTEE        PDC_ACS('K')
+#define ACS_D_TTEE        PDC_ACS('L')
+
+#define ACS_DS_LRCORNER   PDC_ACS('M')
+#define ACS_DS_URCORNER   PDC_ACS('N')
+#define ACS_DS_ULCORNER   PDC_ACS('O')
+#define ACS_DS_LLCORNER   PDC_ACS('P')
+#define ACS_DS_PLUS       PDC_ACS('Q')
+#define ACS_DS_LTEE       PDC_ACS('R')
+#define ACS_DS_RTEE       PDC_ACS('S')
+#define ACS_DS_BTEE       PDC_ACS('T')
+#define ACS_DS_TTEE       PDC_ACS('U')
+
+/* VT100-compatible symbols -- other */
+
+#define ACS_S1            PDC_ACS('l')
+#define ACS_S9            PDC_ACS('o')
+#define ACS_DIAMOND       PDC_ACS('j')
+#define ACS_CKBOARD       PDC_ACS('k')
+#define ACS_DEGREE        PDC_ACS('w')
+#define ACS_PLMINUS       PDC_ACS('x')
+#define ACS_BULLET        PDC_ACS('h')
+
+/* Teletype 5410v1 symbols -- these are defined in SysV curses, but
+   are not well-supported by most terminals. Stick to VT100 characters
+   for optimum portability. */
+
+#define ACS_LARROW        PDC_ACS('!')
+#define ACS_RARROW        PDC_ACS(' ')
+#define ACS_DARROW        PDC_ACS('#')
+#define ACS_UARROW        PDC_ACS('"')
+#define ACS_BOARD         PDC_ACS('+')
+#define ACS_LTBOARD       PDC_ACS('y')
+#define ACS_LANTERN       PDC_ACS('z')
+#define ACS_BLOCK         PDC_ACS('t')
+
+/* That goes double for these -- undocumented SysV symbols. Don't use
+   them. */
+
+#define ACS_S3            PDC_ACS('m')
+#define ACS_S7            PDC_ACS('n')
+#define ACS_LEQUAL        PDC_ACS('u')
+#define ACS_GEQUAL        PDC_ACS('v')
+#define ACS_PI            PDC_ACS('$')
+#define ACS_NEQUAL        PDC_ACS('%')
+#define ACS_STERLING      PDC_ACS('~')
+
+/* Box char aliases */
+
+#define ACS_BSSB      ACS_ULCORNER
+#define ACS_SSBB      ACS_LLCORNER
+#define ACS_BBSS      ACS_URCORNER
+#define ACS_SBBS      ACS_LRCORNER
+#define ACS_SBSS      ACS_RTEE
+#define ACS_SSSB      ACS_LTEE
+#define ACS_SSBS      ACS_BTEE
+#define ACS_BSSS      ACS_TTEE
+#define ACS_BSBS      ACS_HLINE
+#define ACS_SBSB      ACS_VLINE
+#define ACS_SSSS      ACS_PLUS
+
+/* cchar_t aliases */
+
+#ifdef PDC_WIDE
+# define WACS_LRCORNER      (&(acs_map['V']))
+# define WACS_URCORNER      (&(acs_map['W']))
+# define WACS_ULCORNER      (&(acs_map['X']))
+# define WACS_LLCORNER      (&(acs_map['Y']))
+# define WACS_PLUS          (&(acs_map['Z']))
+# define WACS_LTEE          (&(acs_map['[']))
+# define WACS_RTEE          (&(acs_map['\\']))
+# define WACS_BTEE          (&(acs_map[']']))
+# define WACS_TTEE          (&(acs_map['^']))
+# define WACS_HLINE         (&(acs_map['_']))
+# define WACS_VLINE         (&(acs_map['`']))
+
+# define WACS_CENT          (&(acs_map['{']))
+# define WACS_YEN           (&(acs_map['|']))
+# define WACS_PESETA        (&(acs_map['}']))
+# define WACS_HALF          (&(acs_map['&']))
+# define WACS_QUARTER       (&(acs_map['\'']))
+# define WACS_LEFT_ANG_QU   (&(acs_map[')']))
+# define WACS_RIGHT_ANG_QU  (&(acs_map['*']))
+# define WACS_D_HLINE       (&(acs_map['a']))
+# define WACS_D_VLINE       (&(acs_map['b']))
+# define WACS_CLUB          (&(acs_map[ 11]))
+# define WACS_HEART         (&(acs_map[ 12]))
+# define WACS_SPADE         (&(acs_map[ 13]))
+# define WACS_SMILE         (&(acs_map[ 14]))
+# define WACS_REV_SMILE     (&(acs_map[ 15]))
+# define WACS_MED_BULLET    (&(acs_map[ 16]))
+# define WACS_WHITE_BULLET  (&(acs_map[ 17]))
+# define WACS_PILCROW       (&(acs_map[ 18]))
+# define WACS_SECTION       (&(acs_map[ 19]))
+
+# define WACS_SUP2          (&(acs_map[',']))
+# define WACS_ALPHA         (&(acs_map['.']))
+# define WACS_BETA          (&(acs_map['/']))
+# define WACS_GAMMA         (&(acs_map['0']))
+# define WACS_UP_SIGMA      (&(acs_map['1']))
+# define WACS_LO_SIGMA      (&(acs_map['2']))
+# define WACS_MU            (&(acs_map['4']))
+# define WACS_TAU           (&(acs_map['5']))
+# define WACS_UP_PHI        (&(acs_map['6']))
+# define WACS_THETA         (&(acs_map['7']))
+# define WACS_OMEGA         (&(acs_map['8']))
+# define WACS_DELTA         (&(acs_map['9']))
+# define WACS_INFINITY      (&(acs_map['-']))
+# define WACS_LO_PHI        (&(acs_map[ 22]))
+# define WACS_EPSILON       (&(acs_map[':']))
+# define WACS_INTERSECT     (&(acs_map['e']))
+# define WACS_TRIPLE_BAR    (&(acs_map['f']))
+# define WACS_DIVISION      (&(acs_map['c']))
+# define WACS_APPROX_EQ     (&(acs_map['d']))
+# define WACS_SM_BULLET     (&(acs_map['g']))
+# define WACS_SQUARE_ROOT   (&(acs_map['i']))
+# define WACS_UBLOCK        (&(acs_map['p']))
+# define WACS_BBLOCK        (&(acs_map['q']))
+# define WACS_LBLOCK        (&(acs_map['r']))
+# define WACS_RBLOCK        (&(acs_map['s']))
+
+# define WACS_A_ORDINAL     (&(acs_map[20]))
+# define WACS_O_ORDINAL     (&(acs_map[21]))
+# define WACS_INV_QUERY     (&(acs_map[24]))
+# define WACS_REV_NOT       (&(acs_map[25]))
+# define WACS_NOT           (&(acs_map[26]))
+# define WACS_INV_BANG      (&(acs_map[23]))
+# define WACS_UP_INTEGRAL   (&(acs_map[27]))
+# define WACS_LO_INTEGRAL   (&(acs_map[28]))
+# define WACS_SUP_N         (&(acs_map[29]))
+# define WACS_CENTER_SQU    (&(acs_map[30]))
+# define WACS_F_WITH_HOOK   (&(acs_map[31]))
+
+# define WACS_SD_LRCORNER   (&(acs_map[';']))
+# define WACS_SD_URCORNER   (&(acs_map['<']))
+# define WACS_SD_ULCORNER   (&(acs_map['=']))
+# define WACS_SD_LLCORNER   (&(acs_map['>']))
+# define WACS_SD_PLUS       (&(acs_map['?']))
+# define WACS_SD_LTEE       (&(acs_map['@']))
+# define WACS_SD_RTEE       (&(acs_map['A']))
+# define WACS_SD_BTEE       (&(acs_map['B']))
+# define WACS_SD_TTEE       (&(acs_map['C']))
+
+# define WACS_D_LRCORNER    (&(acs_map['D']))
+# define WACS_D_URCORNER    (&(acs_map['E']))
+# define WACS_D_ULCORNER    (&(acs_map['F']))
+# define WACS_D_LLCORNER    (&(acs_map['G']))
+# define WACS_D_PLUS        (&(acs_map['H']))
+# define WACS_D_LTEE        (&(acs_map['I']))
+# define WACS_D_RTEE        (&(acs_map['J']))
+# define WACS_D_BTEE        (&(acs_map['K']))
+# define WACS_D_TTEE        (&(acs_map['L']))
+
+# define WACS_DS_LRCORNER   (&(acs_map['M']))
+# define WACS_DS_URCORNER   (&(acs_map['N']))
+# define WACS_DS_ULCORNER   (&(acs_map['O']))
+# define WACS_DS_LLCORNER   (&(acs_map['P']))
+# define WACS_DS_PLUS       (&(acs_map['Q']))
+# define WACS_DS_LTEE       (&(acs_map['R']))
+# define WACS_DS_RTEE       (&(acs_map['S']))
+# define WACS_DS_BTEE       (&(acs_map['T']))
+# define WACS_DS_TTEE       (&(acs_map['U']))
+
+# define WACS_S1            (&(acs_map['l']))
+# define WACS_S9            (&(acs_map['o']))
+# define WACS_DIAMOND       (&(acs_map['j']))
+# define WACS_CKBOARD       (&(acs_map['k']))
+# define WACS_DEGREE        (&(acs_map['w']))
+# define WACS_PLMINUS       (&(acs_map['x']))
+# define WACS_BULLET        (&(acs_map['h']))
+
+
+# define WACS_LARROW        (&(acs_map['!']))
+# define WACS_RARROW        (&(acs_map[' ']))
+# define WACS_DARROW        (&(acs_map['#']))
+# define WACS_UARROW        (&(acs_map['"']))
+# define WACS_BOARD         (&(acs_map['+']))
+# define WACS_LTBOARD       (&(acs_map['y']))
+# define WACS_LANTERN       (&(acs_map['z']))
+# define WACS_BLOCK         (&(acs_map['t']))
+
+# define WACS_S3            (&(acs_map['m']))
+# define WACS_S7            (&(acs_map['n']))
+# define WACS_LEQUAL        (&(acs_map['u']))
+# define WACS_GEQUAL        (&(acs_map['v']))
+# define WACS_PI            (&(acs_map['$']))
+# define WACS_NEQUAL        (&(acs_map['%']))
+# define WACS_STERLING      (&(acs_map['~']))
+
+# define WACS_BSSB     WACS_ULCORNER
+# define WACS_SSBB     WACS_LLCORNER
+# define WACS_BBSS     WACS_URCORNER
+# define WACS_SBBS     WACS_LRCORNER
+# define WACS_SBSS     WACS_RTEE
+# define WACS_SSSB     WACS_LTEE
+# define WACS_SSBS     WACS_BTEE
+# define WACS_BSSS     WACS_TTEE
+# define WACS_BSBS     WACS_HLINE
+# define WACS_SBSB     WACS_VLINE
+# define WACS_SSSS     WACS_PLUS
+#endif
+
+/*** Color macros ***/
+
+#define COLOR_BLACK   0
+
+#ifdef PDC_RGB        /* RGB */
+# define COLOR_RED    1
+# define COLOR_GREEN  2
+# define COLOR_BLUE   4
+#else                 /* BGR */
+# define COLOR_BLUE   1
+# define COLOR_GREEN  2
+# define COLOR_RED    4
+#endif
+
+#define COLOR_CYAN    (COLOR_BLUE | COLOR_GREEN)
+#define COLOR_MAGENTA (COLOR_RED | COLOR_BLUE)
+#define COLOR_YELLOW  (COLOR_RED | COLOR_GREEN)
+
+#define COLOR_WHITE   7
+
+/*----------------------------------------------------------------------
+ *
+ *  Function and Keypad Key Definitions
+ *  Many are just for compatibility
+ *
+ */
+
+#ifdef PDC_WIDE
+   #define KEY_OFFSET 0xec00
+#else
+   #define KEY_OFFSET 0x100
+#endif
+
+#define KEY_CODE_YES     (KEY_OFFSET + 0x00) /* If get_wch() gives a key code */
+
+#define KEY_BREAK        (KEY_OFFSET + 0x01) /* Not on PC KBD */
+#define KEY_DOWN         (KEY_OFFSET + 0x02) /* Down arrow key */
+#define KEY_UP           (KEY_OFFSET + 0x03) /* Up arrow key */
+#define KEY_LEFT         (KEY_OFFSET + 0x04) /* Left arrow key */
+#define KEY_RIGHT        (KEY_OFFSET + 0x05) /* Right arrow key */
+#define KEY_HOME         (KEY_OFFSET + 0x06) /* home key */
+#define KEY_BACKSPACE    (KEY_OFFSET + 0x07) /* not on pc */
+#define KEY_F0           (KEY_OFFSET + 0x08) /* function keys; 64 reserved */
+
+#define KEY_DL           (KEY_OFFSET + 0x48) /* delete line */
+#define KEY_IL           (KEY_OFFSET + 0x49) /* insert line */
+#define KEY_DC           (KEY_OFFSET + 0x4a) /* delete character */
+#define KEY_IC           (KEY_OFFSET + 0x4b) /* insert char or enter ins mode */
+#define KEY_EIC          (KEY_OFFSET + 0x4c) /* exit insert char mode */
+#define KEY_CLEAR        (KEY_OFFSET + 0x4d) /* clear screen */
+#define KEY_EOS          (KEY_OFFSET + 0x4e) /* clear to end of screen */
+#define KEY_EOL          (KEY_OFFSET + 0x4f) /* clear to end of line */
+#define KEY_SF           (KEY_OFFSET + 0x50) /* scroll 1 line forward */
+#define KEY_SR           (KEY_OFFSET + 0x51) /* scroll 1 line back (reverse) */
+#define KEY_NPAGE        (KEY_OFFSET + 0x52) /* next page */
+#define KEY_PPAGE        (KEY_OFFSET + 0x53) /* previous page */
+#define KEY_STAB         (KEY_OFFSET + 0x54) /* set tab */
+#define KEY_CTAB         (KEY_OFFSET + 0x55) /* clear tab */
+#define KEY_CATAB        (KEY_OFFSET + 0x56) /* clear all tabs */
+#define KEY_ENTER        (KEY_OFFSET + 0x57) /* enter or send (unreliable) */
+#define KEY_SRESET       (KEY_OFFSET + 0x58) /* soft/reset (partial/unreliable) */
+#define KEY_RESET        (KEY_OFFSET + 0x59) /* reset/hard reset (unreliable) */
+#define KEY_PRINT        (KEY_OFFSET + 0x5a) /* print/copy */
+#define KEY_LL           (KEY_OFFSET + 0x5b) /* home down/bottom (lower left) */
+#define KEY_ABORT        (KEY_OFFSET + 0x5c) /* abort/terminate key (any) */
+#define KEY_SHELP        (KEY_OFFSET + 0x5d) /* short help */
+#define KEY_LHELP        (KEY_OFFSET + 0x5e) /* long help */
+#define KEY_BTAB         (KEY_OFFSET + 0x5f) /* Back tab key */
+#define KEY_BEG          (KEY_OFFSET + 0x60) /* beg(inning) key */
+#define KEY_CANCEL       (KEY_OFFSET + 0x61) /* cancel key */
+#define KEY_CLOSE        (KEY_OFFSET + 0x62) /* close key */
+#define KEY_COMMAND      (KEY_OFFSET + 0x63) /* cmd (command) key */
+#define KEY_COPY         (KEY_OFFSET + 0x64) /* copy key */
+#define KEY_CREATE       (KEY_OFFSET + 0x65) /* create key */
+#define KEY_END          (KEY_OFFSET + 0x66) /* end key */
+#define KEY_EXIT         (KEY_OFFSET + 0x67) /* exit key */
+#define KEY_FIND         (KEY_OFFSET + 0x68) /* find key */
+#define KEY_HELP         (KEY_OFFSET + 0x69) /* help key */
+#define KEY_MARK         (KEY_OFFSET + 0x6a) /* mark key */
+#define KEY_MESSAGE      (KEY_OFFSET + 0x6b) /* message key */
+#define KEY_MOVE         (KEY_OFFSET + 0x6c) /* move key */
+#define KEY_NEXT         (KEY_OFFSET + 0x6d) /* next object key */
+#define KEY_OPEN         (KEY_OFFSET + 0x6e) /* open key */
+#define KEY_OPTIONS      (KEY_OFFSET + 0x6f) /* options key */
+#define KEY_PREVIOUS     (KEY_OFFSET + 0x70) /* previous object key */
+#define KEY_REDO         (KEY_OFFSET + 0x71) /* redo key */
+#define KEY_REFERENCE    (KEY_OFFSET + 0x72) /* ref(erence) key */
+#define KEY_REFRESH      (KEY_OFFSET + 0x73) /* refresh key */
+#define KEY_REPLACE      (KEY_OFFSET + 0x74) /* replace key */
+#define KEY_RESTART      (KEY_OFFSET + 0x75) /* restart key */
+#define KEY_RESUME       (KEY_OFFSET + 0x76) /* resume key */
+#define KEY_SAVE         (KEY_OFFSET + 0x77) /* save key */
+#define KEY_SBEG         (KEY_OFFSET + 0x78) /* shifted beginning key */
+#define KEY_SCANCEL      (KEY_OFFSET + 0x79) /* shifted cancel key */
+#define KEY_SCOMMAND     (KEY_OFFSET + 0x7a) /* shifted command key */
+#define KEY_SCOPY        (KEY_OFFSET + 0x7b) /* shifted copy key */
+#define KEY_SCREATE      (KEY_OFFSET + 0x7c) /* shifted create key */
+#define KEY_SDC          (KEY_OFFSET + 0x7d) /* shifted delete char key */
+#define KEY_SDL          (KEY_OFFSET + 0x7e) /* shifted delete line key */
+#define KEY_SELECT       (KEY_OFFSET + 0x7f) /* select key */
+#define KEY_SEND         (KEY_OFFSET + 0x80) /* shifted end key */
+#define KEY_SEOL         (KEY_OFFSET + 0x81) /* shifted clear line key */
+#define KEY_SEXIT        (KEY_OFFSET + 0x82) /* shifted exit key */
+#define KEY_SFIND        (KEY_OFFSET + 0x83) /* shifted find key */
+#define KEY_SHOME        (KEY_OFFSET + 0x84) /* shifted home key */
+#define KEY_SIC          (KEY_OFFSET + 0x85) /* shifted input key */
+
+#define KEY_SLEFT        (KEY_OFFSET + 0x87) /* shifted left arrow key */
+#define KEY_SMESSAGE     (KEY_OFFSET + 0x88) /* shifted message key */
+#define KEY_SMOVE        (KEY_OFFSET + 0x89) /* shifted move key */
+#define KEY_SNEXT        (KEY_OFFSET + 0x8a) /* shifted next key */
+#define KEY_SOPTIONS     (KEY_OFFSET + 0x8b) /* shifted options key */
+#define KEY_SPREVIOUS    (KEY_OFFSET + 0x8c) /* shifted prev key */
+#define KEY_SPRINT       (KEY_OFFSET + 0x8d) /* shifted print key */
+#define KEY_SREDO        (KEY_OFFSET + 0x8e) /* shifted redo key */
+#define KEY_SREPLACE     (KEY_OFFSET + 0x8f) /* shifted replace key */
+#define KEY_SRIGHT       (KEY_OFFSET + 0x90) /* shifted right arrow */
+#define KEY_SRSUME       (KEY_OFFSET + 0x91) /* shifted resume key */
+#define KEY_SSAVE        (KEY_OFFSET + 0x92) /* shifted save key */
+#define KEY_SSUSPEND     (KEY_OFFSET + 0x93) /* shifted suspend key */
+#define KEY_SUNDO        (KEY_OFFSET + 0x94) /* shifted undo key */
+#define KEY_SUSPEND      (KEY_OFFSET + 0x95) /* suspend key */
+#define KEY_UNDO         (KEY_OFFSET + 0x96) /* undo key */
+
+/* PDCurses-specific key definitions -- PC only */
+
+#define ALT_0                 (KEY_OFFSET + 0x97)
+#define ALT_1                 (KEY_OFFSET + 0x98)
+#define ALT_2                 (KEY_OFFSET + 0x99)
+#define ALT_3                 (KEY_OFFSET + 0x9a)
+#define ALT_4                 (KEY_OFFSET + 0x9b)
+#define ALT_5                 (KEY_OFFSET + 0x9c)
+#define ALT_6                 (KEY_OFFSET + 0x9d)
+#define ALT_7                 (KEY_OFFSET + 0x9e)
+#define ALT_8                 (KEY_OFFSET + 0x9f)
+#define ALT_9                 (KEY_OFFSET + 0xa0)
+#define ALT_A                 (KEY_OFFSET + 0xa1)
+#define ALT_B                 (KEY_OFFSET + 0xa2)
+#define ALT_C                 (KEY_OFFSET + 0xa3)
+#define ALT_D                 (KEY_OFFSET + 0xa4)
+#define ALT_E                 (KEY_OFFSET + 0xa5)
+#define ALT_F                 (KEY_OFFSET + 0xa6)
+#define ALT_G                 (KEY_OFFSET + 0xa7)
+#define ALT_H                 (KEY_OFFSET + 0xa8)
+#define ALT_I                 (KEY_OFFSET + 0xa9)
+#define ALT_J                 (KEY_OFFSET + 0xaa)
+#define ALT_K                 (KEY_OFFSET + 0xab)
+#define ALT_L                 (KEY_OFFSET + 0xac)
+#define ALT_M                 (KEY_OFFSET + 0xad)
+#define ALT_N                 (KEY_OFFSET + 0xae)
+#define ALT_O                 (KEY_OFFSET + 0xaf)
+#define ALT_P                 (KEY_OFFSET + 0xb0)
+#define ALT_Q                 (KEY_OFFSET + 0xb1)
+#define ALT_R                 (KEY_OFFSET + 0xb2)
+#define ALT_S                 (KEY_OFFSET + 0xb3)
+#define ALT_T                 (KEY_OFFSET + 0xb4)
+#define ALT_U                 (KEY_OFFSET + 0xb5)
+#define ALT_V                 (KEY_OFFSET + 0xb6)
+#define ALT_W                 (KEY_OFFSET + 0xb7)
+#define ALT_X                 (KEY_OFFSET + 0xb8)
+#define ALT_Y                 (KEY_OFFSET + 0xb9)
+#define ALT_Z                 (KEY_OFFSET + 0xba)
+
+#define CTL_LEFT              (KEY_OFFSET + 0xbb) /* Control-Left-Arrow */
+#define CTL_RIGHT             (KEY_OFFSET + 0xbc)
+#define CTL_PGUP              (KEY_OFFSET + 0xbd)
+#define CTL_PGDN              (KEY_OFFSET + 0xbe)
+#define CTL_HOME              (KEY_OFFSET + 0xbf)
+#define CTL_END               (KEY_OFFSET + 0xc0)
+
+#define KEY_A1                (KEY_OFFSET + 0xc1) /* upper left on Virtual keypad */
+#define KEY_A2                (KEY_OFFSET + 0xc2) /* upper middle on Virt. keypad */
+#define KEY_A3                (KEY_OFFSET + 0xc3) /* upper right on Vir. keypad */
+#define KEY_B1                (KEY_OFFSET + 0xc4) /* middle left on Virt. keypad */
+#define KEY_B2                (KEY_OFFSET + 0xc5) /* center on Virt. keypad */
+#define KEY_B3                (KEY_OFFSET + 0xc6) /* middle right on Vir. keypad */
+#define KEY_C1                (KEY_OFFSET + 0xc7) /* lower left on Virt. keypad */
+#define KEY_C2                (KEY_OFFSET + 0xc8) /* lower middle on Virt. keypad */
+#define KEY_C3                (KEY_OFFSET + 0xc9) /* lower right on Vir. keypad */
+
+#define PADSLASH              (KEY_OFFSET + 0xca) /* slash on keypad */
+#define PADENTER              (KEY_OFFSET + 0xcb) /* enter on keypad */
+#define CTL_PADENTER          (KEY_OFFSET + 0xcc) /* ctl-enter on keypad */
+#define ALT_PADENTER          (KEY_OFFSET + 0xcd) /* alt-enter on keypad */
+#define PADSTOP               (KEY_OFFSET + 0xce) /* stop on keypad */
+#define PADSTAR               (KEY_OFFSET + 0xcf) /* star on keypad */
+#define PADMINUS              (KEY_OFFSET + 0xd0) /* minus on keypad */
+#define PADPLUS               (KEY_OFFSET + 0xd1) /* plus on keypad */
+#define CTL_PADSTOP           (KEY_OFFSET + 0xd2) /* ctl-stop on keypad */
+#define CTL_PADCENTER         (KEY_OFFSET + 0xd3) /* ctl-enter on keypad */
+#define CTL_PADPLUS           (KEY_OFFSET + 0xd4) /* ctl-plus on keypad */
+#define CTL_PADMINUS          (KEY_OFFSET + 0xd5) /* ctl-minus on keypad */
+#define CTL_PADSLASH          (KEY_OFFSET + 0xd6) /* ctl-slash on keypad */
+#define CTL_PADSTAR           (KEY_OFFSET + 0xd7) /* ctl-star on keypad */
+#define ALT_PADPLUS           (KEY_OFFSET + 0xd8) /* alt-plus on keypad */
+#define ALT_PADMINUS          (KEY_OFFSET + 0xd9) /* alt-minus on keypad */
+#define ALT_PADSLASH          (KEY_OFFSET + 0xda) /* alt-slash on keypad */
+#define ALT_PADSTAR           (KEY_OFFSET + 0xdb) /* alt-star on keypad */
+#define ALT_PADSTOP           (KEY_OFFSET + 0xdc) /* alt-stop on keypad */
+#define CTL_INS               (KEY_OFFSET + 0xdd) /* ctl-insert */
+#define ALT_DEL               (KEY_OFFSET + 0xde) /* alt-delete */
+#define ALT_INS               (KEY_OFFSET + 0xdf) /* alt-insert */
+#define CTL_UP                (KEY_OFFSET + 0xe0) /* ctl-up arrow */
+#define CTL_DOWN              (KEY_OFFSET + 0xe1) /* ctl-down arrow */
+#define CTL_TAB               (KEY_OFFSET + 0xe2) /* ctl-tab */
+#define ALT_TAB               (KEY_OFFSET + 0xe3)
+#define ALT_MINUS             (KEY_OFFSET + 0xe4)
+#define ALT_EQUAL             (KEY_OFFSET + 0xe5)
+#define ALT_HOME              (KEY_OFFSET + 0xe6)
+#define ALT_PGUP              (KEY_OFFSET + 0xe7)
+#define ALT_PGDN              (KEY_OFFSET + 0xe8)
+#define ALT_END               (KEY_OFFSET + 0xe9)
+#define ALT_UP                (KEY_OFFSET + 0xea) /* alt-up arrow */
+#define ALT_DOWN              (KEY_OFFSET + 0xeb) /* alt-down arrow */
+#define ALT_RIGHT             (KEY_OFFSET + 0xec) /* alt-right arrow */
+#define ALT_LEFT              (KEY_OFFSET + 0xed) /* alt-left arrow */
+#define ALT_ENTER             (KEY_OFFSET + 0xee) /* alt-enter */
+#define ALT_ESC               (KEY_OFFSET + 0xef) /* alt-escape */
+#define ALT_BQUOTE            (KEY_OFFSET + 0xf0) /* alt-back quote */
+#define ALT_LBRACKET          (KEY_OFFSET + 0xf1) /* alt-left bracket */
+#define ALT_RBRACKET          (KEY_OFFSET + 0xf2) /* alt-right bracket */
+#define ALT_SEMICOLON         (KEY_OFFSET + 0xf3) /* alt-semi-colon */
+#define ALT_FQUOTE            (KEY_OFFSET + 0xf4) /* alt-forward quote */
+#define ALT_COMMA             (KEY_OFFSET + 0xf5) /* alt-comma */
+#define ALT_STOP              (KEY_OFFSET + 0xf6) /* alt-stop */
+#define ALT_FSLASH            (KEY_OFFSET + 0xf7) /* alt-forward slash */
+#define ALT_BKSP              (KEY_OFFSET + 0xf8) /* alt-backspace */
+#define CTL_BKSP              (KEY_OFFSET + 0xf9) /* ctl-backspace */
+#define PAD0                  (KEY_OFFSET + 0xfa) /* keypad 0 */
+
+#define CTL_PAD0              (KEY_OFFSET + 0xfb) /* ctl-keypad 0 */
+#define CTL_PAD1              (KEY_OFFSET + 0xfc)
+#define CTL_PAD2              (KEY_OFFSET + 0xfd)
+#define CTL_PAD3              (KEY_OFFSET + 0xfe)
+#define CTL_PAD4              (KEY_OFFSET + 0xff)
+#define CTL_PAD5              (KEY_OFFSET + 0x100)
+#define CTL_PAD6              (KEY_OFFSET + 0x101)
+#define CTL_PAD7              (KEY_OFFSET + 0x102)
+#define CTL_PAD8              (KEY_OFFSET + 0x103)
+#define CTL_PAD9              (KEY_OFFSET + 0x104)
+
+#define ALT_PAD0              (KEY_OFFSET + 0x105) /* alt-keypad 0 */
+#define ALT_PAD1              (KEY_OFFSET + 0x106)
+#define ALT_PAD2              (KEY_OFFSET + 0x107)
+#define ALT_PAD3              (KEY_OFFSET + 0x108)
+#define ALT_PAD4              (KEY_OFFSET + 0x109)
+#define ALT_PAD5              (KEY_OFFSET + 0x10a)
+#define ALT_PAD6              (KEY_OFFSET + 0x10b)
+#define ALT_PAD7              (KEY_OFFSET + 0x10c)
+#define ALT_PAD8              (KEY_OFFSET + 0x10d)
+#define ALT_PAD9              (KEY_OFFSET + 0x10e)
+
+#define CTL_DEL               (KEY_OFFSET + 0x10f) /* clt-delete */
+#define ALT_BSLASH            (KEY_OFFSET + 0x110) /* alt-back slash */
+#define CTL_ENTER             (KEY_OFFSET + 0x111) /* ctl-enter */
+
+#define SHF_PADENTER          (KEY_OFFSET + 0x112) /* shift-enter on keypad */
+#define SHF_PADSLASH          (KEY_OFFSET + 0x113) /* shift-slash on keypad */
+#define SHF_PADSTAR           (KEY_OFFSET + 0x114) /* shift-star  on keypad */
+#define SHF_PADPLUS           (KEY_OFFSET + 0x115) /* shift-plus  on keypad */
+#define SHF_PADMINUS          (KEY_OFFSET + 0x116) /* shift-minus on keypad */
+#define SHF_UP                (KEY_OFFSET + 0x117) /* shift-up on keypad */
+#define SHF_DOWN              (KEY_OFFSET + 0x118) /* shift-down on keypad */
+#define SHF_IC                (KEY_OFFSET + 0x119) /* shift-insert on keypad */
+#define SHF_DC                (KEY_OFFSET + 0x11a) /* shift-delete on keypad */
+
+#define KEY_MOUSE             (KEY_OFFSET + 0x11b) /* "mouse" key */
+#define KEY_SHIFT_L           (KEY_OFFSET + 0x11c) /* Left-shift */
+#define KEY_SHIFT_R           (KEY_OFFSET + 0x11d) /* Right-shift */
+#define KEY_CONTROL_L         (KEY_OFFSET + 0x11e) /* Left-control */
+#define KEY_CONTROL_R         (KEY_OFFSET + 0x11f) /* Right-control */
+#define KEY_ALT_L             (KEY_OFFSET + 0x120) /* Left-alt */
+#define KEY_ALT_R             (KEY_OFFSET + 0x121) /* Right-alt */
+#define KEY_RESIZE            (KEY_OFFSET + 0x122) /* Window resize */
+#define KEY_SUP               (KEY_OFFSET + 0x123) /* Shifted up arrow */
+#define KEY_SDOWN             (KEY_OFFSET + 0x124) /* Shifted down arrow */
+
+         /* The following are not returned on most PDCurses platforms. */
+
+#define KEY_APPS              (KEY_OFFSET + 0x125)
+
+#define KEY_PAUSE             (KEY_OFFSET + 0x126)
+
+#define KEY_PRINTSCREEN       (KEY_OFFSET + 0x127)
+#define KEY_SCROLLLOCK        (KEY_OFFSET + 0x128)
+
+#define KEY_BROWSER_BACK      (KEY_OFFSET + 0x129)
+#define KEY_BROWSER_FWD       (KEY_OFFSET + 0x12a)
+#define KEY_BROWSER_REF       (KEY_OFFSET + 0x12b)
+#define KEY_BROWSER_STOP      (KEY_OFFSET + 0x12c)
+#define KEY_SEARCH            (KEY_OFFSET + 0x12d)
+#define KEY_FAVORITES         (KEY_OFFSET + 0x12e)
+#define KEY_BROWSER_HOME      (KEY_OFFSET + 0x12f)
+#define KEY_VOLUME_MUTE       (KEY_OFFSET + 0x130)
+#define KEY_VOLUME_DOWN       (KEY_OFFSET + 0x131)
+#define KEY_VOLUME_UP         (KEY_OFFSET + 0x132)
+#define KEY_NEXT_TRACK        (KEY_OFFSET + 0x133)
+#define KEY_PREV_TRACK        (KEY_OFFSET + 0x134)
+#define KEY_MEDIA_STOP        (KEY_OFFSET + 0x135)
+#define KEY_PLAY_PAUSE        (KEY_OFFSET + 0x136)
+#define KEY_LAUNCH_MAIL       (KEY_OFFSET + 0x137)
+#define KEY_MEDIA_SELECT      (KEY_OFFSET + 0x138)
+#define KEY_LAUNCH_APP1       (KEY_OFFSET + 0x139)
+#define KEY_LAUNCH_APP2       (KEY_OFFSET + 0x13a)
+#define KEY_LAUNCH_APP3       (KEY_OFFSET + 0x13b)
+#define KEY_LAUNCH_APP4       (KEY_OFFSET + 0x13c)
+#define KEY_LAUNCH_APP5       (KEY_OFFSET + 0x13d)
+#define KEY_LAUNCH_APP6       (KEY_OFFSET + 0x13e)
+#define KEY_LAUNCH_APP7       (KEY_OFFSET + 0x13f)
+#define KEY_LAUNCH_APP8       (KEY_OFFSET + 0x140)
+#define KEY_LAUNCH_APP9       (KEY_OFFSET + 0x141)
+#define KEY_LAUNCH_APP10      (KEY_OFFSET + 0x142)
+
+#define KEY_MIN       KEY_BREAK         /* Minimum curses key value */
+#define KEY_MAX       KEY_LAUNCH_APP10  /* Maximum curses key */
+
+#define KEY_F(n)      (KEY_F0 + (n))
+
+/*----------------------------------------------------------------------
+ *
+ *  PDCurses Function Declarations
+ *
+ */
+
+/* Standard */
+
+PDCEX  int     addch(const chtype);
+PDCEX  int     addchnstr(const chtype *, int);
+PDCEX  int     addchstr(const chtype *);
+PDCEX  int     addnstr(const char *, int);
+PDCEX  int     addstr(const char *);
+PDCEX  int     attroff(chtype);
+PDCEX  int     attron(chtype);
+PDCEX  int     attrset(chtype);
+PDCEX  int     attr_get(attr_t *, short *, void *);
+PDCEX  int     attr_off(attr_t, void *);
+PDCEX  int     attr_on(attr_t, void *);
+PDCEX  int     attr_set(attr_t, short, void *);
+PDCEX  int     baudrate(void);
+PDCEX  int     beep(void);
+PDCEX  int     bkgd(chtype);
+PDCEX  void    bkgdset(chtype);
+PDCEX  int     border(chtype, chtype, chtype, chtype,
+                      chtype, chtype, chtype, chtype);
+PDCEX  int     box(WINDOW *, chtype, chtype);
+PDCEX  bool    can_change_color(void);
+PDCEX  int     cbreak(void);
+PDCEX  int     chgat(int, attr_t, short, const void *);
+PDCEX  int     clearok(WINDOW *, bool);
+PDCEX  int     clear(void);
+PDCEX  int     clrtobot(void);
+PDCEX  int     clrtoeol(void);
+PDCEX  int     color_content(short, short *, short *, short *);
+PDCEX  int     color_set(short, void *);
+PDCEX  int     copywin(const WINDOW *, WINDOW *, int, int, int,
+                       int, int, int, int);
+PDCEX  int     curs_set(int);
+PDCEX  int     def_prog_mode(void);
+PDCEX  int     def_shell_mode(void);
+PDCEX  int     delay_output(int);
+PDCEX  int     delch(void);
+PDCEX  int     deleteln(void);
+PDCEX  void    delscreen(SCREEN *);
+PDCEX  int     delwin(WINDOW *);
+PDCEX  WINDOW *derwin(WINDOW *, int, int, int, int);
+PDCEX  int     doupdate(void);
+PDCEX  WINDOW *dupwin(WINDOW *);
+PDCEX  int     echochar(const chtype);
+PDCEX  int     echo(void);
+PDCEX  int     endwin(void);
+PDCEX  char    erasechar(void);
+PDCEX  int     erase(void);
+PDCEX  int     extended_color_content(int, int *, int *, int *);
+PDCEX  int     extended_pair_content(int, int *, int *);
+PDCEX  void    filter(void);
+PDCEX  int     flash(void);
+PDCEX  int     flushinp(void);
+PDCEX  chtype  getbkgd(WINDOW *);
+PDCEX  int     getnstr(char *, int);
+PDCEX  int     getstr(char *);
+PDCEX  WINDOW *getwin(FILE *);
+PDCEX  int     halfdelay(int);
+PDCEX  bool    has_colors(void);
+PDCEX  bool    has_ic(void);
+PDCEX  bool    has_il(void);
+PDCEX  int     hline(chtype, int);
+PDCEX  void    idcok(WINDOW *, bool);
+PDCEX  int     idlok(WINDOW *, bool);
+PDCEX  void    immedok(WINDOW *, bool);
+PDCEX  int     inchnstr(chtype *, int);
+PDCEX  int     inchstr(chtype *);
+PDCEX  chtype  inch(void);
+PDCEX  int     init_color(short, short, short, short);
+PDCEX  int     init_extended_color(int, int, int, int);
+PDCEX  int     init_extended_pair(int, int, int);
+PDCEX  int     init_pair(short, short, short);
+
+#ifdef PDC_WIDE
+   #ifdef PDC_FORCE_UTF8
+      #ifdef CHTYPE_32
+         #define initscr initscr_u32
+      #else
+         #define initscr initscr_u64
+      #endif
+   #else
+      #ifdef CHTYPE_32
+         #define initscr initscr_w32
+      #else
+         #define initscr initscr_w64
+      #endif
+   #endif
+#else       /* 8-bit chtypes */
+   #ifdef CHTYPE_32
+      #define initscr initscr_x32
+   #else
+      #define initscr initscr_x64
+   #endif
+#endif
+
+PDCEX  WINDOW *initscr(void);
+PDCEX  int     innstr(char *, int);
+PDCEX  int     insch(chtype);
+PDCEX  int     insdelln(int);
+PDCEX  int     insertln(void);
+PDCEX  int     insnstr(const char *, int);
+PDCEX  int     insstr(const char *);
+PDCEX  int     instr(char *);
+PDCEX  int     intrflush(WINDOW *, bool);
+PDCEX  bool    isendwin(void);
+PDCEX  bool    is_linetouched(WINDOW *, int);
+PDCEX  bool    is_wintouched(WINDOW *);
+PDCEX  char   *keyname(int);
+PDCEX  int     keypad(WINDOW *, bool);
+PDCEX  char    killchar(void);
+PDCEX  int     leaveok(WINDOW *, bool);
+PDCEX  char   *longname(void);
+PDCEX  int     meta(WINDOW *, bool);
+PDCEX  int     move(int, int);
+PDCEX  int     mvaddch(int, int, const chtype);
+PDCEX  int     mvaddchnstr(int, int, const chtype *, int);
+PDCEX  int     mvaddchstr(int, int, const chtype *);
+PDCEX  int     mvaddnstr(int, int, const char *, int);
+PDCEX  int     mvaddstr(int, int, const char *);
+PDCEX  int     mvchgat(int, int, int, attr_t, short, const void *);
+PDCEX  int     mvcur(int, int, int, int);
+PDCEX  int     mvdelch(int, int);
+PDCEX  int     mvderwin(WINDOW *, int, int);
+PDCEX  int     mvgetch(int, int);
+PDCEX  int     mvgetnstr(int, int, char *, int);
+PDCEX  int     mvgetstr(int, int, char *);
+PDCEX  int     mvhline(int, int, chtype, int);
+PDCEX  chtype  mvinch(int, int);
+PDCEX  int     mvinchnstr(int, int, chtype *, int);
+PDCEX  int     mvinchstr(int, int, chtype *);
+PDCEX  int     mvinnstr(int, int, char *, int);
+PDCEX  int     mvinsch(int, int, chtype);
+PDCEX  int     mvinsnstr(int, int, const char *, int);
+PDCEX  int     mvinsstr(int, int, const char *);
+PDCEX  int     mvinstr(int, int, char *);
+PDCEX  int     mvprintw(int, int, const char *, ...);
+PDCEX  int     mvscanw(int, int, const char *, ...);
+PDCEX  int     mvvline(int, int, chtype, int);
+PDCEX  int     mvwaddchnstr(WINDOW *, int, int, const chtype *, int);
+PDCEX  int     mvwaddchstr(WINDOW *, int, int, const chtype *);
+PDCEX  int     mvwaddch(WINDOW *, int, int, const chtype);
+PDCEX  int     mvwaddnstr(WINDOW *, int, int, const char *, int);
+PDCEX  int     mvwaddstr(WINDOW *, int, int, const char *);
+PDCEX  int     mvwchgat(WINDOW *, int, int, int, attr_t, short, const void *);
+PDCEX  int     mvwdelch(WINDOW *, int, int);
+PDCEX  int     mvwgetch(WINDOW *, int, int);
+PDCEX  int     mvwgetnstr(WINDOW *, int, int, char *, int);
+PDCEX  int     mvwgetstr(WINDOW *, int, int, char *);
+PDCEX  int     mvwhline(WINDOW *, int, int, chtype, int);
+PDCEX  int     mvwinchnstr(WINDOW *, int, int, chtype *, int);
+PDCEX  int     mvwinchstr(WINDOW *, int, int, chtype *);
+PDCEX  chtype  mvwinch(WINDOW *, int, int);
+PDCEX  int     mvwinnstr(WINDOW *, int, int, char *, int);
+PDCEX  int     mvwinsch(WINDOW *, int, int, chtype);
+PDCEX  int     mvwinsnstr(WINDOW *, int, int, const char *, int);
+PDCEX  int     mvwinsstr(WINDOW *, int, int, const char *);
+PDCEX  int     mvwinstr(WINDOW *, int, int, char *);
+PDCEX  int     mvwin(WINDOW *, int, int);
+PDCEX  int     mvwprintw(WINDOW *, int, int, const char *, ...);
+PDCEX  int     mvwscanw(WINDOW *, int, int, const char *, ...);
+PDCEX  int     mvwvline(WINDOW *, int, int, chtype, int);
+PDCEX  int     napms(int);
+PDCEX  WINDOW *newpad(int, int);
+PDCEX  SCREEN *newterm(const char *, FILE *, FILE *);
+PDCEX  WINDOW *newwin(int, int, int, int);
+PDCEX  int     nl(void);
+PDCEX  int     nocbreak(void);
+PDCEX  int     nodelay(WINDOW *, bool);
+PDCEX  int     noecho(void);
+PDCEX  int     nonl(void);
+PDCEX  void    noqiflush(void);
+PDCEX  int     noraw(void);
+PDCEX  int     notimeout(WINDOW *, bool);
+PDCEX  int     overlay(const WINDOW *, WINDOW *);
+PDCEX  int     overwrite(const WINDOW *, WINDOW *);
+PDCEX  int     pair_content(short, short *, short *);
+PDCEX  int     pechochar(WINDOW *, chtype);
+PDCEX  int     pnoutrefresh(WINDOW *, int, int, int, int, int, int);
+PDCEX  int     prefresh(WINDOW *, int, int, int, int, int, int);
+PDCEX  int     printw(const char *, ...);
+PDCEX  int     putwin(WINDOW *, FILE *);
+PDCEX  void    qiflush(void);
+PDCEX  int     raw(void);
+PDCEX  int     redrawwin(WINDOW *);
+PDCEX  int     refresh(void);
+PDCEX  int     reset_prog_mode(void);
+PDCEX  int     reset_shell_mode(void);
+PDCEX  int     resetty(void);
+PDCEX  int     ripoffline(int, int (*)(WINDOW *, int));
+PDCEX  int     savetty(void);
+PDCEX  int     scanw(const char *, ...);
+PDCEX  int     scr_dump(const char *);
+PDCEX  int     scr_init(const char *);
+PDCEX  int     scr_restore(const char *);
+PDCEX  int     scr_set(const char *);
+PDCEX  int     scrl(int);
+PDCEX  int     scroll(WINDOW *);
+PDCEX  int     scrollok(WINDOW *, bool);
+PDCEX  SCREEN *set_term(SCREEN *);
+PDCEX  int     setscrreg(int, int);
+PDCEX  int     slk_attroff(const chtype);
+PDCEX  int     slk_attr_off(const attr_t, void *);
+PDCEX  int     slk_attron(const chtype);
+PDCEX  int     slk_attr_on(const attr_t, void *);
+PDCEX  int     slk_attrset(const chtype);
+PDCEX  int     slk_attr_set(const attr_t, short, void *);
+PDCEX  int     slk_clear(void);
+PDCEX  int     slk_color(short);
+PDCEX  int     slk_init(int);
+PDCEX  char   *slk_label(int);
+PDCEX  int     slk_noutrefresh(void);
+PDCEX  int     slk_refresh(void);
+PDCEX  int     slk_restore(void);
+PDCEX  int     slk_set(int, const char *, int);
+PDCEX  int     slk_touch(void);
+PDCEX  int     standend(void);
+PDCEX  int     standout(void);
+PDCEX  int     start_color(void);
+PDCEX  WINDOW *subpad(WINDOW *, int, int, int, int);
+PDCEX  WINDOW *subwin(WINDOW *, int, int, int, int);
+PDCEX  int     syncok(WINDOW *, bool);
+PDCEX  chtype  termattrs(void);
+PDCEX  attr_t  term_attrs(void);
+PDCEX  char   *termname(void);
+PDCEX  void    timeout(int);
+PDCEX  int     touchline(WINDOW *, int, int);
+PDCEX  int     touchwin(WINDOW *);
+PDCEX  int     typeahead(int);
+PDCEX  int     untouchwin(WINDOW *);
+PDCEX  void    use_env(bool);
+PDCEX  int     vidattr(chtype);
+PDCEX  int     vid_attr(attr_t, short, void *);
+PDCEX  int     vidputs(chtype, int (*)(int));
+PDCEX  int     vid_puts(attr_t, short, void *, int (*)(int));
+PDCEX  int     vline(chtype, int);
+PDCEX  int     vw_printw(WINDOW *, const char *, va_list);
+PDCEX  int     vwprintw(WINDOW *, const char *, va_list);
+PDCEX  int     vw_scanw(WINDOW *, const char *, va_list);
+PDCEX  int     vwscanw(WINDOW *, const char *, va_list);
+PDCEX  int     waddchnstr(WINDOW *, const chtype *, int);
+PDCEX  int     waddchstr(WINDOW *, const chtype *);
+PDCEX  int     waddch(WINDOW *, const chtype);
+PDCEX  int     waddnstr(WINDOW *, const char *, int);
+PDCEX  int     waddstr(WINDOW *, const char *);
+PDCEX  int     wattroff(WINDOW *, chtype);
+PDCEX  int     wattron(WINDOW *, chtype);
+PDCEX  int     wattrset(WINDOW *, chtype);
+PDCEX  int     wattr_get(WINDOW *, attr_t *, short *, void *);
+PDCEX  int     wattr_off(WINDOW *, attr_t, void *);
+PDCEX  int     wattr_on(WINDOW *, attr_t, void *);
+PDCEX  int     wattr_set(WINDOW *, attr_t, short, void *);
+PDCEX  void    wbkgdset(WINDOW *, chtype);
+PDCEX  int     wbkgd(WINDOW *, chtype);
+PDCEX  int     wborder(WINDOW *, chtype, chtype, chtype, chtype,
+                        chtype, chtype, chtype, chtype);
+PDCEX  int     wchgat(WINDOW *, int, attr_t, short, const void *);
+PDCEX  int     wclear(WINDOW *);
+PDCEX  int     wclrtobot(WINDOW *);
+PDCEX  int     wclrtoeol(WINDOW *);
+PDCEX  int     wcolor_set(WINDOW *, short, void *);
+PDCEX  void    wcursyncup(WINDOW *);
+PDCEX  int     wdelch(WINDOW *);
+PDCEX  int     wdeleteln(WINDOW *);
+PDCEX  int     wechochar(WINDOW *, const chtype);
+PDCEX  int     werase(WINDOW *);
+PDCEX  int     wgetch(WINDOW *);
+PDCEX  int     wgetnstr(WINDOW *, char *, int);
+PDCEX  int     wgetstr(WINDOW *, char *);
+PDCEX  int     whline(WINDOW *, chtype, int);
+PDCEX  int     winchnstr(WINDOW *, chtype *, int);
+PDCEX  int     winchstr(WINDOW *, chtype *);
+PDCEX  chtype  winch(WINDOW *);
+PDCEX  int     winnstr(WINDOW *, char *, int);
+PDCEX  int     winsch(WINDOW *, chtype);
+PDCEX  int     winsdelln(WINDOW *, int);
+PDCEX  int     winsertln(WINDOW *);
+PDCEX  int     winsnstr(WINDOW *, const char *, int);
+PDCEX  int     winsstr(WINDOW *, const char *);
+PDCEX  int     winstr(WINDOW *, char *);
+PDCEX  int     wmove(WINDOW *, int, int);
+PDCEX  int     wnoutrefresh(WINDOW *);
+PDCEX  int     wprintw(WINDOW *, const char *, ...);
+PDCEX  int     wredrawln(WINDOW *, int, int);
+PDCEX  int     wrefresh(WINDOW *);
+PDCEX  int     wscanw(WINDOW *, const char *, ...);
+PDCEX  int     wscrl(WINDOW *, int);
+PDCEX  int     wsetscrreg(WINDOW *, int, int);
+PDCEX  int     wstandend(WINDOW *);
+PDCEX  int     wstandout(WINDOW *);
+PDCEX  void    wsyncdown(WINDOW *);
+PDCEX  void    wsyncup(WINDOW *);
+PDCEX  void    wtimeout(WINDOW *, int);
+PDCEX  int     wtouchln(WINDOW *, int, int, int);
+PDCEX  int     wvline(WINDOW *, chtype, int);
+
+/* Wide-character functions */
+
+#ifdef PDC_WIDE
+PDCEX  int     addnwstr(const wchar_t *, int);
+PDCEX  int     addwstr(const wchar_t *);
+PDCEX  int     add_wch(const cchar_t *);
+PDCEX  int     add_wchnstr(const cchar_t *, int);
+PDCEX  int     add_wchstr(const cchar_t *);
+PDCEX  int     bkgrnd(const cchar_t *);
+PDCEX  void    bkgrndset(const cchar_t *);
+PDCEX  int     border_set(const cchar_t *, const cchar_t *, const cchar_t *,
+                          const cchar_t *, const cchar_t *, const cchar_t *,
+                          const cchar_t *, const cchar_t *);
+PDCEX  int     box_set(WINDOW *, const cchar_t *, const cchar_t *);
+PDCEX  int     echo_wchar(const cchar_t *);
+PDCEX  int     erasewchar(wchar_t *);
+PDCEX  int     getbkgrnd(cchar_t *);
+PDCEX  int     getcchar(const cchar_t *, wchar_t *, attr_t *, short *, void *);
+PDCEX  int     getn_wstr(wint_t *, int);
+PDCEX  int     get_wch(wint_t *);
+PDCEX  int     get_wstr(wint_t *);
+PDCEX  int     hline_set(const cchar_t *, int);
+PDCEX  int     innwstr(wchar_t *, int);
+PDCEX  int     ins_nwstr(const wchar_t *, int);
+PDCEX  int     ins_wch(const cchar_t *);
+PDCEX  int     ins_wstr(const wchar_t *);
+PDCEX  int     inwstr(wchar_t *);
+PDCEX  int     in_wch(cchar_t *);
+PDCEX  int     in_wchnstr(cchar_t *, int);
+PDCEX  int     in_wchstr(cchar_t *);
+PDCEX  char   *key_name(wchar_t);
+PDCEX  int     killwchar(wchar_t *);
+PDCEX  int     mvaddnwstr(int, int, const wchar_t *, int);
+PDCEX  int     mvaddwstr(int, int, const wchar_t *);
+PDCEX  int     mvadd_wch(int, int, const cchar_t *);
+PDCEX  int     mvadd_wchnstr(int, int, const cchar_t *, int);
+PDCEX  int     mvadd_wchstr(int, int, const cchar_t *);
+PDCEX  int     mvgetn_wstr(int, int, wint_t *, int);
+PDCEX  int     mvget_wch(int, int, wint_t *);
+PDCEX  int     mvget_wstr(int, int, wint_t *);
+PDCEX  int     mvhline_set(int, int, const cchar_t *, int);
+PDCEX  int     mvinnwstr(int, int, wchar_t *, int);
+PDCEX  int     mvins_nwstr(int, int, const wchar_t *, int);
+PDCEX  int     mvins_wch(int, int, const cchar_t *);
+PDCEX  int     mvins_wstr(int, int, const wchar_t *);
+PDCEX  int     mvinwstr(int, int, wchar_t *);
+PDCEX  int     mvin_wch(int, int, cchar_t *);
+PDCEX  int     mvin_wchnstr(int, int, cchar_t *, int);
+PDCEX  int     mvin_wchstr(int, int, cchar_t *);
+PDCEX  int     mvvline_set(int, int, const cchar_t *, int);
+PDCEX  int     mvwaddnwstr(WINDOW *, int, int, const wchar_t *, int);
+PDCEX  int     mvwaddwstr(WINDOW *, int, int, const wchar_t *);
+PDCEX  int     mvwadd_wch(WINDOW *, int, int, const cchar_t *);
+PDCEX  int     mvwadd_wchnstr(WINDOW *, int, int, const cchar_t *, int);
+PDCEX  int     mvwadd_wchstr(WINDOW *, int, int, const cchar_t *);
+PDCEX  int     mvwgetn_wstr(WINDOW *, int, int, wint_t *, int);
+PDCEX  int     mvwget_wch(WINDOW *, int, int, wint_t *);
+PDCEX  int     mvwget_wstr(WINDOW *, int, int, wint_t *);
+PDCEX  int     mvwhline_set(WINDOW *, int, int, const cchar_t *, int);
+PDCEX  int     mvwinnwstr(WINDOW *, int, int, wchar_t *, int);
+PDCEX  int     mvwins_nwstr(WINDOW *, int, int, const wchar_t *, int);
+PDCEX  int     mvwins_wch(WINDOW *, int, int, const cchar_t *);
+PDCEX  int     mvwins_wstr(WINDOW *, int, int, const wchar_t *);
+PDCEX  int     mvwin_wch(WINDOW *, int, int, cchar_t *);
+PDCEX  int     mvwin_wchnstr(WINDOW *, int, int, cchar_t *, int);
+PDCEX  int     mvwin_wchstr(WINDOW *, int, int, cchar_t *);
+PDCEX  int     mvwinwstr(WINDOW *, int, int, wchar_t *);
+PDCEX  int     mvwvline_set(WINDOW *, int, int, const cchar_t *, int);
+PDCEX  int     pecho_wchar(WINDOW *, const cchar_t*);
+PDCEX  int     setcchar(cchar_t*, const wchar_t*, const attr_t,
+                        short, const void*);
+PDCEX  int     slk_wset(int, const wchar_t *, int);
+PDCEX  int     unget_wch(const wchar_t);
+PDCEX  int     vline_set(const cchar_t *, int);
+PDCEX  int     waddnwstr(WINDOW *, const wchar_t *, int);
+PDCEX  int     waddwstr(WINDOW *, const wchar_t *);
+PDCEX  int     wadd_wch(WINDOW *, const cchar_t *);
+PDCEX  int     wadd_wchnstr(WINDOW *, const cchar_t *, int);
+PDCEX  int     wadd_wchstr(WINDOW *, const cchar_t *);
+PDCEX  int     wbkgrnd(WINDOW *, const cchar_t *);
+PDCEX  void    wbkgrndset(WINDOW *, const cchar_t *);
+PDCEX  int     wborder_set(WINDOW *, const cchar_t *, const cchar_t *,
+                           const cchar_t *, const cchar_t *, const cchar_t *,
+                           const cchar_t *, const cchar_t *, const cchar_t *);
+PDCEX  int     wecho_wchar(WINDOW *, const cchar_t *);
+PDCEX  int     wgetbkgrnd(WINDOW *, cchar_t *);
+PDCEX  int     wgetn_wstr(WINDOW *, wint_t *, int);
+PDCEX  int     wget_wch(WINDOW *, wint_t *);
+PDCEX  int     wget_wstr(WINDOW *, wint_t *);
+PDCEX  int     whline_set(WINDOW *, const cchar_t *, int);
+PDCEX  int     winnwstr(WINDOW *, wchar_t *, int);
+PDCEX  int     wins_nwstr(WINDOW *, const wchar_t *, int);
+PDCEX  int     wins_wch(WINDOW *, const cchar_t *);
+PDCEX  int     wins_wstr(WINDOW *, const wchar_t *);
+PDCEX  int     winwstr(WINDOW *, wchar_t *);
+PDCEX  int     win_wch(WINDOW *, cchar_t *);
+PDCEX  int     win_wchnstr(WINDOW *, cchar_t *, int);
+PDCEX  int     win_wchstr(WINDOW *, cchar_t *);
+PDCEX  wchar_t *wunctrl(cchar_t *);
+PDCEX  int     wvline_set(WINDOW *, const cchar_t *, int);
+#endif
+
+/* Quasi-standard */
+
+PDCEX  chtype  getattrs(WINDOW *);
+PDCEX  int     getbegx(WINDOW *);
+PDCEX  int     getbegy(WINDOW *);
+PDCEX  int     getmaxx(WINDOW *);
+PDCEX  int     getmaxy(WINDOW *);
+PDCEX  int     getparx(WINDOW *);
+PDCEX  int     getpary(WINDOW *);
+PDCEX  int     getcurx(WINDOW *);
+PDCEX  int     getcury(WINDOW *);
+PDCEX  void    traceoff(void);
+PDCEX  void    traceon(void);
+PDCEX  char   *unctrl(chtype);
+
+PDCEX  int     crmode(void);
+PDCEX  int     nocrmode(void);
+PDCEX  int     draino(int);
+PDCEX  int     resetterm(void);
+PDCEX  int     fixterm(void);
+PDCEX  int     saveterm(void);
+PDCEX  void    setsyx(int, int);
+
+PDCEX  int     mouse_set(mmask_t);
+PDCEX  int     mouse_on(mmask_t);
+PDCEX  int     mouse_off(mmask_t);
+PDCEX  int     request_mouse_pos(void);
+PDCEX  void    wmouse_position(WINDOW *, int *, int *);
+PDCEX  mmask_t getmouse(void);
+
+/* ncurses */
+
+PDCEX  int     assume_default_colors(int, int);
+PDCEX  const char *curses_version(void);
+PDCEX  bool    has_key(int);
+PDCEX  bool    is_keypad(const WINDOW *);
+PDCEX  bool    is_leaveok(const WINDOW *);
+PDCEX  bool    is_pad(const WINDOW *);
+PDCEX  int     set_tabsize(int);
+PDCEX  int     use_default_colors(void);
+PDCEX  int     wresize(WINDOW *, int, int);
+
+PDCEX  bool    has_mouse(void);
+PDCEX  int     mouseinterval(int);
+PDCEX  mmask_t mousemask(mmask_t, mmask_t *);
+PDCEX  bool    mouse_trafo(int *, int *, bool);
+PDCEX  int     nc_getmouse(MEVENT *);
+PDCEX  int     ungetmouse(MEVENT *);
+PDCEX  bool    wenclose(const WINDOW *, int, int);
+PDCEX  bool    wmouse_trafo(const WINDOW *, int *, int *, bool);
+
+/* PDCurses */
+
+PDCEX  int     addrawch(chtype);
+PDCEX  int     insrawch(chtype);
+PDCEX  bool    is_termresized(void);
+PDCEX  int     mvaddrawch(int, int, chtype);
+PDCEX  int     mvdeleteln(int, int);
+PDCEX  int     mvinsertln(int, int);
+PDCEX  int     mvinsrawch(int, int, chtype);
+PDCEX  int     mvwaddrawch(WINDOW *, int, int, chtype);
+PDCEX  int     mvwdeleteln(WINDOW *, int, int);
+PDCEX  int     mvwinsertln(WINDOW *, int, int);
+PDCEX  int     mvwinsrawch(WINDOW *, int, int, chtype);
+PDCEX  int     raw_output(bool);
+PDCEX  int     resize_term(int, int);
+PDCEX  WINDOW *resize_window(WINDOW *, int, int);
+PDCEX  int     waddrawch(WINDOW *, chtype);
+PDCEX  int     winsrawch(WINDOW *, chtype);
+PDCEX  char    wordchar(void);
+
+#ifdef PDC_WIDE
+PDCEX  wchar_t *slk_wlabel(int);
+#endif
+
+PDCEX  void    PDC_debug(const char *, ...);
+PDCEX  void    PDC_get_version(PDC_VERSION *);
+PDCEX  int     PDC_ungetch(int);
+PDCEX  int     PDC_set_blink(bool);
+PDCEX  int     PDC_set_bold(bool);
+PDCEX  int     PDC_set_line_color(short);
+PDCEX  void    PDC_set_title(const char *);
+
+PDCEX  int     PDC_clearclipboard(void);
+PDCEX  int     PDC_freeclipboard(char *);
+PDCEX  int     PDC_getclipboard(char **, long *);
+PDCEX  int     PDC_setclipboard(const char *, long);
+
+PDCEX  unsigned long PDC_get_key_modifiers(void);
+PDCEX  int     PDC_return_key_modifiers(bool);
+PDCEX  void    PDC_set_resize_limits( const int new_min_lines,
+                               const int new_max_lines,
+                               const int new_min_cols,
+                               const int new_max_cols);
+
+#define FUNCTION_KEY_SHUT_DOWN        0
+#define FUNCTION_KEY_PASTE            1
+#define FUNCTION_KEY_ENLARGE_FONT     2
+#define FUNCTION_KEY_SHRINK_FONT      3
+#define FUNCTION_KEY_CHOOSE_FONT      4
+#define FUNCTION_KEY_ABORT            5
+#define PDC_MAX_FUNCTION_KEYS         6
+
+PDCEX int     PDC_set_function_key( const unsigned function,
+                              const int new_key);
+
+PDCEX  WINDOW *Xinitscr(int, char **);
+#ifdef XCURSES
+PDCEX  void    XCursesExit(void);
+PDCEX  int     sb_init(void);
+PDCEX  int     sb_set_horz(int, int, int);
+PDCEX  int     sb_set_vert(int, int, int);
+PDCEX  int     sb_get_horz(int *, int *, int *);
+PDCEX  int     sb_get_vert(int *, int *, int *);
+PDCEX  int     sb_refresh(void);
+#endif
+
+/* NetBSD */
+
+PDCEX  int     touchoverlap(const WINDOW *, WINDOW *);
+PDCEX  int     underend(void);
+PDCEX  int     underscore(void);
+PDCEX  int     wunderend(WINDOW *);
+PDCEX  int     wunderscore(WINDOW *);
+
+/*** Functions defined as macros ***/
+
+/* getch() and ungetch() conflict with some DOS libraries */
+
+#define getch()            wgetch(stdscr)
+#define ungetch(ch)        PDC_ungetch(ch)
+
+#define COLOR_PAIR(n)      (((chtype)(n) << PDC_COLOR_SHIFT) & A_COLOR)
+#define PAIR_NUMBER(n)     (((n) & A_COLOR) >> PDC_COLOR_SHIFT)
+
+/* These will _only_ work as macros */
+
+#define getbegyx(w, y, x)  (y = getbegy(w), x = getbegx(w))
+#define getmaxyx(w, y, x)  (y = getmaxy(w), x = getmaxx(w))
+#define getparyx(w, y, x)  (y = getpary(w), x = getparx(w))
+#define getyx(w, y, x)     (y = getcury(w), x = getcurx(w))
+
+#define getsyx(y, x)       { if (curscr->_leaveit) (y)=(x)=-1; \
+                             else getyx(curscr,(y),(x)); }
+
+#ifdef NCURSES_MOUSE_VERSION
+# define getmouse(x) nc_getmouse(x)
+#endif
+
+/* Deprecated */
+
+#define PDC_save_key_modifiers(x)  (OK)
+#define PDC_get_input_fd()         0
+
+/* return codes from PDC_getclipboard() and PDC_setclipboard() calls */
+
+#define PDC_CLIP_SUCCESS         0
+#define PDC_CLIP_ACCESS_ERROR    1
+#define PDC_CLIP_EMPTY           2
+#define PDC_CLIP_MEMORY_ERROR    3
+
+/* PDCurses key modifier masks */
+
+#define PDC_KEY_MODIFIER_SHIFT   1
+#define PDC_KEY_MODIFIER_CONTROL 2
+#define PDC_KEY_MODIFIER_ALT     4
+#define PDC_KEY_MODIFIER_NUMLOCK 8
+#define PDC_KEY_MODIFIER_REPEAT  16
+
+#ifdef __cplusplus
+# ifndef PDC_PP98
+#  undef bool
+# endif
+}
+#endif
+
+#endif  /* __PDCURSES__ */
diff --git a/lib/PDCursesMod/curspriv.h b/lib/PDCursesMod/curspriv.h
new file mode 100644
index 00000000000..f33b52d37fa
--- /dev/null
+++ b/lib/PDCursesMod/curspriv.h
@@ -0,0 +1,125 @@
+/* Private definitions and declarations for use within PDCurses.
+   These should generally not be referenced by applications. */
+
+#ifndef __CURSES_INTERNALS__
+#define __CURSES_INTERNALS__ 1
+
+#define CURSES_LIBRARY
+#include <curses.h>
+
+#if defined(__TURBOC__) || defined(__EMX__) || defined(__DJGPP__) || \
+    defined(PDC_99) || defined(__WATCOMC__)
+# if !defined( HAVE_VSSCANF) && !defined( __DMC__)
+#  define HAVE_VSSCANF       /* have vsscanf() */
+# endif
+#endif
+
+#if defined(PDC_99) || defined(__WATCOMC__)
+# if !defined( HAVE_VSNPRINTF) && !defined( __DMC__)
+#  define HAVE_VSNPRINTF     /* have vsnprintf() */
+# endif
+#endif
+
+/*----------------------------------------------------------------------*/
+
+typedef struct           /* structure for ripped off lines */
+{
+    int line;
+    int (*init)(WINDOW *, int);
+} RIPPEDOFFLINE;
+
+/* Window properties */
+
+#define _SUBWIN    0x01  /* window is a subwindow */
+#define _PAD       0x10  /* X/Open Pad. */
+#define _SUBPAD    0x20  /* X/Open subpad. */
+
+/* Miscellaneous */
+
+#define _NO_CHANGE -1    /* flags line edge unchanged */
+
+#define _ECHAR     0x08  /* Erase char       (^H) */
+#define _DWCHAR    0x17  /* Delete Word char (^W) */
+#define _DLCHAR    0x15  /* Delete Line char (^U) */
+
+/*----------------------------------------------------------------------*/
+
+/* Platform implementation functions */
+
+void    PDC_beep(void);
+bool    PDC_can_change_color(void);
+int     PDC_color_content(int, int *, int *, int *);
+bool    PDC_check_key(void);
+int     PDC_curs_set(int);
+void    PDC_doupdate(void);
+void    PDC_flushinp(void);
+int     PDC_get_columns(void);
+int     PDC_get_cursor_mode(void);
+int     PDC_get_key(void);
+int     PDC_get_rows(void);
+void    PDC_gotoyx(int, int);
+bool    PDC_has_mouse(void);
+int     PDC_init_color(int, int, int, int);
+int     PDC_modifiers_set(void);
+int     PDC_mouse_set(void);
+void    PDC_napms(int);
+void    PDC_reset_prog_mode(void);
+void    PDC_reset_shell_mode(void);
+int     PDC_resize_screen(int, int);
+void    PDC_restore_screen_mode(int);
+void    PDC_save_screen_mode(int);
+#ifdef XCURSES
+void    PDC_set_args(int, char **);
+#endif
+void    PDC_scr_close(void);
+void    PDC_scr_free(void);
+int     PDC_scr_open(void);
+void    PDC_set_keyboard_binary(bool);
+void    PDC_transform_line(int, int, int, const chtype *);
+const char *PDC_sysname(void);
+
+/* Internal cross-module functions */
+
+int     PDC_init_atrtab(void);
+WINDOW *PDC_makelines(WINDOW *);
+WINDOW *PDC_makenew(int, int, int, int);
+int     PDC_mouse_in_slk(int, int);
+void    PDC_slk_free(void);
+void    PDC_slk_initialize(void);
+void    PDC_sync(WINDOW *);
+void    PDC_set_default_colors( const int, const int);
+
+#ifdef PDC_WIDE
+int     PDC_mbtowc(wchar_t *, const char *, size_t);
+size_t  PDC_mbstowcs(wchar_t *, const char *, size_t);
+size_t  PDC_wcstombs(char *, const wchar_t *, size_t);
+#endif
+
+#ifdef PDCDEBUG
+# define PDC_LOG(x) if (SP && SP->dbfp) PDC_debug x
+#else
+# define PDC_LOG(x)
+#endif
+
+/* Internal macros for attributes */
+
+#ifndef max
+# define max(a,b) (((a) > (b)) ? (a) : (b))
+#endif
+#ifndef min
+# define min(a,b) (((a) < (b)) ? (a) : (b))
+#endif
+
+#define DIVROUND(num, divisor) ((num) + ((divisor) >> 1)) / (divisor)
+
+#define PDC_CLICK_PERIOD 150  /* time to wait for a click, if
+                                 not set by mouseinterval() */
+#define PDC_COLOR_PAIRS  256
+#define PDC_MAXCOL       768  /* maximum possible COLORS; may be less */
+
+#define _INBUFSIZ        512  /* size of terminal input buffer */
+#define NUNGETCH         256  /* max # chars to ungetch() */
+
+#define INTENTIONALLY_UNUSED_PARAMETER( param) (void)(param)
+
+#endif /* __CURSES_INTERNALS__ */
diff --git a/lib/PDCursesMod/demos/README.md b/lib/PDCursesMod/demos/README.md
new file mode 100644
index 00000000000..8f4b5c6c232
--- /dev/null
+++ b/lib/PDCursesMod/demos/README.md
@@ -0,0 +1,25 @@
+PDCurses Demos
+==============
+
+This directory contains demonstration programs to show and test the 
+capabilities of curses libraries. Some of them predate PDCurses, 
+PCcurses or even pcurses/ncurses. Although some PDCurses-specific code 
+has been added, all programs remain portable to other implementations 
+(at a minimum, to ncurses).
+
+
+Building
+--------
+
+The demos are built by the platform-specific makefiles, in the platform 
+directories. Alternatively, you can build them manually, individually, 
+and link with any curses library; e.g., "cc -lcurses -orain rain.c". 
+There are no dependencies besides curses and the standard C library, and 
+no configuration is needed.
+
+
+Distribution Status
+-------------------
+
+Public Domain, except for rain.c and worm.c, which are under the ncurses 
+license (MIT-like).
diff --git a/lib/PDCursesMod/demos/firework.c b/lib/PDCursesMod/demos/firework.c
new file mode 100644
index 00000000000..5788fc0263f
--- /dev/null
+++ b/lib/PDCursesMod/demos/firework.c
@@ -0,0 +1,149 @@
+#include <curses.h>
+#include <stdlib.h>
+#include <time.h>
+
+#define DELAYSIZE 200
+
+void myrefresh(void);
+void get_color(void);
+void explode(int, int);
+
+short color_table[] =
+{
+    COLOR_RED, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,
+    COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE
+};
+
+#define INTENTIONALLY_UNUSED_PARAMETER( param) (void)(param)
+
+int main(int argc, char **argv)
+{
+    time_t seed;
+    int start, end, row, diff, flag, direction;
+    short i;
+
+#ifdef XCURSES
+    Xinitscr(argc, argv);
+#else
+    INTENTIONALLY_UNUSED_PARAMETER( argv);
+    INTENTIONALLY_UNUSED_PARAMETER( argc);
+    initscr();
+#endif
+    keypad(stdscr, TRUE);
+    nodelay(stdscr, TRUE);
+    noecho();
+
+    if (has_colors())
+        start_color();
+
+    for (i = 0; i < 8; i++)
+        init_pair(i, color_table[i], COLOR_BLACK);
+
+    seed = time((time_t *)0);
+    srand( (unsigned)seed);
+    flag = 0;
+
+    while (getch() == ERR)      /* loop until a key is hit */
+    {
+        do {
+            start = rand() % (COLS - 3);
+            end = rand() % (COLS - 3);
+            start = (start < 2) ? 2 : start;
+            end = (end < 2) ? 2 : end;
+            direction = (start > end) ? -1 : 1;
+            diff = abs(start - end);
+
+        } while (diff < 2 || diff >= LINES - 2);
+
+        attrset(A_NORMAL);
+
+        for (row = 0; row < diff; row++)
+        {
+            mvaddstr(LINES - row, row * direction + start,
+                (direction < 0) ? "\\" : "/");
+
+            if (flag++)
+            {
+                myrefresh();
+                erase();
+                flag = 0;
+            }
+        }
+
+        if (flag++)
+        {
+            myrefresh();
+            flag = 0;
+        }
+
+        explode(LINES - row, diff * direction + start);
+        erase();
+        myrefresh();
+    }
+
+    endwin();
+
+    return 0;
+}
+
+void explode(int row, int col)
+{
+    erase();
+    mvaddstr(row, col, "-");
+    myrefresh();
+
+    --col;
+
+    get_color();
+    mvaddstr(row - 1, col, " - ");
+    mvaddstr(row,     col, "-+-");
+    mvaddstr(row + 1, col, " - ");
+    myrefresh();
+
+    --col;
+
+    get_color();
+    mvaddstr(row - 2, col, " --- ");
+    mvaddstr(row - 1, col, "-+++-");
+    mvaddstr(row,     col, "-+#+-");
+    mvaddstr(row + 1, col, "-+++-");
+    mvaddstr(row + 2, col, " --- ");
+    myrefresh();
+
+    get_color();
+    mvaddstr(row - 2, col, " +++ ");
+    mvaddstr(row - 1, col, "++#++");
+    mvaddstr(row,     col, "+# #+");
+    mvaddstr(row + 1, col, "++#++");
+    mvaddstr(row + 2, col, " +++ ");
+    myrefresh();
+
+    get_color();
+    mvaddstr(row - 2, col, "  #  ");
+    mvaddstr(row - 1, col, "## ##");
+    mvaddstr(row,     col, "#   #");
+    mvaddstr(row + 1, col, "## ##");
+    mvaddstr(row + 2, col, "  #  ");
+    myrefresh();
+
+    get_color();
+    mvaddstr(row - 2, col, " # # ");
+    mvaddstr(row - 1, col, "#   #");
+    mvaddstr(row,     col, "     ");
+    mvaddstr(row + 1, col, "#   #");
+    mvaddstr(row + 2, col, " # # ");
+    myrefresh();
+}
+
+void myrefresh(void)
+{
+    napms(DELAYSIZE);
+    move(LINES - 1, COLS - 1);
+    refresh();
+}
+
+void get_color(void)
+{
+    chtype bold = (rand() % 2) ? A_BOLD : A_NORMAL;
+    attrset(COLOR_PAIR(rand() % 8) | bold);
+}
diff --git a/lib/PDCursesMod/demos/nctests.mif b/lib/PDCursesMod/demos/nctests.mif
new file mode 100644
index 00000000000..3d3cfbe59b5
--- /dev/null
+++ b/lib/PDCursesMod/demos/nctests.mif
@@ -0,0 +1,34 @@
+# This provides for compiling and linking the ncurses test programs.
+
+ncurses_testdir = $(HOME)/ncurses-6.1/test
+
+NCURSES_TESTS   = bs$(E) gdc$(E) hanoi$(E) knight$(E) tclock$(E) \
+lrtest$(E) ncurses$(E)
+
+ncurses_tests: $(NCURSES_TESTS)
+
+ncurses_clean:
+	-rm -f *.$(O) trace $(NCURSES_TESTS)
+
+NCFLAGS         = $(DEMOFLAGS) -I$(demodir) -I$(ncurses_testdir)
+
+bs$(E): $(ncurses_testdir)/bs.c
+	$(BUILD) $(NCFLAGS) -o $@ $< $(LDFLAGS)
+
+gdc$(E): $(ncurses_testdir)/gdc.c
+	$(BUILD) $(NCFLAGS) -o $@ $< $(LDFLAGS)
+
+hanoi$(E): $(ncurses_testdir)/hanoi.c
+	$(BUILD) $(NCFLAGS) -o $@ $< $(LDFLAGS) -lm
+
+knight$(E): $(ncurses_testdir)/knight.c
+	$(BUILD) $(NCFLAGS) -o $@ $< $(LDFLAGS)
+
+tclock$(E): $(ncurses_testdir)/tclock.c
+	$(BUILD) $(NCFLAGS) -o $@ $< $(LDFLAGS) -lm
+
+lrtest$(E): $(ncurses_testdir)/lrtest.c
+	$(BUILD) $(NCFLAGS) -o $@ $< $(LDFLAGS)
+
+ncurses$(E): $(ncurses_testdir)/ncurses.c
+	$(BUILD) $(NCFLAGS) -o $@ $< $(LDFLAGS)
diff --git a/lib/PDCursesMod/demos/newtest.c b/lib/PDCursesMod/demos/newtest.c
new file mode 100644
index 00000000000..6bc8b87b78f
--- /dev/null
+++ b/lib/PDCursesMod/demos/newtest.c
@@ -0,0 +1,591 @@
+/*
+ *  newtest.c   -   Tests certain PDCurses functions,
+ *    mostly those in Win32a,  including some of the
+ *    new attributes for 64-bit chtype.  I wanted to be
+ *    sure the PDC_set_blink and PDC_set_line_color
+ *    functions worked,  and that A_OVERLINE and A_STRIKEOUT
+ *    displayed properly.  Also tests "extended" SLK functions.
+ *
+ */
+#ifndef _XOPEN_SOURCE_EXTENDED
+# define _XOPEN_SOURCE_EXTENDED 1
+#endif
+
+#if defined (PDC_WIDE)
+   #include <curses.h>
+   #define HAVE_WIDE
+#elif defined (HAVE_NCURSESW)
+   #include <ncursesw/curses.h>
+   #define HAVE_WIDE
+#else
+   #include <curses.h>
+#endif
+
+#include <string.h>
+#include <stdio.h>
+#include <locale.h>
+
+int PDC_write_screen_to_file( const char *filename, WINDOW *win);
+
+#ifndef A_OVERLINE
+   #define A_OVERLINE   0
+#endif
+
+static const char *labels[] = {
+               "Quit", "No labels", "431", "2134", "55",
+               "62-really-longer-than-it-should-be-just-for-testing",
+               "83", "7", "b", "25 (seven total)", "32", NULL };
+
+static void slk_setup( const int slk_format)
+{
+    int i;
+#ifdef PDCURSES
+    static int old_format = 0xa;
+
+    if( slk_format != old_format)
+       slk_init( slk_format);
+    old_format = slk_format;
+#endif
+    for( i = 0; labels[i]; i++)
+       slk_set( i + 1, labels[i], 1);
+    slk_refresh( );
+}
+
+static const char *on_off_text( const chtype attrib)
+{
+   return( attrib ? "On " : "Off");
+}
+
+   /* Uses the left/right/under/overline capabilities of Win32a */
+   /* to ensure the text is "boxed".  */
+
+void text_in_a_box( const char *istr)
+{
+   const int len = (int)strlen( istr);
+
+#if defined( A_OVERLINE) && defined( A_UNDERLINE) && defined( A_LEFTLINE) && defined( A_RIGHTLINE)
+   attron( A_OVERLINE | A_UNDERLINE | A_LEFTLINE);
+   if( len == 1)
+      attron( A_RIGHTLINE);
+#endif
+   addnstr( istr, 1);
+   if( len > 1)
+      {
+#ifdef A_LEFTLINE
+      attroff( A_LEFTLINE);
+#endif
+      if( len > 2)
+         addnstr( istr + 1, len - 2);
+#ifdef A_RIGHTLINE
+      attron( A_RIGHTLINE);
+#endif
+      addnstr( istr + len - 1, 1);
+      }
+#if defined( A_OVERLINE) && defined( A_UNDERLINE) && defined( A_LEFTLINE) && defined( A_RIGHTLINE)
+   attroff( A_OVERLINE | A_UNDERLINE | A_LEFTLINE | A_RIGHTLINE);
+#endif
+}
+
+#define COL1 2
+#define COL2 (COL1 + 30)
+#define COL3 72
+
+#define N_CURSORS 9
+      /* There are nine different cursor types;  see below for the list.  */
+      /* You specify two types,  and the cursor blinks between them.      */
+      /* Default is between "underline" and "invisible".  Set both states */
+      /* to the same value to get an unblinking cursor.                   */
+
+#if defined( _WIN32) && !defined( __BORLANDC__)
+#define PURE_WINDOWS_VERSION  1
+#endif
+
+/* Among other things,  'newtest' demonstrates how to make a Win32a
+PDCurses app that is a for-real,  "pure Windows" version (instead of
+a console application).  Doing this is quite easy,  and has certain
+advantages.  If the app is invoked from a command prompt,  the only
+difference you'll see is that the app runs separately (that is,  you
+can continue to use the command prompt,  switching between it,  your
+PDCurses/Win32a app,  and other processes).  Which is the main reason
+I did it;  it meant that I could invoke a PDCurses-based text editor,
+for example,  and still have use of the command line.
+
+   (NOTE that,  for reasons I don't actually understand,  this happens
+when the Visual C++ compiler is used.  With MinGW or OpenWatcom,  it's
+still "really" a console app.)
+
+   To do it,  we ensure that the usual main() function has an alternative
+dummy_main() form,  taking the same arguments as main().  We add a
+WinMain() function,  whose sole purpose is to reformulate lpszCmdLine
+into argc/argv form,  and pass it on to dummy_main().  And,  of course,
+we can switch back to a "normal" console app by removing the above
+#define PURE_WINDOWS_VERSION line.             */
+
+#ifdef PURE_WINDOWS_VERSION
+#undef MOUSE_MOVED
+#include <windows.h>
+
+#define INTENTIONALLY_UNUSED_PARAMETER( param) (void)(param)
+
+int dummy_main( int argc, char **argv);
+
+int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
+                    LPSTR lpszCmdLine, int nCmdShow)
+{
+   char *argv[30];
+   int i, argc = 1;
+
+   INTENTIONALLY_UNUSED_PARAMETER( hInstance);
+   INTENTIONALLY_UNUSED_PARAMETER( hPrevInstance);
+   INTENTIONALLY_UNUSED_PARAMETER( nCmdShow);
+   argv[0] = "newtest";
+   for( i = 0; lpszCmdLine[i]; i++)
+       if( lpszCmdLine[i] != ' ' && (!i || lpszCmdLine[i - 1] == ' '))
+          argv[argc++] = lpszCmdLine + i;
+
+   for( i = 0; lpszCmdLine[i]; i++)
+       if( lpszCmdLine[i] == ' ')
+          lpszCmdLine[i] = '\0';
+
+   return dummy_main( argc, (char **)argv);
+}
+
+int dummy_main( int argc, char **argv)
+#else       /* "usual",  console-app version: */
+int main( int argc, char **argv)
+#endif
+{
+    int quit = 0, i,  use_slk = 1;
+    bool show_mouse_moves = FALSE;
+#ifdef PDCURSES
+    int fmt = 0xa;
+    const char *title_text = "NewTest: tests various PDCurses features";
+#else
+    int fmt = 3;   /* for ncurses,  this is the 4-4-4 SLK format */
+#endif
+    int cursor_state_1 = 0, cursor_state_2 = 1;
+    int cursor_y = 19, cursor_x = 51;
+    int show_slk_index_line = 0;
+    int redraw = 1;
+    const char *extra_characters_to_show = "";
+#ifdef HAVE_WIDE
+    unsigned unicode_offset = 0x80;
+#endif
+
+    setlocale(LC_ALL, "");
+    ttytype[0] = 25;   ttytype[1] = 90;         /* Allow 25 to 90 lines... */
+    ttytype[2] = 80;   ttytype[3] = (char)127;  /* ...and 80 to 127 columns */
+         /* (This program gets weird artifacts when smaller than 25x80.) */
+    for( i = 1; i < argc; i++)
+        if( argv[i][0] == '-')
+            switch( argv[i][1])
+            {
+                case 's':
+                    use_slk = 0;
+                    break;
+                case 'l':
+                    setlocale( LC_ALL, argv[i] + 2);
+                    break;
+                case 'e':
+                    extra_characters_to_show = argv[i] + 2;
+                    break;
+                case 'f':
+                    sscanf( argv[i] + 2, "%x", (unsigned *)&fmt);
+                    break;
+                case 'i':
+                    show_slk_index_line = 1;
+                    break;
+                case 'r':     /* allow user-resizable windows */
+                    {
+                        int min_lines, max_lines, min_cols, max_cols;
+
+                        if( sscanf( argv[i] + 2, "%d,%d,%d,%d",
+                                       &min_lines, &max_lines,
+                                       &min_cols, &max_cols) == 4)
+                        {
+                            ttytype[0] = (char)min_lines;
+                            ttytype[1] = (char)max_lines;
+                            ttytype[2] = (char)min_cols;
+                            ttytype[3] = (char)max_cols;
+                        }
+                    }
+                    break;
+                case 'd':     /* set window size before initscr */
+                    {
+                        int n_lines, n_cols;
+
+                        if( sscanf( argv[i] + 2, "%d,%d", &n_lines,
+                                    &n_cols) == 2)
+                            resize_term( n_lines, n_cols);
+                    }
+                    break;
+#ifdef PDCURSES
+                case 'z':
+                    traceon( );
+                    PDC_debug( "Debugging is on\n");
+                    break;
+                case 't':
+                    title_text = argv[i] + 2;
+                    break;
+#endif
+#ifdef HAVE_WIDE
+                case 'u':
+                    sscanf( argv[i] + 2, "%x", &unicode_offset);
+                    break;
+#endif
+                case 'm':
+                    show_mouse_moves = TRUE;
+                    break;
+                default:
+                    printf( "Option '%s' unrecognized\n", argv[i]);
+                    break;
+            }
+    if( use_slk)
+       slk_init( show_slk_index_line ? -fmt : fmt);
+#ifdef XCURSES
+    Xinitscr(argc, argv);
+#else
+    initscr();
+#endif
+    if( use_slk)
+       slk_setup( show_slk_index_line ? -fmt : fmt);
+
+    start_color();
+
+# if defined(NCURSES_VERSION) || (defined(PDC_BUILD) && PDC_BUILD > 3000)
+    use_default_colors();
+# endif
+    cbreak();
+    noecho();
+    clear();
+    refresh();
+#ifdef __PDCURSES__
+    PDC_set_title( title_text);
+#endif
+    keypad( stdscr, TRUE);
+    init_pair( 1, COLOR_WHITE, COLOR_BLACK);
+    init_pair( 2, COLOR_BLACK, COLOR_YELLOW);
+
+    mousemask( ALL_MOUSE_EVENTS | (show_mouse_moves ? REPORT_MOUSE_POSITION : 0), NULL);
+    attrset( COLOR_PAIR( 1));
+    while( !quit)
+    {
+        char buff[80];
+        const int xmax = getmaxx( stdscr);
+        const int ymax = getmaxy( stdscr);
+        const int color_block_start = 54;
+        int c, color_block_cols = (xmax - color_block_start) / 2;
+        const int color_block_lines = 19;
+        const char *cursor_state_text[N_CURSORS] = {
+                  "Invisible (click to change) ",
+                  "Underscore (click to change)",
+                  "Block (click to change)     ",
+                  "Outline (click to change)   ",
+                  "Caret (click to change)     ",
+                  "Half-block (click to change)",
+                  "Central (click to change)   ",
+                  "Cross (click to change)     ",
+                  "Heavy box (click to change) " };
+
+        if( color_block_cols < 0)
+            color_block_cols = 0;
+        if( redraw)
+        {
+            mvaddstr( 1, COL1, "'Normal' white-on-black");
+            mvaddstr( 2, COL1, longname( ));
+#ifdef A_DIM
+            attron( A_DIM);
+            mvaddstr( 15, 41, "Dimmed text");
+            attroff( A_DIM);
+#endif
+#ifdef A_STANDOUT
+            attron( A_STANDOUT);
+            mvaddstr( 16, 41, "Standout text");
+            attroff( A_STANDOUT);
+#endif
+#ifdef HAVE_WIDE
+            mvaddwstr( 3, COL1, L"'N\xf3rm\xe4\x142' text,  bu\x163 w\xee\x1e0b\xea");
+#endif
+            attron( A_BLINK);
+            sprintf( buff, "Blink %s", on_off_text( termattrs( ) & A_BLINK));
+
+            mvaddstr( 6, 40, buff);
+            attron( A_BOLD);
+            mvaddstr( 8, 40, "BlinkBold");
+            attrset( A_BOLD);
+            sprintf( buff, "Bold %s", on_off_text( termattrs( ) & A_BOLD));
+            mvaddstr( 7, 40, buff);
+            attron( A_BLINK);
+#ifdef A_ITALIC
+            attron( A_ITALIC);
+            mvaddstr( 0, COL2, "BlinkBoldItalic");
+#endif
+            attrset( COLOR_PAIR( 3));
+            attron( A_UNDERLINE);
+#ifdef HAVE_WIDE
+            mvaddstr( 1, COL2, "Underlined");
+            addwstr( L"WideUnder");
+#endif
+            attrset( COLOR_PAIR( 1));
+#ifdef A_ITALIC
+            attron( A_UNDERLINE | A_ITALIC);
+            mvaddstr( 2, COL2, "UnderlinedItalic");
+#endif
+            attrset( COLOR_PAIR( 2));
+            attron( A_BLINK);
+            mvaddstr( 4, COL1, "Black-on-yellow blinking");
+
+            attrset( COLOR_PAIR( 1));
+            move( 4, COL2);
+            text_in_a_box( "Text in a box");
+
+#if defined( CHTYPE_64) && defined( A_STRIKEOUT)
+            attrset( COLOR_PAIR( 6));
+            attron( A_STRIKEOUT);
+            mvaddstr( 10, 40, "Strikeout");
+            attrset( COLOR_PAIR( 1));
+#endif
+
+#ifdef HAVE_WIDE
+            move( 11, 40);
+            text_in_a_box( "Next Ucode pg");
+            if( unicode_offset)
+               {
+               move( 12, 40);
+               text_in_a_box( "Prev Ucode pg");
+               }
+            mvprintw( 13, 40, "U+%04x ", unicode_offset);
+
+#endif
+
+            mvaddstr( 5, 1, "   0 1 2 3 4 5 6 7 8 9 a b c d e f");
+            for( i = 0; i < 8; i++)
+                {
+#ifdef HAVE_WIDE
+                sprintf( buff, "%02x",
+                                (unsigned)( i * 16 + unicode_offset) & 0xff);
+#else
+                sprintf( buff, "%02x", (unsigned)( i * 16 + 128) & 0xff);
+
+#endif
+                mvaddstr( 6 + i, 1, buff);
+                mvaddstr( 6 + i, 36, buff);
+                }
+            for( i = 0; i < 128; i++)
+            {                 /* Show extended characters: */
+#ifdef HAVE_WIDE
+                wchar_t wbuff[2];
+
+                wbuff[0] = (wchar_t)( i + unicode_offset);
+                wbuff[1] = '\0';
+                mvaddwstr( 6 + i / 16, 4 + 2 * (i % 16), wbuff);
+#else
+                move( 6 + i / 16, 4 + 2 * (i % 16));
+                addch( i + 128);
+#endif
+                addch( ' ');
+            }
+#ifdef HAVE_WIDE
+            if( unicode_offset == 0x80)
+            {
+                mvaddstr( 6, 1, "   Click on 'bold on/off or 'blink ->");
+                mvaddstr( 7, 1, "   on/off' to toggle those attribs   ");
+            }
+#endif
+            redraw = 0;
+            attrset( COLOR_PAIR( 1));
+            if( *extra_characters_to_show && ymax > 23)
+            {
+                unsigned long ival;
+                int bytes_read;
+                const char *tptr = extra_characters_to_show;
+
+                move( 23, 63);
+                while( sscanf( tptr, "%lx%n", &ival, &bytes_read) > 0)
+                {
+                    addch( (chtype)ival);
+                    tptr += bytes_read;
+                    if( *tptr)
+                        tptr++;
+                }
+            }
+#ifdef HAVE_WIDE
+            for( i = 0; i < 6; i++)
+            {
+                static const wchar_t spanish[] = L"Espa\xf1ol";
+
+                static const wchar_t russian[] = {0x0420, 0x0443, 0x0441, 0x0441,
+                   0x043a, 0x0438, 0x0439, L' ', 0x044f, 0x0437, 0x044b, 0x043a, 0};
+
+                static const wchar_t greek[] = {0x0395, 0x03bb, 0x03bb, 0x03b7,
+                   0x03bd, 0x03b9, 0x03ba, 0x03ac, 0};
+
+                static const wchar_t georgian[] = {0x10e5, 0x10d0, 0x10e0, 0x10d7,
+                   0x10e3, 0x10da, 0x10d8, L' ', 0x10d4, 0x10dc, 0x10d0, 0};
+
+                static const wchar_t fullwidth[] = { 0xff26, 0xff55, 0xff4c, 0xff4c,
+                   0xff57, 0xff49, 0xff44, 0xff54, 0xff48, 0 };  /* "Fullwidth" */
+
+                static const wchar_t combining_marks[] = { L'C', L'o', 0x35c, L'm',
+                   L'b', 0x30a, L'i', L'n', L'i', 0x304, L'n', 0x30b, 0x329,
+                   L'g', 0x310,
+                   L' ', L'C', 0x338, L'h', 0x306,  L'a', 0x361, L'r', L's',
+                   0x30e, 0x348, 0 };
+
+                static const wchar_t *texts[6] = { spanish, russian, greek,
+                                georgian, fullwidth, combining_marks};
+
+                mvaddwstr( 15 + i / 2, 2 + 20 * (i % 2), texts[i]);
+            }
+#ifdef CHTYPE_64
+             mvaddch( 17, 41, (chtype)0x1d11e);
+#endif            /* U+1D11E = musical symbol G clef */
+#endif
+        mvaddstr( 19, 1, curses_version( ));
+
+#ifdef MAYBE_TRY_THIS_SOMEWHERE_ELSE
+        mvaddstr(  1, COL3, "Click on cursor descriptions to");
+        mvaddstr(  2, COL3, "cycle through possible cursors");
+        mvaddstr(  3, COL3, "Click on colors at left to change");
+        mvaddstr(  4, COL3, "colors used for under/over/outlining");
+        mvaddstr(  5, COL3, "Click 'Blink' at bottom to toggle");
+        mvaddstr(  6, COL3, "'real' blinking vs. 'highlit' blink");
+#endif
+        }
+
+        mvaddnstr( 19, color_block_start, cursor_state_text[cursor_state_1],
+                                 xmax - color_block_start);
+        mvaddnstr( 20, color_block_start, cursor_state_text[cursor_state_2],
+                                 xmax - color_block_start);
+        curs_set( (cursor_state_1 << 8) | cursor_state_2);
+        for( i = 0; i < color_block_cols * color_block_lines; i++)
+        {
+            const int n_color_blocks = (COLOR_PAIRS < 256 ? COLOR_PAIRS : 256);
+
+            attrset( COLOR_PAIR( i >= n_color_blocks ? 2 : i));
+            if( i > 2 && i < n_color_blocks)
+               init_pair((short)i, (short)i, COLOR_BLACK);
+            if( !(i % color_block_cols))
+               move( i / color_block_cols, color_block_start);
+            attron( A_REVERSE);
+            addstr( "  ");
+        }
+        move( cursor_y, cursor_x);
+        refresh();
+        c = getch( );
+        attrset( COLOR_PAIR( 1));
+        if( c == KEY_RESIZE)
+        {
+            redraw = 1;
+            resize_term( 0, 0);
+        }
+        else if( c == 'z')    /* test ability to briefly show original scr */
+        {
+            endwin( );
+            getchar( );
+            refresh( );
+        }
+        else if( c == KEY_F(1) || c == 27)
+            quit = 1;
+        else if( c == KEY_F(2))   /* toggle SLKs */
+        {
+            use_slk ^= 1;
+            if( use_slk)
+                slk_restore( );
+            else
+                slk_clear( );
+        }
+        else if( c >= KEY_F(3) && c < KEY_F(12))
+        {
+            sscanf( labels[c - KEY_F(1)], "%x", (unsigned *)&fmt);
+            if( use_slk)
+                slk_setup( show_slk_index_line ? -fmt : fmt);
+        }
+        if( c != KEY_MOUSE)
+        {
+            sprintf( buff, "Key %s", keyname( c));
+            if( !memcmp( buff + 4, "UNKNOWN", 7))
+                sprintf( buff + 11, " (%x)", c);
+            if( c == KEY_RESIZE)
+                {
+                sprintf( buff + strlen( buff), "(%d x %d)       ",
+                        COLS, LINES);
+                napms( 300);
+                }
+            strcat( buff, " hit                 ");
+            buff[COL2 - COL1] = '\0';
+            mvaddstr( 0, COL1, buff);
+        }
+        else
+        {
+            MEVENT mouse_event;
+#ifdef __PDCURSES__
+            nc_getmouse( &mouse_event);
+#else
+            getmouse( &mouse_event);
+#endif
+            sprintf( buff, "Mouse at %d x %d: %x     ", mouse_event.x,
+                              mouse_event.y, (unsigned)mouse_event.bstate);
+            cursor_x = mouse_event.x;
+            cursor_y = mouse_event.y;
+            mvaddstr( 0, COL1, buff);
+            if( mouse_event.x >= color_block_start
+                            && mouse_event.y < color_block_lines)
+            {
+                int new_color = (mouse_event.x - color_block_start) / 2
+                              + mouse_event.y * color_block_cols;
+
+                if( new_color >= 256)
+                    new_color = -1;
+#ifdef PDCURSES
+                PDC_set_line_color( (short)new_color);
+#endif
+            }
+#ifdef PDCURSES
+            else if( mouse_event.x >= color_block_start)
+            {
+                int shift = ((mouse_event.bstate & BUTTON_MODIFIER_SHIFT) ?
+                           N_CURSORS - 1 : 1);
+
+                if( mouse_event.y == 19)  /* blink/non-blink toggle */
+                    cursor_state_1 = (cursor_state_1 + shift) % N_CURSORS;
+                else if( mouse_event.y == 20)  /* cycle cursor state */
+                    cursor_state_2 = (cursor_state_2 + shift) % N_CURSORS;
+            }
+#endif
+            else if( mouse_event.x >= 40 && mouse_event.x <= 52)
+               switch( mouse_event.y)
+               {
+#ifdef HAVE_WIDE
+                  case 11:
+                     redraw = 1;
+                     unicode_offset += 0x80;
+                     break;
+                  case 12:
+                     if( unicode_offset)
+                     {
+                        redraw = 1;
+                        unicode_offset -= 0x80;
+                     }
+                     break;
+#endif
+#ifdef PDCURSES
+                  case 6:
+                     PDC_set_blink( termattrs( ) & A_BLINK ? FALSE : TRUE);
+                     redraw = 1;
+                     break;
+                  case 7:
+                     PDC_set_bold( termattrs( ) & A_BOLD ? FALSE : TRUE);
+                     redraw = 1;
+                     break;
+#endif
+                  default:
+                     break;
+               }
+        }
+    }
+
+    endwin();
+
+    return 0;
+}
diff --git a/lib/PDCursesMod/demos/ozdemo.c b/lib/PDCursesMod/demos/ozdemo.c
new file mode 100644
index 00000000000..11303928c0b
--- /dev/null
+++ b/lib/PDCursesMod/demos/ozdemo.c
@@ -0,0 +1,442 @@
+/*
+ *  ozdemo.c           - A demo program using PDCurses. The program
+ *  (formerly newdemo)   illustrates the use of colors for text output.
+ */
+
+#include <signal.h>
+#include <string.h>
+#include <curses.h>
+#include <stdlib.h>
+#include <time.h>
+
+int WaitForUser(void);
+int SubWinTest(WINDOW *);
+int BouncingBalls(WINDOW *);
+void trap(int);
+
+/* An ASCII map of Australia */
+
+char *AusMap[17] =
+{
+    "                 _,__        .:",
+    "         Darwin <*  /        | \\",
+    "            .-./     |.     :  :,",
+    "           /    |      '-._/     \\_",
+    "          /     |   N.T. | '       \\",
+    "        .'      |        |   Qld.  *: Brisbane",
+    "     .-'        |        |           ;",
+    "     |   W.A.   |----------|         |",
+    "     \\          |          |--------/",
+    "      |         |   S.A.   | N.S.W./",
+    "Perth  *        |__.--._   |-,_   *  Sydney",
+    "        \\     _.'       \\:.|Vic'-,|",
+    "        >__,-'   Adelaide  \\_/*_.-'",
+    "                              Melbourne",
+    "                             :--,",
+    "                        Tas.  '* Hobart",
+    ""
+};
+
+/* Funny messages for the scroller */
+
+char *messages[] =
+{
+    "Hello from the Land Down Under",
+    "The Land of crocs, and a big Red Rock",
+    "Where the sunflower runs along the highways",
+    "The dusty red roads lead one to loneliness",
+    "Blue sky in the morning and",
+    "Freezing nights and twinkling stars",
+    NULL
+};
+
+int WaitForUser(void)
+{
+    chtype ch;
+
+    nodelay(stdscr, TRUE);
+    halfdelay(50);
+
+    ch = getch();
+
+    nodelay(stdscr, FALSE);
+    nocbreak();     /* Reset the halfdelay() value */
+    cbreak();
+
+    return (ch == '\033') ? (int)ch : 0;
+}
+
+int SubWinTest(WINDOW *win)
+{
+    WINDOW *swin1, *swin2, *swin3;
+    int w, h, sw, sh, bx, by;
+
+    wattrset(win, 0);
+    getmaxyx(win, h, w);
+    getbegyx(win, by, bx);
+
+    sw = w / 3;
+    sh = h / 3;
+
+    if ((swin1 = derwin(win, sh, sw, 3, 5)) == NULL)
+        return 1;
+    if ((swin2 = subwin(win, sh, sw, by + 4, bx + 8)) == NULL)
+        return 1;
+    if ((swin3 = subwin(win, sh, sw, by + 5, bx + 11)) == NULL)
+        return 1;
+
+    init_pair(8, COLOR_RED, COLOR_BLUE);
+    wbkgd(swin1, COLOR_PAIR(8));
+    werase(swin1);
+    mvwaddstr(swin1, 0, 3, "Sub-window 1");
+    wrefresh(swin1);
+
+    init_pair(9, COLOR_CYAN, COLOR_MAGENTA);
+    wbkgd(swin2, COLOR_PAIR(9));
+    werase(swin2);
+    mvwaddstr(swin2, 0, 3, "Sub-window 2");
+    wrefresh(swin2);
+
+    init_pair(10, COLOR_YELLOW, COLOR_GREEN);
+    wbkgd(swin3, COLOR_PAIR(10));
+    werase(swin3);
+    mvwaddstr(swin3, 0, 3, "Sub-window 3");
+    wrefresh(swin3);
+
+    delwin(swin1);
+    delwin(swin2);
+    delwin(swin3);
+    WaitForUser();
+
+    return 0;
+}
+
+int BouncingBalls(WINDOW *win)
+{
+    chtype c1, c2, c3, ball1, ball2, ball3;
+    int w, h, x1, y1, xd1, yd1, x2, y2, xd2, yd2, x3, y3, xd3, yd3, c;
+
+    curs_set(0);
+
+    wbkgd(win, COLOR_PAIR(1));
+    wrefresh(win);
+    wattrset(win, 0);
+
+    init_pair(11, COLOR_RED, COLOR_GREEN);
+    init_pair(12, COLOR_BLUE, COLOR_RED);
+    init_pair(13, COLOR_YELLOW, COLOR_WHITE);
+
+    ball1 = 'O' | COLOR_PAIR(11);
+    ball2 = '*' | COLOR_PAIR(12);
+    ball3 = '@' | COLOR_PAIR(13);
+
+    getmaxyx(win, h, w);
+
+    x1 = 2 + rand() % (w - 4);
+    y1 = 2 + rand() % (h - 4);
+    x2 = 2 + rand() % (w - 4);
+    y2 = 2 + rand() % (h - 4);
+    x3 = 2 + rand() % (w - 4);
+    y3 = 2 + rand() % (h - 4);
+
+    xd1 = 1;
+    yd1 = 1;
+    xd2 = 1;
+    yd2 = -1;
+    xd3 = -1;
+    yd3 = 1;
+
+    nodelay(stdscr, TRUE);
+
+    while ((c = getch()) == ERR)
+    {
+        x1 += xd1;
+        if (x1 <= 1 || x1 >= w - 2)
+            xd1 *= -1;
+
+        y1 += yd1;
+        if (y1 <= 1 || y1 >= h - 2)
+            yd1 *= -1;
+
+        x2 += xd2;
+        if (x2 <= 1 || x2 >= w - 2)
+            xd2 *= -1;
+
+        y2 += yd2;
+        if (y2 <= 1 || y2 >= h - 2)
+            yd2 *= -1;
+
+        x3 += xd3;
+        if (x3 <= 1 || x3 >= w - 2)
+            xd3 *= -1;
+
+        y3 += yd3;
+        if (y3 <= 1 || y3 >= h - 2)
+            yd3 *= -1;
+
+        c1 = mvwinch(win, y1, x1);
+        c2 = mvwinch(win, y2, x2);
+        c3 = mvwinch(win, y3, x3);
+
+        mvwaddch(win, y1, x1, ball1);
+        mvwaddch(win, y2, x2, ball2);
+        mvwaddch(win, y3, x3, ball3);
+
+        wmove(win, 0, 0);
+        wrefresh(win);
+
+        mvwaddch(win, y1, x1, c1);
+        mvwaddch(win, y2, x2, c2);
+        mvwaddch(win, y3, x3, c3);
+
+        napms(150);
+    }
+
+    nodelay(stdscr, FALSE);
+    ungetch(c);
+    return 0;
+}
+
+/* Trap interrupt */
+
+void trap(int sig)
+{
+    if (sig == SIGINT)
+    {
+        endwin();
+
+        exit(0);
+    }
+}
+
+#define INTENTIONALLY_UNUSED_PARAMETER( param) (void)(param)
+
+int main(int argc, char **argv)
+{
+    WINDOW *win;
+    chtype save[80], ch;
+    time_t seed;
+    const int width = 52, height = 22, msg_line = 9;
+    int w, x, y, i, j;
+    const char *versions_1 =
+            " DOS, DOSVGA, OS/2, Plan 9, SDL 1/2,";
+    const char *versions_2 =
+            " VT, Windows console & GUI, X11";
+    const char *hit_any_key =
+            "       Type a key to continue or ESC to quit     ";
+
+#ifdef XCURSES
+    Xinitscr(argc, argv);
+#else
+    INTENTIONALLY_UNUSED_PARAMETER( argv);
+    INTENTIONALLY_UNUSED_PARAMETER( argc);
+    initscr();
+#endif
+    seed = time((time_t *)0);
+    srand( (unsigned)seed);
+
+    start_color();
+# if defined(NCURSES_VERSION) || (defined(PDC_BUILD) && PDC_BUILD > 3000)
+    use_default_colors();
+# endif
+    cbreak();
+    noecho();
+
+    curs_set(0);
+
+#if !defined(__TURBOC__) && !defined(OS2)
+    signal(SIGINT, trap);
+#endif
+    noecho();
+
+    /* refresh stdscr so that reading from it will not cause it to
+       overwrite the other windows that are being created */
+
+    refresh();
+
+    /* Create a drawing window */
+
+    win = newwin(height, width, (LINES - height) / 2, (COLS - width) / 2);
+
+    if (win == NULL)
+    {
+        endwin();
+
+        return 1;
+    }
+
+    for (;;)
+    {
+        init_pair(1, COLOR_WHITE, COLOR_BLUE);
+        wbkgd(win, COLOR_PAIR(1));
+        werase(win);
+
+        init_pair(2, COLOR_RED, COLOR_RED);
+        wattrset(win, COLOR_PAIR(2));
+        box(win, ' ', ' ');
+        wrefresh(win);
+
+        wattrset(win, 0);
+
+        /* Do random output of a character */
+
+        ch = 'a';
+
+        nodelay(stdscr, TRUE);
+
+        for (i = 0; i < 5000; ++i)
+        {
+            x = rand() % (width - 2) + 1;
+            y = rand() % (height - 2) + 1;
+
+            mvwaddch(win, y, x, ch);
+            wrefresh(win);
+
+            if (getch() != ERR)
+                break;
+
+            if (i == 2000)
+            {
+                ch = 'b';
+                init_pair(3, COLOR_CYAN, COLOR_YELLOW);
+                wattrset(win, COLOR_PAIR(3));
+            }
+        }
+
+        nodelay(stdscr, FALSE);
+
+        SubWinTest(win);
+
+        /* Erase and draw green window */
+
+        init_pair(4, COLOR_YELLOW, COLOR_GREEN);
+        wbkgd(win, COLOR_PAIR(4));
+        wattrset(win, A_BOLD);
+        werase(win);
+        wrefresh(win);
+
+        /* Draw RED bounding box */
+
+        wattrset(win, COLOR_PAIR(2));
+        box(win, ' ', ' ');
+        wrefresh(win);
+
+        /* Display Australia map */
+
+        wattrset(win, A_BOLD);
+        i = 0;
+
+        while (*AusMap[i])
+        {
+            mvwaddstr(win, i + 1, 3, AusMap[i]);
+            wrefresh(win);
+            napms(100);
+            ++i;
+        }
+
+        init_pair(5, COLOR_BLUE, COLOR_WHITE);
+        wattrset(win, COLOR_PAIR(5) | A_BLINK);
+        mvwaddstr( win, height - 5, 2, longname( ));
+        mvwaddstr( win, height - 4, 2, curses_version( ));
+        mvwaddstr( win, height - 3, 2, versions_1);
+        mvwaddstr( win, height - 2, 2, versions_2);
+        wrefresh(win);
+
+        /* Draw running messages */
+
+        init_pair(6, COLOR_BLACK, COLOR_WHITE);
+        wattrset(win, COLOR_PAIR(6));
+        w = width - 2;
+        nodelay(win, TRUE);
+
+        mvwhline(win, msg_line, 1, ' ', w);
+
+        for (j = 0; messages[j] != NULL; j++)
+        {
+            char *message = messages[j];
+            int msg_len = (int)strlen(message);
+            int stop = 0;
+            int xpos, start, count;
+
+            for (i = 0; i <= w + msg_len; i++)
+            {
+                if (i < w)
+                {
+                    xpos = w - i;
+                    start = 0;
+                    count = (i > msg_len) ? msg_len : i;
+                }
+                else
+                {
+                    xpos = 0;
+                    start = i - w;
+                    count = (w > msg_len - start) ? msg_len - start : w;
+                }
+
+                mvwaddnstr(win, msg_line, xpos + 1, message + start, count);
+                if (xpos + count < w)
+                    waddstr(win, " ");
+
+                wrefresh(win);
+
+                if (wgetch(win) != ERR)
+                {
+                    flushinp();
+                    stop = 1;
+                    break;
+                }
+
+                napms(100);
+            }
+
+            if (stop)
+                break;
+        }
+
+        j = 0;
+
+        /*  Draw running 'A's across in RED */
+
+        init_pair(7, COLOR_RED, COLOR_GREEN);
+        wattron(win, COLOR_PAIR(7));
+
+        for (i = 2; i < width - 4; ++i)
+        {
+            ch = mvwinch(win, 5, i);
+            save[j++] = ch;
+            ch = ch & 0x7f;
+            mvwaddch(win, 5, i, ch);
+        }
+
+        wrefresh(win);
+
+        /* Put a message up; wait for a key */
+
+        wattrset(win, COLOR_PAIR(5));
+        mvwaddstr(win, msg_line, 2, hit_any_key);
+        wrefresh(win);
+
+        if (WaitForUser() == '\033')
+            break;
+
+        /* Restore the old line */
+
+        wattrset(win, 0);
+
+        for (i = 2, j = 0; i < width - 4; ++i)
+            mvwaddch(win, 5, i, save[j++]);
+
+        wrefresh(win);
+
+        BouncingBalls(win);
+
+        /* BouncingBalls() leaves a keystroke in the queue */
+
+        if (WaitForUser() == '\033')
+            break;
+    }
+
+    endwin();
+
+    return 0;
+}
diff --git a/lib/PDCursesMod/demos/picsview.c b/lib/PDCursesMod/demos/picsview.c
new file mode 100644
index 00000000000..f1482f66685
--- /dev/null
+++ b/lib/PDCursesMod/demos/picsview.c
@@ -0,0 +1,489 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#define PDC_NCMOUSE
+
+#include "curses.h"
+#include <math.h>
+#include <assert.h>
+#ifndef _WIN32
+    #define CONVERT_IMAGES
+    #include <unistd.h>
+#endif
+
+/* This is inspired by,  but not really based on,  Thomas E. Dickey's
+'picsmap' program for ncurses.  Its real purpose is to demonstrate the
+ability to use large palettes (basically,  full RGB) and large numbers
+of color pairs (up to 2^20 = 1048576 pairs).  That ability is currently
+available only in the VT and WinGUI flavors of PDCurses,  but will be
+expanded to X11,  SDLx,  and probably WinCon.
+
+   Run with an image file as a command-line argument.  The image will
+be displayed using PDCurses' extended color palette and color pairs.
+You can pan around the image with the mouse and keyboard, and zoom
+in/out using the mouse wheel,  and hit 'r' to rotate the image 90 degrees.
+
+   If you don't specify an image file,  a fake image showing color
+gradients is generated.  On Linux,  it'll use 'convert' (ImageMagick)
+to turn JPEGs or other image files into PNMs or PGMs.  On DOS/Windows,
+you have to give it a PNM or PGM file.
+
+   This program relies on the availability of a 2^24+256=16777472-color
+palette and 2^20=1048576 color pairs.  Thus,  any color can be specified,
+and up to a million combinations of foreground and background color.
+In each cell,  an ACS_BBLOCK ('bottom half block') is shown;  the
+bottom half then appears in the foreground color for that character
+cell,  and the upper half in the background color for that cell.  Thus,
+the 'pixels' making up our image are one character wide,  but only
+half a character high.
+
+   We start out with the image scaled to fit entirely within the window.
+The loop below goes through 2 * LINES iterations.  On even passes,  we
+compute RGB values for the pixels that will go into the top half of each
+character cell.  On odd passes,  we're computing the RGB for the bottom
+halves,  and each time one is computed,  we spit out another character.
+(And,  if the colors have changed,  we allocate another color pair.
+So this can chew through as many color pairs as there are character
+cells on the current screen.)    */
+
+double aspect = 1.1;       /* The 'bottom block' (half-height cell character) */
+               /* is _almost_ square,  but is about 10% wider than it is tall */
+
+
+/* PNM files give each pixel as an RGB triplet of bytes.  A width by height
+image consumes exactly width * height * 3 bytes. */
+
+#ifndef ACS_BBLOCK
+   #define ACS_BBLOCK 0x2584
+#endif
+
+static int get_rgb_value( const char *iptr)
+{
+   unsigned char red = (unsigned char)iptr[0];
+   unsigned char grn = (unsigned char)iptr[1];
+   unsigned char blu = (unsigned char)iptr[2];
+
+   return( (int)red | ((int)grn << 8) | ((int)blu << 16));
+}
+
+/* Image rotation isn't done fancily here.  We allocate another array of equal
+size,  copy pixels into it rearranged to their rotated positions,  and copy
+that new array back into the original.  */
+
+static void rotate_pixels_ninety_degrees( const int xsize, const int ysize, char *pixels)
+{
+   int i, j;
+   char *tmp = (char *)malloc( xsize * ysize * 3);
+
+   assert( tmp);
+   for( i = 0; i < ysize; i++)
+      {
+      char *tptr = tmp + (ysize - 1 - i) * 3;
+
+      for( j = xsize; j; j--)
+         {
+         *tptr++ = *pixels++;
+         *tptr++ = *pixels++;
+         *tptr++ = *pixels++;
+         tptr += (ysize - 1) * 3;
+         }
+      }
+   pixels -= xsize * ysize * 3;
+   memcpy( pixels, tmp, xsize * ysize * 3);
+   free( tmp);
+}
+
+static void invert_pixels( const int xsize, const int ysize, char *pixels)
+{
+   char *endpix = pixels + (xsize * ysize - 1) * 3;
+
+   while( endpix > pixels)
+      {
+      char tbuff[3];
+
+      tbuff[0] = pixels[0];  pixels[0] = endpix[0];   endpix[0] = tbuff[0];
+      tbuff[1] = pixels[1];  pixels[1] = endpix[1];   endpix[1] = tbuff[1];
+      tbuff[2] = pixels[2];  pixels[2] = endpix[2];   endpix[2] = tbuff[2];
+      pixels += 3;
+      endpix -= 3;
+      }
+}
+
+static void mirror_pixels_top_bottom( const int xsize, const int ysize, char *pixels)
+{
+   char *tbuff = (char *)malloc( xsize * 3);
+   char *tptr1 = pixels, *tptr2 = pixels + (ysize - 1) * xsize * 3;
+
+   while( tptr2 > tptr1)
+      {
+      memcpy( tbuff, tptr1, 3 * xsize);
+      memcpy( tptr1, tptr2, 3 * xsize);
+      memcpy( tptr2, tbuff, 3 * xsize);
+      tptr1 += xsize * 3;
+      tptr2 -= xsize * 3;
+      }
+   free( tbuff);
+}
+
+static void mirror_pixels_left_right( const int xsize, int ysize, char *pixels)
+{
+   mirror_pixels_top_bottom( xsize, ysize, pixels);
+   invert_pixels( xsize, ysize, pixels);
+}
+
+/* Make a reasonably interesting image with gradients,  circles,
+and hyperbolas */
+
+static void make_fake_image( const char *filename)
+{
+   FILE *ofile = fopen( filename, "wb");
+   int i, j, xsize = 640, ysize = 480, r = 150, r1 = 200;
+   unsigned char buff[3];
+
+   fprintf( ofile, "P6\n%d %d\n255\n", xsize, ysize);
+   for( i = 0; i < ysize; i++)
+      for( j = 0; j < xsize; j++)
+         {
+         const int dx = j - xsize / 2;
+         const int dy = i - ysize / 2;
+
+         buff[0] = (unsigned char)( i * 255 / ysize);
+         buff[1] = (unsigned char)( j * 255 / xsize);
+         if( dx * dx + dy * dy < r1 * r1)
+            buff[1] ^= 0xff;
+         if( abs( dx * dx - dy * dy) > r * r)
+            buff[2] = 0xc0;
+         else
+            buff[2] = 0;
+         fwrite( buff, 3, 1, ofile);
+         }
+   fclose( ofile);
+}
+
+/* Compute dither offset.  See https://en.wikipedia.org/wiki/Ordered_dithering
+for explanation.  This would correspond to a 16x16 'threshold map'.  */
+
+static int calc_dither( int x, int y)
+{
+   int rval = 1;
+
+   while( !(rval & 0x100))
+      {
+      rval <<= 2;
+      rval |= (x & 1) | ((y & 1) << 1);
+      x >>= 1;
+      y >>= 1;
+      }
+   return( rval & 0xff);
+}
+
+/* For 'full-color' palettes,  the mapping from RGB to default palette
+entry is a simple shift by 256.  For 'traditional' 256-color systems
+with a 6x6x6 color cube,  the math is slightly harder.  Dithering is
+used to make the results marginally less ugly. */
+
+static int find_in_palette( const int rgb, const int dither)
+{
+   if( COLORS > 0x100000)
+      return( rgb + 256);
+   else
+      {        /* find entry in 6x6x6 color cube */
+      const int red = (rgb & 0xff);
+      const int grn = ((rgb >> 8) & 0xff);
+      const int blu = ((rgb >> 16) & 0xff);
+
+      return( 16 + ((blu * 5 + dither) / 256)
+                 + ((grn * 5 + dither) / 256) * 6
+                 + ((red * 5 + dither) / 256) * 36);
+      }
+}
+
+#if defined( __linux)
+    const char *temp_image_name = "/tmp/ickywax.pnm";
+#else
+    const char *temp_image_name = "ickywax.pnm";
+#endif
+
+int main( const int argc, const char *argv[])
+{
+   FILE *ifile;
+   int xsize, ysize;
+   char *pixels, buff[100];
+   const char *filename = temp_image_name;
+   const char *filename_to_show = temp_image_name;
+   int c = 0, i, bytes_per_pixel = 3;
+   double scale = 0., xpix = 0., ypix = 0.;
+   bool show_help = TRUE;
+
+   for( i = 1; i < argc; i++)
+      if( argv[i][0] == '-')
+         switch( argv[i][1])
+            {
+            case 'a':
+               aspect = atof( argv[i] + 2);
+               break;
+            }
+   if( argc > 1 && argv[1][0] != '-')
+      {
+      filename_to_show = argv[1];
+#ifdef CONVERT_IMAGES
+      snprintf( buff, sizeof( buff), "convert %s %s", argv[1], temp_image_name);
+      if( system( buff))
+         {
+         printf( "Couldn't convert %s\n", filename);
+         return( -1);
+         }
+#else
+      filename = argv[1];
+      temp_image_name = NULL;
+#endif
+      }
+   else
+      make_fake_image( temp_image_name);
+   ifile = fopen( filename, "rb");
+   if( !ifile)
+      {
+      printf( "'%s' not opened\n", filename_to_show);
+      return( -2);
+      }
+   if( !fgets( buff, sizeof( buff), ifile) || *buff != 'P'
+               || buff[1] > '6' || buff[1] < '5')
+      {
+      printf( "'%s' was not a .pnm file\n", filename_to_show);
+      return( -3);
+      }
+   if( buff[1] == '5')
+      bytes_per_pixel = 1;
+   if( fgets( buff, sizeof( buff), ifile))
+      sscanf( buff, "%d %d", &xsize, &ysize);
+   else
+      {
+      fprintf( stderr, "Unable to read '%s'\n", filename_to_show);
+      return( -9);
+      }
+   if( !fgets( buff, sizeof( buff), ifile))
+      return( -4);
+   pixels = (char *)calloc( xsize * ysize, 3);
+   assert( pixels);
+   if( !fread( pixels, xsize * ysize, bytes_per_pixel, ifile))
+      {
+      printf( "%d x %d pixels not read\n", xsize, ysize);
+      return( -5);
+      }
+   fclose( ifile);
+   if( temp_image_name)
+#ifdef _WIN32
+      _unlink( temp_image_name);
+#else
+      unlink( temp_image_name);
+#endif
+   if( bytes_per_pixel == 1)     /* expand grayscale to RGB */
+      for( i = xsize * ysize - 1; i >= 0; i--)
+         pixels[i * 3] = pixels[i * 3 + 1] = pixels[i * 3 + 2] = pixels[i];
+   initscr( );
+   start_color( );
+   cbreak( );
+   noecho();
+   keypad( stdscr, 1);
+   mousemask( ALL_MOUSE_EVENTS | REPORT_MOUSE_POSITION, NULL);
+   while( c != 27 && c != 'q')
+      {
+      int *xloc = (int *)calloc( 2 * COLS, sizeof( int));
+      int *idxs = xloc + COLS;
+      int prev_idx = -1, prev_low_idx = -1;
+      int j, pair_num = 16;
+      MEVENT mouse_event;
+      double xpix1, ypix1;
+
+      assert( xloc);
+      memset( &mouse_event, 0, sizeof( MEVENT));
+      if( !scale)       /* recompute scale */
+         {
+         double scale1 = (double)xsize / (double)COLS;
+
+         scale = (double)ysize / ((double)LINES * 2. * aspect);
+         if( scale < scale1)
+            scale = scale1;
+         xpix = (double)xsize / 2.;
+         ypix = (double)ysize / 2.;
+         }
+      for( i = 0; i < COLS; i++)
+         xloc[i] = (int)( xpix + (double)i * scale) - (int)( COLS * scale) / 2;
+      erase( );
+      for( j = 0; j < LINES * 2; j++)
+         {
+         const int yloc = (int)( ypix + (double)j * scale * aspect)
+                        - (int)( LINES * scale * aspect);
+         const char *pptr = pixels + yloc * 3 * xsize;
+
+         if( yloc < 0 || yloc >= ysize)
+            pptr = NULL;
+         for( i = 0; i < COLS && xloc[i] < 0; i++)
+            ;
+         if( !(j % 2))
+            {
+            memset( idxs, 0, COLS * sizeof( int));
+            if( pptr)
+               for( ; i < COLS && xloc[i] < xsize; i++)
+                  idxs[i] = find_in_palette( get_rgb_value( pptr + xloc[i] * 3),
+                                    calc_dither( i, j));
+            }
+         else
+            {
+            move( j / 2, i);
+            for( ; i < COLS && xloc[i] < xsize; i++)
+               {
+               int low_rgb = (pptr ? get_rgb_value( pptr + xloc[i] * 3) : 0);
+               int low_idx = find_in_palette( low_rgb, calc_dither( i, j));
+
+               if( low_idx != prev_low_idx || idxs[i] != prev_idx)
+                  {
+#ifdef __PDCURSES__
+                  init_extended_pair( pair_num, low_idx, idxs[i]);
+#else
+                  init_pair( pair_num, low_idx, idxs[i]);
+#endif
+                  attrset( COLOR_PAIR( pair_num));
+                  pair_num++;
+                  prev_low_idx = low_idx;
+                  prev_idx = idxs[i];
+                  }
+               addch( ACS_BBLOCK);
+               }
+            }
+         }
+      free( xloc);
+      attrset( 0);
+      mvaddstr( LINES - 1, 0, filename_to_show);
+      snprintf( buff, sizeof( buff), " %d x %d pixels", xsize, ysize);
+      addstr( buff);
+      snprintf( buff, sizeof( buff), "     %d color pairs used", pair_num);
+      addstr( buff);
+      if( show_help)
+         {
+         mvaddstr( LINES - 8, 0, "Home key sets default view (image fit to screen)");
+         mvaddstr( LINES - 7, 0, "Click mouse to pan;  scroll wheel to zoom in/out");
+         mvaddstr( LINES - 6, 0, "Cursor keys also pan; * zooms in, / zooms out");
+         mvaddstr( LINES - 5, 0, "'r' rotates clockwise, 'R' CCW, 'i' inverts image");
+         mvaddstr( LINES - 4, 0, "'m' mirrors image left/right, 'f' flips top/bottom");
+         mvaddstr( LINES - 3, 0, "Any other key causes this help to appear");
+         show_help = FALSE;
+         }
+      refresh();
+      xpix1 = xpix;
+      ypix1 = ypix;
+      do
+         {
+         c = getch( );
+         if( c == KEY_MOUSE)
+            {
+            getmouse( &mouse_event);
+            xpix1 = xpix + (double)(mouse_event.x - COLS / 2) * scale;
+            ypix1 = ypix + (double)(mouse_event.y - LINES / 2) * scale * 2. * aspect;
+            if( mouse_event.bstate & REPORT_MOUSE_POSITION)
+               {
+               c = -1;
+               snprintf( buff, sizeof( buff), "x=%5d y=%5d", (int)xpix1, (int)ypix1);
+               mvaddstr( LINES - 2, 0, buff);
+               }
+            }
+         }
+         while( c == -1);
+      switch( c)
+         {
+         case KEY_MOUSE:
+            {
+            double rescale = 1.;
+
+            if( mouse_event.bstate & BUTTON4_PRESSED)
+               rescale = 1. / 1.2;
+#ifdef __PDCURSES__
+            else if( mouse_event.bstate & BUTTON5_PRESSED)
+               rescale = 1.2;
+#endif
+            else
+               {
+               xpix = xpix1;
+               ypix = ypix1;
+               }
+            scale *= rescale;
+            xpix += (xpix1 - xpix) * (1. - rescale);
+            ypix += (ypix1 - ypix) * (1. - rescale);
+            }
+            break;
+         case '*':
+            scale /= 1.2;
+            break;
+         case '/':
+            scale *= 1.2;
+            break;
+         case KEY_A1:
+         case KEY_HOME:
+            scale = 0.;       /* recompute/recenter */
+            break;
+         case KEY_UP:
+#ifdef KEY_A2
+         case KEY_A2:
+#endif
+            ypix -= LINES * scale / 2.;
+            break;
+         case KEY_LEFT:
+#ifdef KEY_B1
+         case KEY_B1:
+#endif
+            xpix -= COLS * scale / 4.;
+            break;
+         case KEY_DOWN:
+#ifdef KEY_C2
+         case KEY_C2:
+#endif
+            ypix += LINES * scale / 2.;
+            break;
+         case KEY_RIGHT:
+#ifdef KEY_B3
+         case KEY_B3:
+#endif
+            xpix += COLS * scale / 4.;
+            break;
+#ifdef KEY_RESIZE
+         case KEY_RESIZE:
+            resize_term( 0, 0);
+            break;
+#endif
+         case 'r':
+         case 'R':
+            {
+            const int tval = xsize;
+
+            rotate_pixels_ninety_degrees( xsize, ysize, pixels);
+            if( c == 'R')
+               invert_pixels( xsize, ysize, pixels);
+            xsize = ysize;
+            ysize = tval;
+            scale = 0.;
+            }
+            break;
+         case 'i':
+            invert_pixels( xsize, ysize, pixels);
+            break;
+         case 'f':
+            mirror_pixels_top_bottom( xsize, ysize, pixels);
+            ypix = ysize - ypix;
+            break;
+         case 'm':
+            mirror_pixels_left_right( xsize, ysize, pixels);
+            xpix = xsize - xpix;
+            break;
+         default:
+            show_help = TRUE;
+            break;
+         }
+      }
+   free( pixels);
+   endwin();
+#ifdef PDCURSES
+   delscreen( SP);
+#endif
+   return( 0);
+}
diff --git a/lib/PDCursesMod/demos/ptest.c b/lib/PDCursesMod/demos/ptest.c
new file mode 100644
index 00000000000..3f02f3a9265
--- /dev/null
+++ b/lib/PDCursesMod/demos/ptest.c
@@ -0,0 +1,309 @@
+#include <curses.h>
+#include <panel.h>
+#include <stdlib.h>
+
+PANEL *p1, *p2, *p3, *p4, *p5;
+WINDOW *w4, *w5;
+
+long nap_msec = 1;
+
+char *mod[] =
+{
+    "test ", "TEST ", "(**) ", "*()* ", "<--> ", "LAST "
+};
+
+void pflush(void)
+{
+    update_panels();
+    doupdate();
+}
+
+void sizecheck(void)
+{
+    if (COLS < 70 || LINES < 23)
+    {
+        printw("A window at least 70x23 is required for this demo");
+        refresh();
+        napms(5000);
+        endwin();
+        exit(-1);
+    }
+}
+
+void backfill(void)
+{
+    int y, x;
+
+    erase();
+
+    for (y = 0; y < LINES - 1; y++)
+        for (x = 0; x < COLS; x++)
+            printw("%d", (y + x) % 10);
+}
+
+void wait_a_while(long msec)
+{
+    int c;
+
+    if (msec != 1)
+        timeout(msec);
+
+    c = getch();
+
+#ifdef KEY_RESIZE
+    if (c == KEY_RESIZE)
+    {
+# ifdef PDCURSES
+        resize_term(0, 0);
+# endif
+        sizecheck();
+        backfill();
+    }
+    else
+#endif
+    if (c == 'q')
+    {
+        endwin();
+        exit(1);
+    }
+}
+
+void saywhat(const char *text)
+{
+    mvprintw(LINES - 1, 0, "%-20.20s", text);
+}
+
+/* mkpanel - alloc a win and panel and associate them */
+
+PANEL *mkpanel(int rows, int cols, int tly, int tlx)
+{
+    WINDOW *win = newwin(rows, cols, tly, tlx);
+    PANEL *pan = (PANEL *)0;
+
+    if (win)
+    {
+        pan = new_panel(win);
+
+        if (!pan)
+            delwin(win);
+    }
+
+    return pan;
+}
+
+void rmpanel(PANEL *pan)
+{
+    WINDOW *win = pan->win;
+
+    del_panel(pan);
+    delwin(win);
+}
+
+void fill_panel(PANEL *pan)
+{
+    WINDOW *win = pan->win;
+    char num = *((char *)pan->user + 1);
+    int y, x, maxy, maxx;
+
+    box(win, 0, 0);
+    mvwprintw(win, 1, 1, "-pan%c-", num);
+    getmaxyx(win, maxy, maxx);
+
+    for (y = 2; y < maxy - 1; y++)
+        for (x = 1; x < maxx - 1; x++)
+            mvwaddch(win, y, x, num);
+}
+
+int main(int argc, char **argv)
+{
+    int itmp, y;
+
+    if (argc > 1 && atol(argv[1]))
+        nap_msec = atol(argv[1]);
+
+#ifdef XCURSES
+    Xinitscr(argc, argv);
+#else
+    initscr();
+#endif
+
+    keypad(stdscr, TRUE);
+    sizecheck();
+    backfill();
+
+    for (y = 0; y < 5; y++)
+    {
+        p1 = mkpanel(10, 10, 0, 0);
+        set_panel_userptr(p1, "p1");
+
+        p2 = mkpanel(14, 14, 5, 5);
+        set_panel_userptr(p2, "p2");
+
+        p3 = mkpanel(6, 8, 12, 12);
+        set_panel_userptr(p3, "p3");
+
+        p4 = mkpanel(10, 10, 10, 30);
+        w4 = panel_window(p4);
+        set_panel_userptr(p4, "p4");
+
+        p5 = mkpanel(10, 10, 13, 37);
+        w5 = panel_window(p5);
+        set_panel_userptr(p5, "p5");
+
+        fill_panel(p1);
+        fill_panel(p2);
+        fill_panel(p3);
+        fill_panel(p4);
+        fill_panel(p5);
+        hide_panel(p4);
+        hide_panel(p5);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("h3 s1 s2 s4 s5;");
+        move_panel(p1, 0, 0);
+        hide_panel(p3);
+        show_panel(p1);
+        show_panel(p2);
+        show_panel(p4);
+        show_panel(p5);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("s1;");
+        show_panel(p1);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("s2;");
+        show_panel(p2);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("m2;");
+        move_panel(p2, 10, 10);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("s3;");
+        show_panel(p3);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("m3;");
+        move_panel(p3, 5, 5);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("b3;");
+        bottom_panel(p3);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("s4;");
+        show_panel(p4);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("s5;");
+        show_panel(p5);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("t3;");
+        top_panel(p3);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("t1;");
+        top_panel(p1);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("t2;");
+        top_panel(p2);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("t3;");
+        top_panel(p3);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("t4;");
+        top_panel(p4);
+        pflush();
+        wait_a_while(nap_msec);
+
+        for (itmp = 0; itmp < 6; itmp++)
+        {
+            saywhat("m4;");
+            mvwaddstr(w4, 3, 1, mod[itmp]);
+            move_panel(p4, 4, itmp * 10);
+            mvwaddstr(w5, 4, 1, mod[itmp]);
+            pflush();
+            wait_a_while(nap_msec);
+
+            saywhat("m5;");
+            mvwaddstr(w4, 4, 1, mod[itmp]);
+            move_panel(p5, 7, itmp * 10 + 6);
+            mvwaddstr(w5, 3, 1, mod[itmp]);
+            pflush();
+            wait_a_while(nap_msec);
+        }
+
+        saywhat("m4;");
+        move_panel(p4, 4, itmp * 10);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("t5;");
+        top_panel(p5);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("t2;");
+        top_panel(p2);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("t1;");
+        top_panel(p1);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("d2;");
+        rmpanel(p2);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("h3;");
+        hide_panel(p3);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("d1;");
+        rmpanel(p1);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("d4; ");
+        rmpanel(p4);
+        pflush();
+        wait_a_while(nap_msec);
+
+        saywhat("d5; ");
+        rmpanel(p5);
+        pflush();
+        wait_a_while(nap_msec);
+
+        if (nap_msec == 1)
+            break;
+
+        nap_msec = 100L;
+    }
+
+    endwin();
+
+    return 0;
+}   /* end of main */
diff --git a/lib/PDCursesMod/demos/rain.c b/lib/PDCursesMod/demos/rain.c
new file mode 100644
index 00000000000..52349b48513
--- /dev/null
+++ b/lib/PDCursesMod/demos/rain.c
@@ -0,0 +1,161 @@
+/****************************************************************************
+ * Copyright (c) 2002 Free Software Foundation, Inc.                        *
+ *                                                                          *
+ * Permission is hereby granted, free of charge, to any person obtaining a  *
+ * copy of this software and associated documentation files (the            *
+ * "Software"), to deal in the Software without restriction, including      *
+ * without limitation the rights to use, copy, modify, merge, publish,      *
+ * distribute, distribute with modifications, sublicense, and/or sell       *
+ * copies of the Software, and to permit persons to whom the Software is    *
+ * furnished to do so, subject to the following conditions:                 *
+ *                                                                          *
+ * The above copyright notice and this permission notice shall be included  *
+ * in all copies or substantial portions of the Software.                   *
+ *                                                                          *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
+ * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
+ *                                                                          *
+ * Except as contained in this notice, the name(s) of the above copyright   *
+ * holders shall not be used in advertising or otherwise to promote the     *
+ * sale, use or other dealings in this Software without prior written       *
+ * authorization.                                                           *
+ ****************************************************************************/
+
+#include <curses.h>
+#include <stdlib.h>
+#include <time.h>
+
+/* rain 1980-11-03 EPS/CITHEP */
+
+static int next_j(int j)
+{
+    if (j == 0)
+        j = 4;
+    else
+        --j;
+
+    if (has_colors())
+    {
+        int z = rand() % 3;
+        chtype color = COLOR_PAIR(z);
+
+        if (z)
+            color |= A_BOLD;
+
+        attrset(color);
+    }
+
+    return j;
+}
+
+#define INTENTIONALLY_UNUSED_PARAMETER( param) (void)(param)
+
+int main(int argc, char *argv[])
+{
+    time_t seed;
+    int x, y, j, r, c;
+    static int xpos[5], ypos[5];
+
+#ifdef XCURSES
+    Xinitscr(argc, argv);
+#else
+    INTENTIONALLY_UNUSED_PARAMETER( argv);
+    INTENTIONALLY_UNUSED_PARAMETER( argc);
+    initscr();
+#endif
+    seed = time((time_t *)0);
+    srand( (unsigned)seed);
+
+    if (has_colors())
+    {
+        short bg = COLOR_BLACK;
+
+        start_color();
+
+#if defined(NCURSES_VERSION) || (defined(PDC_BUILD) && PDC_BUILD > 3000)
+        if (use_default_colors() == OK)
+            bg = -1;
+#endif
+        init_pair(1, COLOR_BLUE, bg);
+        init_pair(2, COLOR_CYAN, bg);
+    }
+
+    nl();
+    noecho();
+    curs_set(0);
+    timeout(0);
+    keypad(stdscr, TRUE);
+
+    r = LINES - 4;
+    c = COLS - 4;
+
+    for (j = 5; --j >= 0;)
+    {
+        xpos[j] = rand() % c + 2;
+        ypos[j] = rand() % r + 2;
+    }
+
+    for (j = 0;;)
+    {
+        x = rand() % c + 2;
+        y = rand() % r + 2;
+
+        mvaddch(y, x, '.');
+
+        mvaddch(ypos[j], xpos[j], 'o');
+
+        j = next_j(j);
+        mvaddch(ypos[j], xpos[j], 'O');
+
+        j = next_j(j);
+        mvaddch(ypos[j] - 1, xpos[j], '-');
+        mvaddstr(ypos[j], xpos[j] - 1, "|.|");
+        mvaddch(ypos[j] + 1, xpos[j], '-');
+
+        j = next_j(j);
+        mvaddch(ypos[j] - 2, xpos[j], '-');
+        mvaddstr(ypos[j] - 1, xpos[j] - 1, "/ \\");
+        mvaddstr(ypos[j], xpos[j] - 2, "| O |");
+        mvaddstr(ypos[j] + 1, xpos[j] - 1, "\\ /");
+        mvaddch(ypos[j] + 2, xpos[j], '-');
+
+        j = next_j(j);
+        mvaddch(ypos[j] - 2, xpos[j], ' ');
+        mvaddstr(ypos[j] - 1, xpos[j] - 1, "   ");
+        mvaddstr(ypos[j], xpos[j] - 2, "     ");
+        mvaddstr(ypos[j] + 1, xpos[j] - 1, "   ");
+        mvaddch(ypos[j] + 2, xpos[j], ' ');
+
+        xpos[j] = x;
+        ypos[j] = y;
+
+        switch (getch())
+        {
+        case 'q':
+        case 'Q':
+            curs_set(1);
+            endwin();
+            return EXIT_SUCCESS;
+        case 's':
+            nodelay(stdscr, FALSE);
+            break;
+        case ' ':
+            nodelay(stdscr, TRUE);
+#ifdef KEY_RESIZE
+            break;
+        case KEY_RESIZE:
+# ifdef PDCURSES
+            resize_term(0, 0);
+# endif
+            r = LINES - 4;
+            c = COLS - 4;
+#endif
+        }
+        napms(50);
+    }
+}
diff --git a/lib/PDCursesMod/demos/simplemenu.c b/lib/PDCursesMod/demos/simplemenu.c
new file mode 100644
index 00000000000..c5d238cfa75
--- /dev/null
+++ b/lib/PDCursesMod/demos/simplemenu.c
@@ -0,0 +1,176 @@
+#include <curses.h>
+#include <stdlib.h>
+
+#define str(s) #s
+#define xstr(s) str(s)
+#define MAX_LEN 30
+
+typedef struct menuentry {
+	int number;
+	char *label;
+
+	struct menuentry *previous;
+	struct menuentry *next;
+} menuentry;
+
+typedef struct menustate {
+	WINDOW *window;
+	WINDOW *menu;
+
+	menuentry *first_entry;
+	menuentry *last_entry;
+} menustate;
+
+void redrawitem(menustate *state, int i, bool selected) {
+	char item[MAX_LEN+3];
+	menuentry *iter = state->first_entry;
+
+	if (selected) {
+		wattron(state->menu, A_STANDOUT);
+	}
+
+	while (iter->number != i) {
+		if (!iter->next) { return; }
+		iter = iter->next;
+	}
+
+	sprintf(item, " %-" xstr(MAX_LEN) "s ", iter->label);
+	mvwprintw(state->menu, iter->number-1, 0, "%s", item);
+
+	if (selected) {
+		wattroff(state->menu, A_STANDOUT);
+	}
+
+	//touchwin(state->window);
+}
+
+void printmenu(menustate *state) {
+	char item[MAX_LEN+3];
+	menuentry *iter = state->first_entry;
+
+	while (iter) {
+		sprintf(item, " %-" xstr(MAX_LEN) "s ", iter->label);
+		mvwprintw(state->menu, iter->number-1, 0, "%s", item);
+		iter = iter->next;
+	}
+
+	redrawitem(state, 1, TRUE);
+}
+
+menuentry *init_entry(char* label, menuentry *previous) {
+	menuentry *entry = malloc(sizeof(menuentry));
+	entry->label = label;
+
+	if (previous) {
+		entry->number = previous->number + 1;
+		previous->next = entry;
+	}
+	else {
+		entry->number = 1;
+	}
+
+	entry->previous = previous;
+	entry->next = NULL;
+
+	return entry;
+}
+
+int menu_num_entries(menustate *state) {
+	if (state->last_entry) {
+		return state->last_entry->number;
+	}
+	else {
+		return 0;
+	}
+}
+
+void add_entry(menustate *state, char* label) {
+	menuentry *entry = init_entry(label, state->last_entry);
+	if (!state->first_entry) {
+		state->first_entry = entry;
+	}
+	state->last_entry = entry;
+}
+
+int main(void) {
+	menustate state = {
+		.last_entry = NULL,
+		.first_entry = NULL,
+	};
+	int ch = 0;
+	int curr = 1;
+	int menu_width = MAX_LEN;
+	int menu_height = 0;
+
+	initscr();
+
+	add_entry(&state, "First entry!!");
+	add_entry(&state, "Second entry");
+	add_entry(&state, "Third entry");
+	add_entry(&state, "Fourth entry");
+
+	menu_height = menu_num_entries(&state);
+
+	// Creates the "canvas" for the menu, centered.
+	state.window = newwin(
+		menu_height + 2 + 2,
+		menu_width + 4,
+		0, 0
+	);
+
+	state.menu = derwin(
+		state.window,
+		menu_height,
+		menu_width + 2,
+		3, 1
+	);
+	syncok(state.menu, TRUE);
+
+	mvwin(
+		state.window,
+		(LINES-menu_height)/2,
+		(COLS-menu_width)/2
+	);
+
+	// Draw a box around the window
+	box(state.window, 0, 0);
+	mvwaddch(state.window, 2, 0, ACS_LTEE);
+	whline(state.window, 0, menu_width+2);
+	mvwaddch(state.window, 2, menu_width+3, ACS_RTEE);
+
+	// Silence inputs
+	noecho();
+	curs_set(0);
+
+	// Enables key-based navigation
+	keypad(state.window, TRUE);
+
+	printmenu(&state);
+
+	while((ch = wgetch(state.window)) != 'q'){
+
+		switch(ch) {
+			case KEY_UP:
+				redrawitem(&state, curr, FALSE);
+				curr--;
+				curr = (curr<1) ? menu_num_entries(&state) : curr;
+				redrawitem(&state, curr, TRUE);
+				break;
+			case KEY_DOWN:
+				redrawitem(&state, curr, FALSE);
+				curr++;
+				curr = (curr > menu_num_entries(&state)) ? 1 : curr;
+				redrawitem(&state, curr, TRUE);
+				break;
+			case '\n':
+				mvwprintw(state.window, 1, 2, "hi '%d' ", curr);
+				break;
+		}
+	}
+
+	// Cleanup
+	delwin(state.menu);
+	delwin(state.window);
+	wrefresh(stdscr);
+	endwin();
+}
diff --git a/lib/PDCursesMod/demos/speed.c b/lib/PDCursesMod/demos/speed.c
new file mode 100644
index 00000000000..c4401223810
--- /dev/null
+++ b/lib/PDCursesMod/demos/speed.c
@@ -0,0 +1,102 @@
+#include <stdio.h>
+#include <curses.h>
+
+/* PDCurses/ncurses speed test.  Initializes *curses,  displays
+semi-random numbers on the screen for 3000 milliseconds = 3 seconds,
+and then tells you how many frames per second you got (i.e.,  how
+many complete screen refreshes).
+
+   Results on my somewhat elderly machine,  all in Xubuntu 18.04 :
+
+SDL1 : 140 fps in wide mode,  340 in non-wide
+SDL2: 233 fps in wide mode, 624 fps in non-wide mode
+X11 wide mode: 180 fps first time,  800 fps subsequently
+ncurses : 3700 fps in wide mode
+VT : 3600 fps in wide mode,  4500 fps in non-wide mode
+WinGUI : 280 fps,  both modes (through Wine)
+WinCon : 840 fps,  wide mode;  75 fps in non-wide
+DOS (with DosBox) : 223 fps
+DOSVGA (with DosBox) : 50 fps
+
+   SDL2 uses TrueType (R) fonts in wide mode,  as opposed to simple
+bitmapped fonts in 8-bit mode.  So its ability to be blazingly fast
+in the latter is unsurprising.
+
+   X11,  I'll guess,  has some sort of optimization for wide-char fonts
+(because they get more use),  and perhaps some sort of caching that
+would account for why the first load is a little slower.
+
+   Dunno why Win32 console has such a huge variation,  and haven't
+tested it under "real" Windows.
+*/
+
+#define INTENTIONALLY_UNUSED_PARAMETER( param) (void)(param)
+
+/* ftime() is consided obsolete.  But it's all we have for
+millisecond precision on older compilers/systems.  We'll
+use gettimeofday() when available.        */
+
+#if defined(__TURBOC__) || defined(__EMX__) || defined(__DJGPP__) || \
+    defined( __DMC__) || defined(__WATCOMC__) || defined(_MSC_VER)
+#include <sys/timeb.h>
+
+static long millisec_clock( )
+{
+    struct timeb t;
+
+    ftime( &t);
+    return( (long)t.time * 1000L + (long)t.millitm);
+}
+#else
+#include <sys/time.h>
+
+static long millisec_clock( )
+{
+    struct timeval t;
+
+    gettimeofday( &t, NULL);
+    return( t.tv_sec * 1000 + t.tv_usec / 1000);
+}
+#endif
+
+int main( const int argc, const char **argv)
+{
+    unsigned n_frames = 0;
+    long t0;
+
+    INTENTIONALLY_UNUSED_PARAMETER( argv);
+    INTENTIONALLY_UNUSED_PARAMETER( argc);
+    resize_term( 30, 90);
+    initscr();
+    cbreak( );
+    noecho();
+    refresh();
+    keypad( stdscr, 1);
+    nodelay(stdscr, TRUE);
+    t0 = millisec_clock( );
+    while( millisec_clock( ) - t0 < 3000L && getch( ) != 'q')
+      {
+      char buff[11];
+      int i, j;
+      const int lines = 25, cols = 80;
+
+      n_frames++;
+      sprintf( buff, " %9u", (n_frames * 31415926u) % 1000000000u);
+      attrset(A_BOLD);
+      for( i = 0; i < lines; i++)
+         {
+         move( i, 0);
+         if( i == (int)n_frames % lines)
+            attrset( A_NORMAL);
+         for( j = 0; j + 10 < cols; j += 10)
+            addstr( buff);
+         }
+      }
+    nodelay(stdscr, FALSE);
+    move( LINES / 2, COLS / 2 - 20);
+    printw( "  %u frames/sec  ", n_frames / 3);
+    getch( );
+    endwin();
+    printf( "%u frames per second\n", n_frames / 3);
+    return( 0);
+}
diff --git a/lib/PDCursesMod/demos/test_pan.c b/lib/PDCursesMod/demos/test_pan.c
new file mode 100644
index 00000000000..bcb23f02d39
--- /dev/null
+++ b/lib/PDCursesMod/demos/test_pan.c
@@ -0,0 +1,188 @@
+/* Demonstrates/tests panel library.  Based loosely on example from
+
+http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/panels.html
+
+   Should look like this when you run it :
+
+            -------- Top of screen -----------
+ Hit 1-3 to move panels 1-3 to the top
+ Cursor keys move the top panel
+ Tab toggles display of top panel
+ Click on a panel to bring to top/send to bottom
+ Escape or q exits the program
+
+    
+        
+            
+                                                  
+                                                  
+                                                  
+                                                  
+                Window 3                          
+                                                  
+                                              
+                                               
+              
+*/
+
+#define PDC_NCMOUSE
+
+#include <panel.h>
+#include <stdio.h>
+#include <assert.h>
+
+#if !defined( __PDCURSES__) && !NCURSES_SP_FUNCS
+      /* Older ncurses may lack ceiling_panel() and ground_panel() */
+
+PANEL *ceiling_panel( SCREEN *sp)
+{
+   return( panel_below( NULL));
+}
+
+PANEL *ground_panel( SCREEN *sp)
+{
+   return( panel_above( NULL));
+}
+#endif         /* #ifndef NCURSES_SP_FUNCS */
+
+/* To determine on which panel (if any) the mouse was clicked,
+cycle through panel_below() until you find that (x, y) is within
+the window extents,  or you get a NULL panel.         */
+
+PANEL *panel_from_point( const int y, const int x)
+{
+   PANEL *curr = NULL;
+
+   while( (curr = panel_below( curr)) != NULL)
+      {
+      WINDOW *win = panel_window( curr);
+      const int x0 = getbegx( win), y0 = getbegy( win);
+
+      if( x >= x0 && y >= y0 && x - x0 < getmaxx( win)
+                             && y - y0 < getmaxy( win))
+         return( curr);
+      }
+   return( NULL);
+}
+
+int main()
+{
+   WINDOW *my_wins[3];
+   PANEL  *my_panels[3];
+   int lines = 10, cols = 40, y = 7, x = 4, i, c = 0;
+
+   initscr();
+   cbreak();
+   noecho();
+   keypad( stdscr, 1);
+   mousemask( ALL_MOUSE_EVENTS, NULL);
+
+   /* Create windows for the panels */
+   my_wins[0] = newwin(lines, cols, y, x);
+   my_wins[1] = newwin(lines, cols, y + 1, x + 5);
+   my_wins[2] = newwin(lines, cols, y + 2, x + 10);
+
+   /*
+    * Create borders around the windows so that you can see the effect
+    * of panels
+    */
+   for(i = 0; i < 3; ++i)
+      box(my_wins[i], 0, 0);
+
+   /* Attach a panel to each window */    /* Order is bottom up */
+   my_panels[0] = new_panel(my_wins[0]);  /* Push 0, order: stdscr-0 */
+   my_panels[1] = new_panel(my_wins[1]);  /* Push 1, order: stdscr-0-1 */
+   my_panels[2] = new_panel(my_wins[2]);  /* Push 2, order: stdscr-0-1-2 */
+   for( i = 0; i < 3; i++)
+      {
+      char text[20];
+
+      snprintf( text, sizeof( text), "Window %d", i + 1);
+      mvwaddstr( my_wins[i], 5, 5, text);
+      }
+   mvaddstr( 1, 1, "Hit 1-3 to move panels 1-3 to the top");
+   mvaddstr( 2, 1, "Cursor keys move the top panel");
+   mvaddstr( 3, 1, "Tab toggles display of top panel");
+   mvaddstr( 4, 1, "Click on a panel to bring to top/send to bottom");
+   mvaddstr( 5, 1, "Escape or q exits the program");
+
+   /* Update the stacking order. 2nd panel will be on top */
+   while( c != 27 && c != 'q')
+      {
+      PANEL *curr_top = ceiling_panel( NULL);
+
+      assert( curr_top);
+      update_panels();
+
+      /* Show it on the screen */
+      doupdate();
+
+      c = getch();
+      switch( c)
+         {
+         case '1': case '2': case '3':
+            top_panel( my_panels[c - '1']);
+            break;
+         case 9: case 'h':
+#ifdef __PDCURSES__
+            if( panel_hidden( curr_top) == OK)
+#else
+            if( panel_hidden( curr_top) == TRUE)
+#endif
+               show_panel( curr_top);
+            else
+               hide_panel( curr_top);
+            break;
+         case KEY_LEFT: case KEY_RIGHT: case KEY_UP: case KEY_DOWN:
+            {
+            WINDOW *win = panel_window( curr_top);
+
+            x = getbegx( win);
+            y = getbegy( win);
+            if( c == KEY_LEFT)
+               x--;
+            if( c == KEY_RIGHT)
+               x++;
+            if( c == KEY_UP)
+               y--;
+            if( c == KEY_DOWN)
+               y++;
+            if( move_panel( curr_top, y, x) == ERR)
+               flash( );
+            }
+            break;
+         case KEY_MOUSE:
+            {
+            MEVENT mouse_event;
+            PANEL *clicked_on_panel;
+
+            getmouse( &mouse_event);
+            clicked_on_panel = panel_from_point( mouse_event.y, mouse_event.x);
+            if( clicked_on_panel)
+               {
+               if( clicked_on_panel == ceiling_panel( NULL))  /* it's already on top */
+                  bottom_panel( clicked_on_panel);
+               else
+                  top_panel( clicked_on_panel);
+               }
+            }
+            break;
+         case KEY_RESIZE:
+            resize_term( 0, 0);
+            break;
+         default:
+            flash( );
+            break;
+         }
+      }
+   endwin();
+   for( i = 0; i < 3; ++i)
+      {
+      del_panel( my_panels[i]);
+      delwin( my_wins[i]);
+      }
+#ifdef PDCURSES
+    delscreen( SP);
+#endif
+    return( 0);
+}
diff --git a/lib/PDCursesMod/demos/testcurs.c b/lib/PDCursesMod/demos/testcurs.c
new file mode 100644
index 00000000000..4537986683a
--- /dev/null
+++ b/lib/PDCursesMod/demos/testcurs.c
@@ -0,0 +1,1612 @@
+/*
+ * This is a test program for PDCurses. Originally by
+ * John Burnell <johnb@kea.am.dsir.govt.nz>
+ *
+ *  wrs (1993-05-28) -- modified to be consistent (perform identically)
+ *                      with either PDCurses or under Unix System V, R4
+ */
+
+#ifndef _XOPEN_SOURCE_EXTENDED
+# define _XOPEN_SOURCE_EXTENDED 1
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <curses.h>
+
+#ifdef WACS_S1
+# define HAVE_WIDE 1
+#else
+# define HAVE_WIDE 0
+#endif
+
+#include <locale.h>
+
+#if HAVE_WIDE
+# include <wchar.h>
+#endif
+
+#if defined(PDCURSES) && !defined(XCURSES)
+# define HAVE_RESIZE 1
+#else
+# define HAVE_RESIZE 0
+#endif
+
+#ifdef A_COLOR
+# define HAVE_COLOR 1
+#else
+# define HAVE_COLOR 0
+#endif
+
+#ifdef PDCURSES
+# define HAVE_CLIPBOARD 1
+#else
+# define HAVE_CLIPBOARD 0
+#endif
+
+void inputTest(WINDOW *);
+void scrollTest(WINDOW *);
+void introTest(WINDOW *);
+int initTest(WINDOW **, int, char **);
+void outputTest(WINDOW *);
+void padTest(WINDOW *);
+void acsTest(WINDOW *);
+void attrTest(WINDOW *);
+
+#if HAVE_COLOR
+void colorTest(WINDOW *);
+#endif
+
+#if HAVE_RESIZE
+void resizeTest(WINDOW *);
+#endif
+
+#if HAVE_CLIPBOARD
+void clipboardTest(WINDOW *);
+#endif
+
+#if HAVE_WIDE
+void wideTest(WINDOW *);
+#endif
+
+void display_menu(int, int);
+
+struct commands
+{
+    const char *text;
+    void (*function)(WINDOW *);
+};
+
+typedef struct commands COMMAND;
+
+#define INTENTIONALLY_UNUSED_PARAMETER( param) (void)(param)
+#define MAX_OPTIONS (7 + HAVE_COLOR + HAVE_RESIZE + HAVE_CLIPBOARD + HAVE_WIDE)
+
+COMMAND command[MAX_OPTIONS] =
+{
+    {"Intro Test", introTest},
+    {"Pad Test", padTest},
+#if HAVE_RESIZE
+    {"Resize Test", resizeTest},
+#endif
+    {"Scroll Test", scrollTest},
+    {"Input Test", inputTest},
+    {"Output Test", outputTest},
+    {"ACS Test", acsTest},
+    {"Attrib Test", attrTest},
+#if HAVE_COLOR
+    {"Color Test", colorTest},
+#endif
+#if HAVE_CLIPBOARD
+    {"Clipboard Test", clipboardTest},
+#endif
+#if HAVE_WIDE
+    {"Wide Input", wideTest}
+#endif
+};
+
+int width, height;
+
+int main(int argc, char *argv[])
+{
+    WINDOW *win;
+    int key, old_option = -1, new_option = 0;
+    bool quit = FALSE;
+
+    if( argc == 2)
+       setlocale(LC_ALL, argv[1]);
+    else
+       setlocale(LC_ALL, "");
+
+#ifdef PDCURSES
+#ifdef PDC_VER_MAJOR   /* so far only seen in 4.0+ */
+    PDC_set_resize_limits( 20, 50, 70, 200);
+#endif
+#endif
+
+    if (initTest(&win, argc, argv))
+        return 1;
+
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(1, COLOR_WHITE, COLOR_BLUE);
+        wbkgd(win, COLOR_PAIR(1));
+    }
+    else
+#endif
+        wbkgd(win, A_REVERSE);
+
+    erase();
+    display_menu(old_option, new_option);
+
+    while (1)
+    {
+        noecho();
+        keypad(stdscr, TRUE);
+        raw();
+
+        key = getch();
+
+        switch(key)
+        {
+        case 10:
+        case 13:
+        case KEY_ENTER:
+            old_option = -1;
+            erase();
+            refresh();
+            (*command[new_option].function)(win);
+            erase();
+            display_menu(old_option, new_option);
+            break;
+
+        case KEY_PPAGE:
+        case KEY_HOME:
+            old_option = new_option;
+            new_option = 0;
+            display_menu(old_option, new_option);
+            break;
+
+        case KEY_NPAGE:
+        case KEY_END:
+            old_option = new_option;
+            new_option = MAX_OPTIONS - 1;
+            display_menu(old_option, new_option);
+            break;
+
+        case KEY_UP:
+            old_option = new_option;
+            new_option = (new_option == 0) ?
+                new_option : new_option - 1;
+            display_menu(old_option, new_option);
+            break;
+
+        case KEY_DOWN:
+            old_option = new_option;
+            new_option = (new_option == MAX_OPTIONS - 1) ?
+                new_option : new_option + 1;
+            display_menu(old_option, new_option);
+            break;
+#ifdef KEY_RESIZE
+        case KEY_RESIZE:
+# ifdef PDCURSES
+            resize_term(0, 0);
+# endif
+            old_option = -1;
+            erase();
+            display_menu(old_option, new_option);
+            break;
+#endif
+        case 'Q':
+        case 'q':
+            quit = TRUE;
+        }
+
+        if (quit == TRUE)
+            break;
+    }
+
+    delwin(win);
+    endwin();
+#ifdef PDCURSES
+    delscreen( SP);
+#endif
+
+    return 0;
+}
+
+void Continue(WINDOW *win)
+{
+    mvwaddstr(win, 10, 1, " Press any key to continue");
+    wrefresh(win);
+    raw();
+    wgetch(win);
+}
+
+void Continue2(void)
+{
+    move(LINES - 1, 1);
+    clrtoeol();
+    mvaddstr(LINES - 2, 1, " Press any key to continue");
+    refresh();
+    raw();
+    getch();
+}
+
+int initTest(WINDOW **win, int argc, char *argv[])
+{
+#ifdef XCURSES
+    Xinitscr(argc, argv);
+#else
+    INTENTIONALLY_UNUSED_PARAMETER( argv);
+    INTENTIONALLY_UNUSED_PARAMETER( argc);
+    initscr();
+#endif
+#ifdef A_COLOR
+    if (has_colors())
+        start_color();
+#endif
+    /* Create a drawing window */
+
+    width  = 60;
+    height = 13;
+
+    *win = newwin(height, width, (LINES - height) / 2, (COLS - width) / 2);
+
+    if (*win == NULL)
+    {
+        endwin();
+        return 1;
+    }
+
+    return 0;
+}
+
+void introTest(WINDOW *win)
+{
+    werase(win);
+    wmove(win, height / 2 - 5, width / 2);
+    wvline(win, ACS_VLINE, 10);
+    wmove(win, height / 2, width / 2 - 10);
+    whline(win, ACS_HLINE, 20);
+    Continue(win);
+
+    beep();
+    werase(win);
+
+    box(win, ACS_VLINE, ACS_HLINE);
+    wrefresh(win);
+
+    cbreak();
+    mvwaddstr(win, 1, 1,
+        "You should have a rectangle in the middle of the screen");
+    mvwaddstr(win, 2, 1, "You should have heard a beep");
+    Continue(win);
+
+    flash();
+    mvwaddstr(win, 3, 1, "You should have seen a flash");
+    Continue(win);
+}
+
+void scrollTest(WINDOW *win)
+{
+    int i, OldY;
+#if !defined (PDCURSES) && !defined (NCURSES_VERSION)
+    int OldX;
+#endif
+    werase(win);
+    mvwaddstr(win, height - 2, 1, "The window will now scroll slowly");
+    box(win, ACS_VLINE, ACS_HLINE);
+    wrefresh(win);
+    scrollok(win, TRUE);
+    napms(500);
+
+    for (i = 1; i <= height; i++)
+    {
+        napms(150);
+        scroll(win);
+        wrefresh(win);
+    };
+
+#if defined (PDCURSES) || defined (NCURSES_VERSION)
+    OldY = getmaxy(win);
+#else
+    getmaxyx(win, OldY, OldX);
+#endif
+    mvwaddstr(win, 6, 1, "The top of the window will scroll");
+    wmove(win, 1, 1);
+    wsetscrreg(win, 0, 4);
+    box(win, ACS_VLINE, ACS_HLINE);
+    wrefresh(win);
+
+    for (i = 1; i <= 5; i++)
+    {
+        napms(500);
+        scroll(win);
+        wrefresh(win);
+    }
+
+    mvwaddstr(win, 3, 1, "The bottom of the window will scroll");
+    wmove(win, 8, 1);
+    wsetscrreg(win, 5, --OldY);
+    box(win, ACS_VLINE, ACS_HLINE);
+    wrefresh(win);
+
+    for (i = 5; i <= OldY; i++)
+    {
+        napms(300);
+        wscrl(win, -1);
+        wrefresh(win);
+    }
+
+    wsetscrreg(win, 0, OldY);
+}
+
+void inputTest(WINDOW *win)
+{
+    int w, h, bx, by, sw, sh, i, c, num = 0;
+    char buffer[80];
+    WINDOW *subWin;
+    static const char spinner[5] = "/-\\|";
+    int spinner_count = 0;
+
+    wclear(win);
+
+    getmaxyx(win, h, w);
+    getbegyx(win, by, bx);
+
+    sw = w / 3;
+    sh = h / 3;
+
+    if ((subWin = subwin(win, sh, sw, by + h - sh - 2, bx + w - sw - 2))
+        == NULL)
+        return;
+
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(2, COLOR_WHITE, COLOR_RED);
+        wbkgd(subWin, COLOR_PAIR(2) | A_BOLD);
+    }
+    else
+#endif
+        wbkgd(subWin, A_BOLD);
+
+    box(subWin, ACS_VLINE, ACS_HLINE);
+    wrefresh(win);
+
+    nocbreak();
+
+    wclear (win);
+    mvwaddstr(win, 1, 1,
+        "Press keys (or mouse buttons) to show their names");
+    mvwaddstr(win, 2, 1, "Press spacebar to finish, Ctrl-A to return to main menu");
+    mvwaddstr(win, 2, 1, "Press spacebar to finish");
+    wrefresh(win);
+
+    keypad(win, TRUE);
+    raw();
+    noecho();
+
+    wtimeout(win, 200);
+
+#ifdef PDCURSES
+    mouse_set(ALL_MOUSE_EVENTS);
+    PDC_return_key_modifiers(TRUE);
+#endif
+    curs_set(0);        /* turn cursor off */
+
+    while (1)
+    {
+        while (1)
+        {
+            c = wgetch(win);
+
+            if (c == ERR)
+            {
+                spinner_count++;
+                if (spinner_count == 4)
+                    spinner_count = 0;
+                mvwaddch(win, 3, 3, spinner[spinner_count]);
+                wrefresh(win);
+            }
+            else
+                break;
+        }
+#ifdef PDCURSES
+        wmove(win, 4, 18);
+        wclrtoeol(win);
+#endif
+        mvwaddstr(win, 3, 5, "Key Pressed: ");
+        wclrtoeol(win);
+
+        wprintw( win, "(%x) ", c);
+        if( has_key( c))
+            wprintw(win, "%s", keyname(c));
+        else if (isprint(c))
+            wprintw(win, "%c", c);
+        else
+            wprintw(win, "%s", unctrl(c));
+#ifdef PDCURSES
+        if (c == KEY_MOUSE)
+        {
+            int button = 0;
+            request_mouse_pos();
+
+            if (BUTTON_CHANGED(1))
+                button = 1;
+            else if (BUTTON_CHANGED(2))
+                button = 2;
+            else if (BUTTON_CHANGED(3))
+                button = 3;
+
+            if (button && (BUTTON_STATUS(button) &
+                BUTTON_MODIFIER_MASK))
+            {
+                waddstr(win, " Modifier(s):");
+
+                if (BUTTON_STATUS(button) & BUTTON_SHIFT)
+                    waddstr(win, " SHIFT");
+
+                if (BUTTON_STATUS(button) & BUTTON_CONTROL)
+                    waddstr(win, " CONTROL");
+
+                if (BUTTON_STATUS(button) & BUTTON_ALT)
+                    waddstr(win, " ALT");
+            }
+
+            wmove(win, 4, 18);
+            wclrtoeol(win);
+            wprintw(win, "Button %d: ", button);
+
+            if (MOUSE_MOVED)
+                waddstr(win, "moved: ");
+            else if (MOUSE_WHEEL_UP)
+                waddstr(win, "wheel up: ");
+            else if (MOUSE_WHEEL_DOWN)
+                waddstr(win, "wheel dn: ");
+            else if (MOUSE_WHEEL_LEFT)
+                waddstr(win, "wheel lt: ");
+            else if (MOUSE_WHEEL_RIGHT)
+                waddstr(win, "wheel rt: ");
+            else if ((BUTTON_STATUS(button) &
+                BUTTON_ACTION_MASK) == BUTTON_PRESSED)
+                waddstr(win, "pressed: ");
+            else if ((BUTTON_STATUS(button) &
+                BUTTON_ACTION_MASK) == BUTTON_CLICKED)
+                waddstr(win, "clicked: ");
+            else if ((BUTTON_STATUS(button) &
+                BUTTON_ACTION_MASK) == BUTTON_DOUBLE_CLICKED)
+                waddstr(win, "double: ");
+            else
+                waddstr(win, "released: ");
+
+            wprintw(win, "Position: Y: %d X: %d", MOUSE_Y_POS, MOUSE_X_POS);
+        }
+        else if (PDC_get_key_modifiers())
+        {
+            waddstr(win, " Modifier(s):");
+            if (PDC_get_key_modifiers() & PDC_KEY_MODIFIER_SHIFT)
+                waddstr(win, " SHIFT");
+
+            if (PDC_get_key_modifiers() & PDC_KEY_MODIFIER_CONTROL)
+                waddstr(win, " CONTROL");
+
+            if (PDC_get_key_modifiers() & PDC_KEY_MODIFIER_ALT)
+                waddstr(win, " ALT");
+
+            if (PDC_get_key_modifiers() & PDC_KEY_MODIFIER_NUMLOCK)
+                waddstr(win, " NUMLOCK");
+        }
+#endif
+        wrefresh(win);
+
+        if (c == ' ' || c == 1)
+            break;
+    }
+
+    wtimeout(win, -1);  /* turn off timeout() */
+    curs_set(1);        /* turn cursor back on */
+
+#ifdef PDCURSES
+    mouse_set(0L);
+    PDC_return_key_modifiers(FALSE);
+#endif
+    wclear(win);
+    if( c == 1)
+    {
+       delwin( subWin);
+       return;
+    }
+    mvwaddstr(win, 2, 1, "Press some keys for 5 seconds");
+    mvwaddstr(win, 1, 1, "Pressing ^C should do nothing");
+    wrefresh(win);
+
+    werase(subWin);
+    box(subWin, ACS_VLINE, ACS_HLINE);
+
+    for (i = 0; i < 5; i++)
+    {
+        mvwprintw(subWin, 1, 1, "Time = %d", i);
+        wrefresh(subWin);
+        napms(1000);
+        flushinp();
+    }
+
+    delwin(subWin);
+    werase(win);
+    flash();
+    wrefresh(win);
+    napms(500);
+    flushinp();
+
+    mvwaddstr(win, 2, 1, "Press a key, followed by ENTER");
+    wmove(win, 9, 10);
+    wrefresh(win);
+    echo();
+
+    keypad(win, TRUE);
+    raw();
+    wgetnstr(win, buffer, 3);
+    flushinp();
+
+    wmove(win, 9, 10);
+    wdelch(win);
+    mvwaddstr(win, 4, 1, "The character should now have been deleted");
+    Continue(win);
+
+    refresh();
+    wclear(win);
+    echo();
+    buffer[0] = '\0';
+    mvwaddstr(win, 3, 2, "The window should have moved");
+    mvwaddstr(win, 4, 2,
+              "This text should have appeared without you pressing a key");
+    mvwaddstr(win, 6, 2, "Enter a number then a string seperated by space");
+    mvwin(win, 2, 1);
+    wrefresh(win);
+    mvwscanw(win, 7, 6, "%d %s", &num, buffer);
+    mvwprintw(win, 8, 6, "String: %s Number: %d", buffer, num);
+    Continue(win);
+
+    refresh();
+    wclear(win);
+    echo();
+    mvwaddstr(win, 3, 2, "Enter a 5 character string: ");
+    wgetnstr(win, buffer, 5);
+    mvwprintw(win, 4, 2, "String: %s", buffer);
+    Continue(win);
+}
+
+void outputTest(WINDOW *win)
+{
+    WINDOW *win1;
+    char Buffer[80];
+    chtype ch;
+    int by, bx;
+
+#ifdef PDCURSES
+    PDC_set_blink(TRUE);
+#endif
+    nl();
+    wclear(win);
+    mvwaddstr(win, 1, 1, "You should now have a screen in the upper "
+                         "left corner, and this text should have wrapped");
+    waddstr(win,"\nThis text should be down\n");
+    waddstr(win,  "and broken into two here ^");
+    Continue(win);
+
+    wclear(win);
+    wattron(win, A_BOLD);
+    mvwaddstr(win, 1, 1, "A new window will appear with this text in it");
+    mvwaddstr(win, 8, 1, "Press any key to continue");
+    wrefresh(win);
+    wgetch(win);
+
+    getbegyx(win, by, bx);
+
+    if (LINES < 24 || COLS < 75)
+    {
+        mvwaddstr(win, 5, 1, "Some tests have been skipped as they require a");
+        mvwaddstr(win, 6, 1, "display of at least 24 LINES by 75 COLUMNS");
+        Continue(win);
+    }
+    else
+    {
+        win1 = newwin(10, 50, 14, 25);
+
+        if (win1 == NULL)
+        {
+            endwin();
+            return;
+        }
+
+#ifdef A_COLOR
+        if (has_colors())
+        {
+            init_pair(3, COLOR_BLUE, COLOR_WHITE);
+            wbkgd(win1, COLOR_PAIR(3));
+        }
+        else
+#endif
+            wbkgd(win1, A_NORMAL);
+
+        wclear(win1);
+        mvwaddstr(win1, 5, 1, "This text should appear; using overlay option");
+        copywin(win, win1, 0, 0, 0, 0, 9, 49, TRUE);
+        box(win1, ACS_VLINE, ACS_HLINE);
+        wmove(win1, 8, 26);
+        wrefresh(win1);
+        wgetch(win1);
+
+        wclear(win1);
+
+        wattron(win1, A_BLINK);
+        mvwaddstr(win1, 4, 1,
+                  "This blinking text should appear in only the second window");
+        wattroff(win1, A_BLINK);
+
+        mvwin(win1, by, bx);
+        overlay(win, win1);
+        mvwin(win1, 14, 25);
+        wmove(win1, 8, 26);
+        wrefresh(win1);
+        wgetch(win1);
+
+        delwin(win1);
+    }
+
+    clear();
+    wclear(win);
+    wrefresh(win);
+    mvwaddstr(win, 6, 2, "This line shouldn't appear");
+    mvwaddstr(win, 4, 2, "Only half of the next line is visible");
+    mvwaddstr(win, 5, 2, "Only half of the next line is visible");
+    wmove(win, 6, 1);
+    wclrtobot(win);
+    wmove(win, 5, 20);
+    wclrtoeol(win);
+    mvwaddstr(win, 8, 2, "This line also shouldn't appear");
+    wmove(win, 8, 1);
+    winsdelln(win, -1);
+    Continue(win);
+
+    wmove(win, 5, 9);
+    ch = winch(win);
+
+    wclear(win);
+    wmove(win, 6, 2);
+    waddstr(win, "The next char should be l:  ");
+    winsch(win, ch);
+    Continue(win);
+
+    mvwinsstr(win, 6, 2, "A1B2C3D4E5");
+    Continue(win);
+
+    wmove(win, 5, 1);
+    winsdelln(win, 1);
+    mvwaddstr(win, 5, 2, "The lines below should have moved down");
+    Continue(win);
+
+    wclear(win);
+    wmove(win, 2, 2);
+    wprintw(win, "This is a formatted string in a window: %d %s\n",
+            42, "is it");
+    mvwaddstr(win, 10, 1, "Enter a string: ");
+    wrefresh(win);
+    echo();
+    wscanw(win, "%s", Buffer);
+
+    printw("This is a formatted string in stdscr: %d %s\n", 42, "is it");
+    mvaddstr(10, 1, "Enter a string: ");
+    scanw("%s", Buffer);
+
+    wclear(win);
+    curs_set(2);
+    mvwaddstr(win, 1, 1, "The cursor should be in high-visibility mode");
+    Continue(win);
+
+    wclear(win);
+    curs_set(0);
+    mvwaddstr(win, 1, 1, "The cursor should have disappeared");
+    Continue(win);
+
+    wclear(win);
+    curs_set(1);
+    mvwaddstr(win, 1, 1, "The cursor should be normal");
+    Continue(win);
+
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        wclear(win);
+        mvwaddstr(win, 1, 1, "Colors should change after you press a key");
+        Continue(win);
+
+        init_pair(1, COLOR_RED, COLOR_WHITE);
+        wrefresh(win);
+    }
+#endif
+    werase(win);
+    mvwaddstr(win, 1, 1, "Information About Your Terminal");
+    mvwaddstr(win, 3, 1, termname());
+    mvwaddstr(win, 4, 1, longname());
+
+    if (termattrs() & A_BLINK)
+        mvwaddstr(win, 5, 1, "This terminal claims to support blinking.");
+    else
+        mvwaddstr(win, 5, 1, "This terminal does NOT support blinking.");
+
+    mvwaddnstr(win, 7, 5, "Have a nice day!ok", 16);
+    wrefresh(win);
+
+    mvwinnstr(win, 7, 5, Buffer, 18);
+    mvaddstr(LINES - 2, 10, Buffer);
+    refresh();
+    Continue(win);
+#ifdef PDCURSES
+    PDC_set_blink(FALSE);
+#endif
+}
+
+#if HAVE_RESIZE
+void resizeTest(WINDOW *dummy)
+{
+    WINDOW *win1;
+    int nwidth = 135, nheight = 52;
+    int owidth = COLS, oheight = LINES;
+
+    INTENTIONALLY_UNUSED_PARAMETER( dummy);
+    savetty();
+
+    resize_term(nheight, nwidth);
+
+    clear();
+    refresh();
+
+    win1 = newwin(10, 50, 14, 25);
+
+    if (win1 == NULL)
+    {
+        endwin();
+        return;
+    }
+
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(3, COLOR_BLUE, COLOR_WHITE);
+        wattrset(win1, COLOR_PAIR(3));
+    }
+
+    wclear(win1);
+#endif
+    mvwaddstr(win1, 0, 0, "The screen may now be resized");
+    mvwprintw(win1, 1, 4, "Given size: %d by %d", nwidth, nheight);
+    mvwprintw(win1, 2, 4, "Actual size: %d by %d", COLS, LINES);
+    Continue(win1);
+
+    wclear(win1);
+    resetty();
+
+    mvwaddstr(win1, 0, 0, "The screen should now be reset");
+    mvwprintw(win1, 1, 6, "Old size: %d by %d", owidth, oheight);
+    mvwprintw(win1, 2, 6, "Size now: %d by %d", COLS, LINES);
+    Continue(win1);
+
+    delwin(win1);
+
+    clear();
+    refresh();
+}
+#endif /* HAVE_RESIZE */
+
+void padTest(WINDOW *dummy)
+{
+    WINDOW *pad, *spad;
+
+    INTENTIONALLY_UNUSED_PARAMETER( dummy);
+    pad = newpad(50, 100);
+    wattron(pad, A_REVERSE);
+    mvwaddstr(pad, 5, 2, "This is a new pad");
+    wattrset(pad, 0);
+    mvwaddstr(pad, 8, 0,
+        "The end of this line should be truncated here:except  now");
+    mvwaddstr(pad, 11, 1, "This line should not appear.It will now");
+    wmove(pad, 10, 1);
+    wclrtoeol(pad);
+    mvwaddstr(pad, 10, 1, " Press any key to continue");
+    prefresh(pad, 0, 0, 0, 0, 10, 45);
+    keypad(pad, TRUE);
+    raw();
+    wgetch(pad);
+
+    spad = subpad(pad, 12, 25, 7, 52);
+    mvwaddstr(spad, 2, 2, "This is a new subpad");
+    box(spad, 0, 0);
+    delwin(spad);
+    prefresh(pad, 0, 0, 0, 0, 15, 75);
+    keypad(pad, TRUE);
+    raw();
+    wgetch(pad);
+
+    mvwaddstr(pad, 35, 2, "This is displayed at line 35 in the pad");
+    mvwaddstr(pad, 40, 1, " Press any key to continue");
+    prefresh(pad, 30, 0, 0, 0, 10, 45);
+    keypad(pad, TRUE);
+    raw();
+    wgetch(pad);
+
+    delwin(pad);
+}
+
+#if HAVE_CLIPBOARD
+void clipboardTest(WINDOW *win)
+{
+    static const char *text =
+        "This string placed in clipboard by PDCurses test program, testcurs.";
+    char *ptr = NULL;
+    long i, length = 0;
+
+    INTENTIONALLY_UNUSED_PARAMETER( win);
+    mvaddstr(1, 1,
+             "This test will display the contents of the system clipboard");
+
+    Continue2();
+
+    scrollok(stdscr, TRUE);
+    i = PDC_getclipboard(&ptr, &length);
+
+    switch(i)
+    {
+    case PDC_CLIP_ACCESS_ERROR:
+        mvaddstr(3, 1, "There was an error accessing the clipboard");
+        refresh();
+        break;
+
+    case PDC_CLIP_MEMORY_ERROR:
+        mvaddstr(3, 1,
+            "Unable to allocate memory for clipboard contents");
+        break;
+
+    case PDC_CLIP_EMPTY:
+        mvaddstr(3, 1, "There was no text in the clipboard");
+        break;
+
+    default:
+        wsetscrreg(stdscr, 0, LINES - 1);
+        clear();
+        mvaddstr(1, 1, "Clipboard contents...");
+        mvprintw(2, 1, "%s\n", ptr);
+    }
+
+    Continue2();
+
+    clear();
+    mvaddstr(1, 1,
+        "This test will place the following string in the system clipboard:");
+    mvaddstr(2, 1, text);
+
+    i = PDC_setclipboard(text, (long)strlen(text));
+
+    switch(i)
+    {
+    case PDC_CLIP_ACCESS_ERROR:
+        mvaddstr(3, 1, "There was an error accessing the clipboard");
+        break;
+
+    case PDC_CLIP_MEMORY_ERROR:
+        mvaddstr(3, 1, "Unable to allocate memory for clipboard contents");
+        break;
+
+    default:
+        mvaddstr(3, 1, "The string was placed in the clipboard successfully");
+    }
+
+    Continue2();
+}
+#endif /* HAVE_CLIPBOARD */
+
+void curTest(void)
+{
+    do {
+        int c = getch();
+
+#if defined (PDCURSES) || defined (NCURSES_VERSION)
+        if (c == KEY_UP)
+            move(getcury(stdscr) - 1, getcurx(stdscr));
+        else if (c == KEY_DOWN)
+            move(getcury(stdscr) + 1, getcurx(stdscr));
+        else if (c == KEY_LEFT)
+            move(getcury(stdscr), getcurx(stdscr) - 1);
+        else if (c == KEY_RIGHT)
+            move(getcury(stdscr), getcurx(stdscr) + 1);
+#ifdef PDCURSES
+        else if (c == 'i')
+            curs_set(SP->visibility == 1 ? 2 : 1);
+#endif
+        else
+#endif
+            break;
+    } while (TRUE);
+}
+
+void acsTest(WINDOW *win)
+{
+    static const char *acs_names[] =
+    {
+        "ACS_ULCORNER", "ACS_URCORNER", "ACS_LLCORNER", "ACS_LRCORNER",
+        "ACS_LTEE", "ACS_RTEE", "ACS_TTEE", "ACS_BTEE", "ACS_HLINE",
+        "ACS_VLINE", "ACS_PLUS",
+
+#ifdef ACS_D_ULCORNER
+        "ACS_D_ULCORNER", "ACS_D_URCORNER", "ACS_D_LLCORNER", "ACS_D_LRCORNER",
+        "ACS_D_LTEE", "ACS_D_RTEE", "ACS_D_TTEE", "ACS_D_BTEE", "ACS_D_HLINE",
+        "ACS_D_VLINE", "ACS_D_PLUS",
+#endif
+#ifdef ACS_SD_ULCORNER
+        "ACS_SD_ULCORNER", "ACS_SD_URCORNER", "ACS_SD_LLCORNER",
+        "ACS_SD_LRCORNER", "ACS_SD_LTEE",
+        "ACS_SD_RTEE", "ACS_SD_TTEE", "ACS_SD_BTEE", "ACS_SD_PLUS",
+        "ACS_DS_ULCORNER", "ACS_DS_URCORNER", "ACS_DS_LLCORNER",
+        "ACS_DS_LRCORNER", "ACS_DS_LTEE", "ACS_DS_RTEE", "ACS_DS_TTEE",
+        "ACS_DS_BTEE", "ACS_DS_PLUS",
+#endif
+        "ACS_S1",
+#ifdef ACS_S3
+        "ACS_S3", "ACS_S7",
+#endif
+        "ACS_S9", "ACS_DIAMOND",
+#ifdef ACS_CLUB
+        "ACS_CLUB", "ACS_SPADE", "ACS_HEART",
+        "ACS_LTBOARD",
+#endif
+        "ACS_BOARD", "ACS_CKBOARD", "ACS_DEGREE", "ACS_PLMINUS",
+        "ACS_BULLET",
+#ifdef ACS_SM_BULLET
+        "ACS_SM_BULLET", "ACS_MED_BULLET", "ACS_WHITE_BULLET",
+        "ACS_PILCROW", "ACS_SECTION", "ACS_SMILE", "ACS_REV_SMILE",
+#endif
+        "ACS_LARROW", "ACS_RARROW", "ACS_UARROW", "ACS_DARROW",
+        "ACS_LANTERN", "ACS_BLOCK",
+#ifdef ACS_LEQUAL
+        "ACS_LEQUAL", "ACS_GEQUAL", "ACS_NEQUAL",
+        "ACS_PI",  "ACS_STERLING",
+#endif
+#ifdef ACS_CENT
+        "ACS_CENT", "ACS_YEN", "ACS_PESETA",
+        "ACS_ALPHA", "ACS_BETA", "ACS_GAMMA", "ACS_UP_SIGMA",
+        "ACS_LO_SIGMA", "ACS_MU", "ACS_TAU", "ACS_UP_PHI", "ACS_LO_PHI",
+        "ACS_OMEGA", "ACS_DELTA", "ACS_INFINITY", "ACS_THETA", "ACS_EPSILON",
+        "ACS_INTERSECT", "ACS_SUP2", "ACS_SUP_N", "ACS_TRIPLE_BAR",
+        "ACS_APPROX_EQ", "ACS_SQUARE_ROOT", "ACS_NOT", "ACS_REV_NOT",
+        "ACS_HALF", "ACS_QUARTER", "ACS_DIVISION",
+        "ACS_UP_INTEGRAL", "ACS_LO_INTEGRAL",
+        "ACS_UBLOCK", "ACS_BBLOCK",
+        "ACS_LBLOCK", "ACS_RBLOCK",
+        "ACS_A_ORDINAL", "ACS_O_ORDINAL",
+        "ACS_INV_BANG", "ACS_INV_QUERY",
+        "ACS_LEFT_ANG_QU", "ACS_RIGHT_ANG_QU",
+        "ACS_CENTER_SQU", "ACS_F_WITH_HOOK",
+#endif
+    };
+
+    const chtype acs_values[] =
+    {
+        ACS_ULCORNER, ACS_URCORNER, ACS_LLCORNER, ACS_LRCORNER,
+        ACS_LTEE, ACS_RTEE, ACS_TTEE, ACS_BTEE, ACS_HLINE,
+        ACS_VLINE, ACS_PLUS,
+
+#ifdef ACS_D_ULCORNER
+        ACS_D_ULCORNER, ACS_D_URCORNER, ACS_D_LLCORNER, ACS_D_LRCORNER,
+        ACS_D_LTEE, ACS_D_RTEE, ACS_D_TTEE, ACS_D_BTEE, ACS_D_HLINE,
+        ACS_D_VLINE, ACS_D_PLUS,
+#endif
+#ifdef ACS_SD_ULCORNER
+        ACS_SD_ULCORNER, ACS_SD_URCORNER, ACS_SD_LLCORNER,
+        ACS_SD_LRCORNER, ACS_SD_LTEE,
+        ACS_SD_RTEE, ACS_SD_TTEE, ACS_SD_BTEE, ACS_SD_PLUS,
+        ACS_DS_ULCORNER, ACS_DS_URCORNER, ACS_DS_LLCORNER,
+        ACS_DS_LRCORNER, ACS_DS_LTEE, ACS_DS_RTEE, ACS_DS_TTEE,
+        ACS_DS_BTEE, ACS_DS_PLUS,
+#endif
+        ACS_S1,
+#ifdef ACS_S3
+        ACS_S3, ACS_S7,
+#endif
+        ACS_S9, ACS_DIAMOND,
+#ifdef ACS_CLUB
+        ACS_CLUB, ACS_SPADE, ACS_HEART, ACS_LTBOARD,
+#endif
+        ACS_BOARD, ACS_CKBOARD, ACS_DEGREE, ACS_PLMINUS, ACS_BULLET,
+#ifdef ACS_SM_BULLET
+        ACS_SM_BULLET, ACS_MED_BULLET, ACS_WHITE_BULLET,
+        ACS_PILCROW, ACS_SECTION, ACS_SMILE, ACS_REV_SMILE,
+#endif
+        ACS_LARROW, ACS_RARROW, ACS_UARROW, ACS_DARROW,
+        ACS_LANTERN, ACS_BLOCK,
+#ifdef ACS_LEQUAL
+        ACS_LEQUAL, ACS_GEQUAL, ACS_NEQUAL,
+        ACS_PI,  ACS_STERLING,
+#endif
+#ifdef ACS_CENT
+        ACS_CENT, ACS_YEN, ACS_PESETA,
+        ACS_ALPHA, ACS_BETA, ACS_GAMMA, ACS_UP_SIGMA,
+        ACS_LO_SIGMA, ACS_MU, ACS_TAU, ACS_UP_PHI, ACS_LO_PHI,
+        ACS_OMEGA, ACS_DELTA, ACS_INFINITY, ACS_THETA, ACS_EPSILON,
+        ACS_INTERSECT, ACS_SUP2, ACS_SUP_N, ACS_TRIPLE_BAR,
+        ACS_APPROX_EQ, ACS_SQUARE_ROOT, ACS_NOT, ACS_REV_NOT,
+        ACS_HALF, ACS_QUARTER, ACS_DIVISION,
+        ACS_UP_INTEGRAL, ACS_LO_INTEGRAL,
+        ACS_UBLOCK, ACS_BBLOCK,
+        ACS_LBLOCK, ACS_RBLOCK,
+        ACS_A_ORDINAL, ACS_O_ORDINAL,
+        ACS_INV_BANG, ACS_INV_QUERY,
+        ACS_LEFT_ANG_QU, ACS_RIGHT_ANG_QU,
+        ACS_CENTER_SQU, ACS_F_WITH_HOOK,
+#endif
+    };
+
+#if HAVE_WIDE && defined( WACS_S1)
+    const cchar_t *wacs_values[] =
+    {
+        WACS_ULCORNER, WACS_URCORNER, WACS_LLCORNER, WACS_LRCORNER,
+        WACS_LTEE, WACS_RTEE, WACS_TTEE, WACS_BTEE, WACS_HLINE,
+        WACS_VLINE, WACS_PLUS,
+
+#ifdef WACS_D_ULCORNER
+        WACS_D_ULCORNER, WACS_D_URCORNER, WACS_D_LLCORNER, WACS_D_LRCORNER,
+        WACS_D_LTEE, WACS_D_RTEE, WACS_D_TTEE, WACS_D_BTEE, WACS_D_HLINE,
+        WACS_D_VLINE, WACS_D_PLUS,
+#endif
+#ifdef WACS_SD_ULCORNER
+        WACS_SD_ULCORNER, WACS_SD_URCORNER, WACS_SD_LLCORNER,
+        WACS_SD_LRCORNER, WACS_SD_LTEE,
+        WACS_SD_RTEE, WACS_SD_TTEE, WACS_SD_BTEE, WACS_SD_PLUS,
+        WACS_DS_ULCORNER, WACS_DS_URCORNER, WACS_DS_LLCORNER,
+        WACS_DS_LRCORNER, WACS_DS_LTEE, WACS_DS_RTEE, WACS_DS_TTEE,
+        WACS_DS_BTEE, WACS_DS_PLUS,
+#endif
+        WACS_S1,
+#ifdef WACS_S3
+        WACS_S3, WACS_S7,
+#endif
+        WACS_S9, WACS_DIAMOND,
+#ifdef WACS_CLUB
+        WACS_CLUB, WACS_SPADE, WACS_HEART, WACS_LTBOARD,
+#endif
+        WACS_BOARD, WACS_CKBOARD, WACS_DEGREE, WACS_PLMINUS, WACS_BULLET,
+#ifdef WACS_SM_BULLET
+        WACS_SM_BULLET, WACS_MED_BULLET, WACS_WHITE_BULLET,
+        WACS_PILCROW, WACS_SECTION, WACS_SMILE, WACS_REV_SMILE,
+#endif
+        WACS_LARROW, WACS_RARROW, WACS_UARROW, WACS_DARROW,
+        WACS_LANTERN, WACS_BLOCK,
+#ifdef WACS_LEQUAL
+        WACS_LEQUAL, WACS_GEQUAL, WACS_NEQUAL,
+        WACS_PI,  WACS_STERLING,
+#endif
+#ifdef WACS_CENT
+        WACS_CENT, WACS_YEN, WACS_PESETA,
+        WACS_ALPHA, WACS_BETA, WACS_GAMMA, WACS_UP_SIGMA,
+        WACS_LO_SIGMA, WACS_MU, WACS_TAU, WACS_UP_PHI, WACS_LO_PHI,
+        WACS_OMEGA, WACS_DELTA, WACS_INFINITY, WACS_THETA, WACS_EPSILON,
+        WACS_INTERSECT, WACS_SUP2, WACS_SUP_N, WACS_TRIPLE_BAR,
+        WACS_APPROX_EQ, WACS_SQUARE_ROOT, WACS_NOT, WACS_REV_NOT,
+        WACS_HALF, WACS_QUARTER, WACS_DIVISION,
+        WACS_UP_INTEGRAL, WACS_LO_INTEGRAL,
+        WACS_UBLOCK, WACS_BBLOCK,
+        WACS_LBLOCK, WACS_RBLOCK,
+        WACS_A_ORDINAL, WACS_O_ORDINAL,
+        WACS_INV_BANG, WACS_INV_QUERY,
+        WACS_LEFT_ANG_QU, WACS_RIGHT_ANG_QU,
+        WACS_CENTER_SQU, WACS_F_WITH_HOOK,
+#endif               /* #if WACS_CENT */
+    };
+#endif               /* #ifdef WACS_S1   */
+
+#if HAVE_WIDE
+    static const wchar_t russian[] = {0x0420, 0x0443, 0x0441, 0x0441,
+        0x043a, 0x0438, 0x0439, L' ', 0x044f, 0x0437, 0x044b, 0x043a, 0};
+
+    static const wchar_t greek[] = {0x0395, 0x03bb, 0x03bb, 0x03b7,
+        0x03bd, 0x03b9, 0x03ba, 0x03ac, 0};
+
+    static const wchar_t georgian[] = {0x10e5, 0x10d0, 0x10e0, 0x10d7,
+        0x10e3, 0x10da, 0x10d8, L' ', 0x10d4, 0x10dc, 0x10d0, 0};
+
+    static const wchar_t fullwidth[] = { 0xff26, 0xff55, 0xff4c, 0xff4c,
+        0xff57, 0xff49, 0xff44, 0xff54, 0xff48, 0 };  /* "Fullwidth" */
+
+    static const wchar_t combining_marks[] = { L'C', L'o', 0x35c, L'm',
+                   L'b', 0x30a, L'i', L'n', L'i', 0x304, L'n', 0x30b, 0x329,
+                   L'g', 0x310,
+                   L' ', L'C', 0x338, L'h', 0x306,  L'a', 0x361, L'r', L's',
+                   0x30e, 0x348, 0 };
+
+#endif
+
+    int i, tmarg = 1, ncols = (COLS - 4) / 19;
+    int col_size = (COLS - 4) / ncols;
+    int n_items = sizeof( acs_names) / sizeof( acs_names[0]);
+    int n_rows = LINES / 2 - 4;
+
+    INTENTIONALLY_UNUSED_PARAMETER( win);
+    i = 0;
+    while( i < n_items)
+    {
+        int j, xloc = 3;
+
+        attrset(A_BOLD);
+        mvaddstr( 1, (COLS - 23) / 2, "Alternate Character Set");
+        attrset(A_NORMAL);
+        tmarg = 4;
+        while( i < n_items && xloc < COLS - col_size)
+        {
+            for( j = 0; i < n_items && j < n_rows; j++, i++)
+            {
+                move( j * 2 + tmarg, xloc);
+                addch(acs_values[i]);
+                printw(" %s", acs_names[i]);
+            }
+            xloc += col_size;
+        }
+
+        mvaddstr( tmarg + n_rows * 2, 3, curses_version( ));
+        move( tmarg + n_rows * 2 + 1, 3);
+        printw( "sizeof( chtype) = %d; sizeof( mmask_t) = %d",
+                           (int)sizeof( chtype), (int)sizeof( mmask_t));
+        mvaddstr(tmarg + n_rows * 2 + 2, 3, "Press any key to continue");
+        getch();
+        clear( );
+    }
+
+#if HAVE_WIDE
+    i = 0;
+    while( i < n_items)
+    {
+        int j, xloc = 3;
+
+        attrset(A_BOLD);
+        mvaddstr( 1, (COLS - 28) / 2, "Wide Alternate Character Set");
+        attrset(A_NORMAL);
+        tmarg = 4;
+#ifdef WACS_S1
+        while( i < n_items && xloc < COLS - col_size)
+        {
+            for( j = 0; i < n_items && j < n_rows; j++, i++)
+            {
+                move( j * 2 + tmarg, xloc);
+                add_wch( wacs_values[i]);
+                printw(" W%s", acs_names[i]);
+            }
+            xloc += col_size;
+        }
+#endif
+    /* Spanish, Russian, Greek, Georgian, fullwidth, combining */
+
+        tmarg += n_rows * 2;
+        mvaddwstr(tmarg, COLS / 8 - 5, L"Espa\xf1ol");
+        mvaddwstr(tmarg, 3 * (COLS / 8) - 5, russian);
+        mvaddwstr(tmarg, 5 * (COLS / 8) - 5, greek);
+        mvaddwstr(tmarg, 7 * (COLS / 8) - 5, georgian);
+        mvaddwstr(tmarg + 1, COLS / 8 - 5, fullwidth);
+
+        mvaddwstr(tmarg + 1, 3 * (COLS / 8) - 5, combining_marks);
+#ifdef CHTYPE_64
+        mvaddch( tmarg + 1, 7 * (COLS / 8) - 5, (chtype)0x1d11e);
+#endif            /* U+1D11E = musical symbol G clef */
+
+        mvaddstr(tmarg + 2, 3, "Press any key to continue");
+        getch();
+        clear( );
+    }
+#endif
+}
+
+void attrTest(WINDOW *win)
+{
+    int tmarg = (LINES - 16) / 2;
+    int col1 = (COLS - 36) / 2, col2 = col1 + 20;
+
+    INTENTIONALLY_UNUSED_PARAMETER( win);
+    attrset(A_BOLD);
+    mvaddstr(tmarg, (COLS - 20) / 2, "Character Attributes");
+    attrset(A_NORMAL);
+
+    refresh();
+
+#ifdef PDCURSES
+    PDC_set_blink(TRUE);
+    PDC_set_bold(TRUE);
+#endif
+
+#ifdef A_ITALIC
+    attrset(A_ITALIC);
+    mvaddstr(tmarg + 3, col1, "A_ITALIC");
+    attrset(A_NORMAL);
+#endif
+
+    attrset(A_BOLD);
+    mvaddstr(tmarg + 5, col1, "A_BOLD");
+    attrset(A_NORMAL);
+
+    attrset(A_BLINK);
+    mvaddstr(tmarg + 7, col1, "A_BLINK");
+    attrset(A_NORMAL);
+
+    attrset(A_REVERSE);
+    mvaddstr(tmarg + 9, col1, "A_REVERSE");
+    attrset(A_NORMAL);
+
+    attrset(A_STANDOUT);
+    mvaddstr(tmarg + 11, col1, "A_STANDOUT");
+    attrset(A_NORMAL);
+
+    attrset(A_UNDERLINE);
+    mvaddstr(tmarg + 13, col1, "A_UNDERLINE");
+    attrset(A_NORMAL);
+
+#ifdef A_STRIKEOUT
+    if( A_STRIKEOUT)
+    {
+        attrset(A_STRIKEOUT);
+        mvaddstr(tmarg + 15, col1, "A_STRIKEOUT");
+        attrset(A_NORMAL);
+    }
+#endif
+
+#ifdef A_OVERLINE
+    if( A_OVERLINE)
+    {
+        attrset(A_OVERLINE);
+        mvaddstr(tmarg + 15, col2, "A_OVERLINE");
+        attrset(A_NORMAL);
+    }
+#endif
+
+#ifdef A_ITALIC
+    if( A_ITALIC)
+    {
+        attrset(A_ITALIC|A_UNDERLINE);
+        mvaddstr(tmarg + 3, col2, "Underlined Italic");
+        attrset(A_NORMAL);
+    }
+#endif
+
+    attrset(A_BOLD|A_UNDERLINE);
+    mvaddstr(tmarg + 5, col2, "Underlined Bold");
+    attrset(A_NORMAL);
+
+    attrset(A_BLINK|A_UNDERLINE);
+    mvaddstr(tmarg + 7, col2, "Underlined Blink");
+    attrset(A_NORMAL);
+
+#ifdef A_LEFT
+    attrset(A_LEFT);
+    mvaddstr(tmarg + 9, col2, "A_LEFT");
+    attrset(A_NORMAL);
+#endif
+
+#ifdef A_RIGHT
+    attrset(A_RIGHT);
+    mvaddstr(tmarg + 11, col2, "A_RIGHT");
+    attrset(A_NORMAL);
+#endif
+
+    attrset(A_BLINK|A_REVERSE);
+    mvaddstr(tmarg + 13, col2, "Reverse Blink");
+    attrset(A_NORMAL);
+
+    mvaddstr(tmarg + 17, 3, "Press any key to continue");
+    curTest();
+
+#ifdef PDCURSES
+    PDC_set_bold(FALSE);
+    PDC_set_blink(FALSE);
+#endif
+}
+
+#if HAVE_COLOR
+void remap(int tmarg, const short *colors)
+{
+    struct
+    {
+        short red, green, blue;
+    } orgcolors[16];
+    short i, maxcol = (COLORS >= 16) ? 16 : 8;
+
+    for (i = 0; i < maxcol; i++)
+        color_content(i, &(orgcolors[i].red),
+                         &(orgcolors[i].green),
+                         &(orgcolors[i].blue));
+
+    attrset(A_BOLD);
+    mvaddstr(tmarg, (COLS - 22) / 2, " init_color() Example ");
+    attrset(A_NORMAL);
+
+    refresh();
+
+    for (i = 0; i < 8; i++)
+    {
+        init_color(colors[i], i * 125, 0, i * 125);
+
+        if (COLORS >= 16)
+            init_color(colors[i] + 8, 0, i * 125, 0);
+    }
+
+    mvaddstr(tmarg + 19, 3, "Press any key to continue");
+    curTest();
+
+    for (i = 0; i < maxcol; i++)
+        init_color(i, orgcolors[i].red,
+                      orgcolors[i].green,
+                      orgcolors[i].blue);
+}
+
+void extended(int tmarg)
+{
+    short i, x, y, z, lmarg = (short)(COLS - 77) / 2;
+
+    erase();
+
+    curs_set(0);
+
+    attrset(A_BOLD);
+    mvaddstr(tmarg, (COLS - 15) / 2, "Extended Colors");
+    attrset(A_NORMAL);
+
+    mvaddstr(tmarg + 3, lmarg, "6x6x6 Color Cube (16-231):");
+
+    for (i = 16; i < 256; i++)
+        init_pair(i, COLOR_BLACK, i);
+
+    for (i = 16, x = 0; x < 6; x++)
+        for (z = 0; z < 6; z++)
+            for (y = 0; y < 6; y++)
+            {
+                chtype ch = ' ' | COLOR_PAIR(i++);
+
+                mvaddch(tmarg + 5 + y, z * 13 + x * 2 + lmarg, ch);
+                addch(ch);
+            }
+
+    mvaddstr(tmarg + 13, lmarg, "Greyscale (232-255):");
+
+    for (x = 0; x < 24; x++)
+    {
+        chtype ch = ' ' | COLOR_PAIR(232 + x);
+
+        mvaddch(tmarg + 15, x * 2 + lmarg, ch);
+        addch(ch);
+    }
+
+    refresh();
+    curs_set(1);
+
+    mvaddstr(tmarg + 19, 3, "Press any key to continue");
+    curTest();
+}
+
+void gradient(int tmarg)
+{
+    int i;
+    short cnum = 256, pnum = 16;
+
+    erase();
+    refresh();
+
+    curs_set(0);
+
+    attrset(A_BOLD);
+    mvaddstr(tmarg, (COLS - 17) / 2, "Colors Beyond 256");
+    attrset(A_NORMAL);
+
+    for (i = 0; i < 6; i++)
+    {
+        int j;
+        const char *output_text[6] = {
+            "Red on green to white on black | "
+            "   (gradients work just as well with",
+            "Blue on yellow to black on red | "
+            "palettes, if you have enough colors)",
+            "White on red to green on blue,  underlined (if available)",
+            "We can keep going on and on until we "
+            "run out of color pairs or colors.",
+            "Some platforms will have plenty of both "
+            "and this won't be a real problem. ",
+            "Others can be made to work that way "
+            "without too much trouble." };
+
+        const int len = (int)strlen(output_text[i]);
+
+        move(tmarg + 3 + i, (COLS - 69) / 2);
+        for (j = 0; j < len && cnum < COLORS && pnum < COLOR_PAIRS; j++)
+        {
+            const short oval = (short)( j * 1000 / len);
+            const short reverse = 1000 - oval;
+
+            if (!i)
+            {
+                init_color(cnum, 1000, oval, oval);
+                init_color(cnum + 1, 0, reverse, 0);
+            }
+            else if (i == 1)
+            {
+                init_color(cnum, 0, 0, reverse);
+                init_color(cnum + 1, 1000, reverse, 0);
+            }
+            else if( i == 2)
+            {
+                init_color(cnum, reverse, 1000, reverse);
+                init_color(cnum + 1, reverse, 0, oval);
+            }
+            else
+            {
+                const short r = (short)( rand( ) % 400);
+                const short g = (short)( rand( ) % 400);
+                const short b = (short)( rand( ) % 400);
+
+                init_color( cnum, r, g, b);
+                init_color( cnum + 1, 1000 - r, 1000 - g, 1000 - b);
+            }
+            init_pair(pnum, cnum, cnum + 1);
+            attrset(COLOR_PAIR(pnum));
+            if (i == 2)
+                attron(A_UNDERLINE);
+            else
+                attroff(A_UNDERLINE);
+            addch(output_text[i][j]);
+
+            cnum += 2;
+            pnum++;
+        }
+    }
+
+    refresh();
+    curs_set(1);
+
+    attrset(A_NORMAL);
+    mvaddstr(tmarg + 19, 3, "Press any key to continue");
+    curTest();
+}
+
+void colorTest(WINDOW *win)
+{
+    static const short colors[] =
+    {
+        COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE,
+        COLOR_CYAN, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE
+    };
+
+    static const char *colornames[] =
+    {
+        "COLOR_BLACK", "COLOR_RED", "COLOR_GREEN", "COLOR_BLUE",
+        "COLOR_CYAN", "COLOR_MAGENTA", "COLOR_YELLOW", "COLOR_WHITE"
+    };
+
+    chtype fill = ACS_BLOCK;
+    bool widecol = (COLORS >= 16);
+
+    int i, j, tmarg, col1, col2, col3;
+
+    INTENTIONALLY_UNUSED_PARAMETER( win);
+    if (!has_colors())
+        return;
+
+    tmarg = (LINES - 19) / 2;
+    col1 = (COLS - 60) / 2;
+    col2 = col1 + 20;
+    col3 = col2 + 20;
+
+    attrset(A_BOLD);
+    mvaddstr(tmarg, (COLS - 22) / 2, "Color Attribute Macros");
+    attrset(A_NORMAL);
+
+    if (widecol)
+    {
+        mvaddstr(tmarg + 3, col2 + 3, "Colors 0-7");
+        mvaddstr(tmarg + 3, col3 + 2, "Colors 8-15");
+    }
+    else
+    {
+        mvaddstr(tmarg + 3, col2 + 4, "A_NORMAL");
+        mvaddstr(tmarg + 3, col3 + 5, "A_BOLD");
+    }
+
+    for (i = 0; i < 8; i++)
+    {
+        init_pair((short)i + 4, colors[i], COLOR_BLACK);
+        if (widecol)
+            init_pair((short)i + 12, colors[i] + 8, COLOR_BLACK);
+
+        mvaddstr(tmarg + i + 5, col1, colornames[i]);
+
+        for (j = 0; j < 16; j++)
+        {
+            mvaddch(tmarg + i + 5, col2 + j, fill | COLOR_PAIR(i + 4));
+            mvaddch(tmarg + i + 5, col3 + j, fill | (widecol ?
+                    COLOR_PAIR(i + 12) : (COLOR_PAIR(i + 4) | A_BOLD) ));
+        }
+    }
+
+    mvprintw(tmarg + 15, col1, "COLORS = %d", COLORS);
+    mvprintw(tmarg + 16, col1, "COLOR_PAIRS = %d", COLOR_PAIRS);
+
+    mvaddstr(tmarg + 19, 3, "Press any key to continue");
+    curTest();
+
+    if (can_change_color())
+        remap(tmarg, colors);
+
+    if (COLORS >= 256)
+        extended(tmarg);
+
+    if (can_change_color() && COLORS >= 768)
+        gradient(tmarg);
+}
+#endif
+
+#if HAVE_WIDE
+void wideTest(WINDOW *win)
+{
+    wchar_t tmp[513];
+    size_t i;
+
+    INTENTIONALLY_UNUSED_PARAMETER( win);
+    attrset(A_BOLD);
+    mvaddstr(1, (COLS - 25) / 2, "Wide Character Input Test");
+    attrset(A_NORMAL);
+
+    mvaddstr(4, 1, "Enter a string: ");
+
+    echo();
+
+    get_wstr((wint_t *)tmp);
+    addstr("\n\n String:\n\n ");
+    addwstr(tmp);
+    addstr("\n\n\n Hex:\n\n ");
+
+    for (i = 0; i < wcslen(tmp); i++)
+    {
+        printw("%04x ", tmp[i]);
+        addnwstr(tmp + i, 1);
+        addstr("  ");
+    }
+
+    noecho();
+
+    Continue2();
+}
+#endif
+
+void display_menu(int old_option, int new_option)
+{
+    int lmarg = (COLS - 14) / 2,
+        tmarg = (LINES - (MAX_OPTIONS + 2)) / 2;
+
+    if (old_option == -1)
+    {
+        int i;
+
+        attrset(A_BOLD);
+        mvaddstr(tmarg - 3, lmarg - 5, "PDCurses Test Program");
+        attrset(A_NORMAL);
+
+        for (i = 0; i < MAX_OPTIONS; i++)
+            mvaddstr(tmarg + i, lmarg, command[i].text);
+    }
+    else
+        mvaddstr(tmarg + old_option, lmarg, command[old_option].text);
+
+    attrset(A_REVERSE);
+    mvaddstr(tmarg + new_option, lmarg, command[new_option].text);
+    attrset(A_NORMAL);
+
+    mvaddstr(tmarg + MAX_OPTIONS + 2, lmarg - 23,
+             "Use Up and Down Arrows to select - Enter to run - Q to quit");
+    refresh();
+}
diff --git a/lib/PDCursesMod/demos/triangles.c b/lib/PDCursesMod/demos/triangles.c
new file mode 100644
index 00000000000..f7e96bacfa5
--- /dev/null
+++ b/lib/PDCursesMod/demos/triangles.c
@@ -0,0 +1,85 @@
+#include <curses.h>
+#include <stdlib.h>
+#include <sys/random.h>
+
+int getrandom_int(void)
+{
+	int ret;
+	int rand;
+
+	ret = getrandom(&rand, sizeof(int), 0);
+	(void) ret;
+
+	if (rand < 0) {
+		return (rand * -1);
+	} else {
+		return (rand);
+	}
+}
+
+#define ITERMAX 10000
+
+int main(void)
+{
+    long iter;
+    int yi, xi;
+    int y[3], x[3];
+    int index;
+    int maxlines, maxcols;
+
+    /* initialize curses */
+
+    initscr();
+    cbreak();
+    noecho();
+
+    clear();
+
+    /* initialize triangle */
+
+    maxlines = LINES - 1;
+    maxcols = COLS - 1;
+
+    y[0] = 0;
+    x[0] = 0;
+
+    y[1] = maxlines;
+    x[1] = maxcols / 2;
+
+    y[2] = 0;
+    x[2] = maxcols;
+
+    mvaddch(y[0], x[0], '0');
+    mvaddch(y[1], x[1], '1');
+    mvaddch(y[2], x[2], '2');
+
+    /* initialize yi,xi with random values */
+
+    yi = getrandom_int() % maxlines;
+    xi = getrandom_int() % maxcols;
+
+    mvaddch(yi, xi, '.');
+
+    /* iterate the triangle */
+
+    for (iter = 0; iter < ITERMAX; iter++) {
+        index = getrandom_int() % 3;
+
+        yi = (yi + y[index]) / 2;
+        xi = (xi + x[index]) / 2;
+
+        mvaddch(yi, xi, '*');
+        refresh();
+    }
+
+    /* done */
+
+    mvaddstr(maxlines, 0, "Press any key to quit");
+
+    refresh();
+
+    getch();
+    endwin();
+
+    exit(0);
+}
diff --git a/lib/PDCursesMod/demos/tui.c b/lib/PDCursesMod/demos/tui.c
new file mode 100644
index 00000000000..751daf9c71e
--- /dev/null
+++ b/lib/PDCursesMod/demos/tui.c
@@ -0,0 +1,820 @@
+/********************************* tui.c ************************************/
+/*
+ * 'textual user interface'
+ *
+ * Author : P.J. Kunst <kunst@prl.philips.nl>
+ * Date   : 1993-02-25
+ */
+
+#include <ctype.h>
+#include <curses.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include "tui.h"
+
+void statusmsg(char *);
+int waitforkey(void);
+void rmerror(void);
+
+#if defined(__unix) && !defined(__DJGPP__)
+#include <unistd.h>
+#endif
+
+#ifdef A_COLOR
+# define TITLECOLOR       1       /* color pair indices */
+# define MAINMENUCOLOR    (2 | A_BOLD)
+# define MAINMENUREVCOLOR (3 | A_BOLD | A_REVERSE)
+# define SUBMENUCOLOR     (4 | A_BOLD)
+# define SUBMENUREVCOLOR  (5 | A_BOLD | A_REVERSE)
+# define BODYCOLOR        6
+# define STATUSCOLOR      (7 | A_BOLD)
+# define INPUTBOXCOLOR    8
+# define EDITBOXCOLOR     (9 | A_BOLD | A_REVERSE)
+#else
+# define TITLECOLOR       0       /* color pair indices */
+# define MAINMENUCOLOR    (A_BOLD)
+# define MAINMENUREVCOLOR (A_BOLD | A_REVERSE)
+# define SUBMENUCOLOR     (A_BOLD)
+# define SUBMENUREVCOLOR  (A_BOLD | A_REVERSE)
+# define BODYCOLOR        0
+# define STATUSCOLOR      (A_BOLD)
+# define INPUTBOXCOLOR    0
+# define EDITBOXCOLOR     (A_BOLD | A_REVERSE)
+#endif
+
+
+#define th 1     /* title window height */
+#define mh 1     /* main menu height */
+#define sh 2     /* status window height */
+#define bh (LINES - th - mh - sh)   /* body window height */
+#define bw COLS  /* body window width */
+
+
+/******************************* STATIC ************************************/
+
+static WINDOW *wtitl, *wmain, *wbody, *wstat; /* title, menu, body, status win*/
+static int nexty, nextx;
+static int key = ERR, ch = ERR;
+static bool quit = FALSE;
+static bool incurses = FALSE;
+
+#ifndef PDCURSES
+static char wordchar(void)
+{
+    return 0x17;    /* ^W */
+}
+#endif
+
+static char *padstr(char *s, int length)
+{
+    static char buf[MAXSTRLEN];
+    char fmt[10];
+
+    sprintf(fmt, (int)strlen(s) > length ? "%%.%ds" : "%%-%ds", length);
+    sprintf(buf, fmt, s);
+
+    return buf;
+}
+
+static char *prepad(char *s, int length)
+{
+    int i;
+    char *p = s;
+
+    if (length > 0)
+    {
+        memmove((void *)(s + length), (const void *)s, strlen(s) + 1);
+
+        for (i = 0; i < length; i++)
+            *p++ = ' ';
+    }
+
+    return s;
+}
+
+static void rmline(WINDOW *win, int nr)   /* keeps box lines intact */
+{
+    mvwaddstr(win, nr, 1, padstr(" ", bw - 2));
+    wrefresh(win);
+}
+
+static void initcolor(void)
+{
+#ifdef A_COLOR
+    if (has_colors())
+        start_color();
+
+    /* foreground, background */
+
+    init_pair(TITLECOLOR       & ~A_ATTR, COLOR_BLACK, COLOR_CYAN);
+    init_pair(MAINMENUCOLOR    & ~A_ATTR, COLOR_WHITE, COLOR_CYAN);
+    init_pair(MAINMENUREVCOLOR & ~A_ATTR, COLOR_WHITE, COLOR_BLACK);
+    init_pair(SUBMENUCOLOR     & ~A_ATTR, COLOR_WHITE, COLOR_CYAN);
+    init_pair(SUBMENUREVCOLOR  & ~A_ATTR, COLOR_WHITE, COLOR_BLACK);
+    init_pair(BODYCOLOR        & ~A_ATTR, COLOR_WHITE, COLOR_BLUE);
+    init_pair(STATUSCOLOR      & ~A_ATTR, COLOR_WHITE, COLOR_CYAN);
+    init_pair(INPUTBOXCOLOR    & ~A_ATTR, COLOR_BLACK, COLOR_CYAN);
+    init_pair(EDITBOXCOLOR     & ~A_ATTR, COLOR_WHITE, COLOR_BLACK);
+#endif
+}
+
+static void setcolor(WINDOW *win, chtype color)
+{
+    chtype attr = color & A_ATTR;  /* extract Bold, Reverse, Blink bits */
+
+#ifdef A_COLOR
+    attr &= ~A_REVERSE;  /* ignore reverse, use colors instead! */
+    wattrset(win, COLOR_PAIR(color & A_CHARTEXT) | attr);
+#else
+    attr &= ~A_BOLD;     /* ignore bold, gives messy display on HP-UX */
+    wattrset(win, attr);
+#endif
+}
+
+static void colorbox(WINDOW *win, chtype color, int hasbox)
+{
+    int maxy;
+#ifndef PDCURSES
+    int maxx;
+#endif
+    chtype attr = color & A_ATTR;  /* extract Bold, Reverse, Blink bits */
+
+    setcolor(win, color);
+
+#ifdef A_COLOR
+    if (has_colors())
+        wbkgd(win, COLOR_PAIR(color & A_CHARTEXT) | (attr & ~A_REVERSE));
+    else
+#endif
+        wbkgd(win, attr);
+
+    werase(win);
+
+#ifdef PDCURSES
+    maxy = getmaxy(win);
+#else
+    getmaxyx(win, maxy, maxx);
+#endif
+    if (hasbox && (maxy > 2))
+        box(win, 0, 0);
+
+    touchwin(win);
+    wrefresh(win);
+}
+
+static void idle(void)
+{
+    char buf[MAXSTRLEN];
+    time_t t;
+    struct tm *tp;
+
+    if (time (&t) == -1)
+        return;  /* time not available */
+
+    tp = localtime(&t);
+    sprintf(buf, " %.4d-%.2d-%.2d  %.2d:%.2d:%.2d",
+            tp->tm_year + 1900, tp->tm_mon + 1, tp->tm_mday,
+            tp->tm_hour, tp->tm_min, tp->tm_sec);
+
+    mvwaddstr(wtitl, 0, bw - (int)strlen(buf) - 2, buf);
+    wrefresh(wtitl);
+}
+
+static void menudim(menu *mp, int *lines, int *columns)
+{
+    int n, l, mmax = 0;
+
+    for (n = 0; mp->func; n++, mp++)
+        if ((l = (int)strlen(mp->name)) > mmax) mmax = l;
+
+    *lines = n;
+    *columns = mmax + 2;
+}
+
+static void setmenupos(int y, int x)
+{
+    nexty = y;
+    nextx = x;
+}
+
+static void getmenupos(int *y, int *x)
+{
+    *y = nexty;
+    *x = nextx;
+}
+
+static int hotkey(const char *s)
+{
+    int c0 = *s;    /* if no upper case found, return first char */
+
+    for (; *s; s++)
+        if (isupper((unsigned char)*s))
+            break;
+
+    return *s ? *s : c0;
+}
+
+static void repaintmenu(WINDOW *wmenu, menu *mp)
+{
+    int i;
+    menu *p = mp;
+
+    for (i = 0; p->func; i++, p++)
+        mvwaddstr(wmenu, i + 1, 2, p->name);
+
+    touchwin(wmenu);
+    wrefresh(wmenu);
+}
+
+static void repaintmainmenu(int width, menu *mp)
+{
+    int i;
+    menu *p = mp;
+
+    for (i = 0; p->func; i++, p++)
+        mvwaddstr(wmain, 0, i * width, prepad(padstr(p->name, width - 1), 1));
+
+    touchwin(wmain);
+    wrefresh(wmain);
+}
+
+static void mainhelp(void)
+{
+#ifdef ALT_X
+    statusmsg("Use arrow keys and Enter to select (Alt-X to quit)");
+#else
+    statusmsg("Use arrow keys and Enter to select");
+#endif
+}
+
+static void mainmenu(menu *mp)
+{
+    int nitems, barlen, old = -1, cur = 0, c, cur0;
+
+    menudim(mp, &nitems, &barlen);
+    repaintmainmenu(barlen, mp);
+
+    while (!quit)
+    {
+        if (cur != old)
+        {
+            if (old != -1)
+            {
+                mvwaddstr(wmain, 0, old * barlen,
+                          prepad(padstr(mp[old].name, barlen - 1), 1));
+
+                statusmsg(mp[cur].desc);
+            }
+            else
+                mainhelp();
+
+            setcolor(wmain, MAINMENUREVCOLOR);
+
+            mvwaddstr(wmain, 0, cur * barlen,
+                      prepad(padstr(mp[cur].name, barlen - 1), 1));
+
+            setcolor(wmain, MAINMENUCOLOR);
+            old = cur;
+            wrefresh(wmain);
+        }
+
+        switch (c = (key != ERR ? key : waitforkey()))
+        {
+        case KEY_DOWN:
+        case '\n':              /* menu item selected */
+            touchwin(wbody);
+            wrefresh(wbody);
+            rmerror();
+            setmenupos(th + mh, cur * barlen);
+            curs_set(1);
+            (mp[cur].func)();   /* perform function */
+            curs_set(0);
+
+            switch (key)
+            {
+            case KEY_LEFT:
+                cur = (cur + nitems - 1) % nitems;
+                key = '\n';
+                break;
+
+            case KEY_RIGHT:
+                cur = (cur + 1) % nitems;
+                key = '\n';
+                break;
+
+            default:
+                key = ERR;
+            }
+
+            repaintmainmenu(barlen, mp);
+            old = -1;
+            break;
+
+        case KEY_LEFT:
+            cur = (cur + nitems - 1) % nitems;
+            break;
+
+        case KEY_RIGHT:
+            cur = (cur + 1) % nitems;
+            break;
+
+        case KEY_ESC:
+            mainhelp();
+            break;
+
+        default:
+            cur0 = cur;
+
+            do
+            {
+                cur = (cur + 1) % nitems;
+
+            } while ((cur != cur0) && (hotkey(mp[cur].name) != toupper(c)));
+
+            if (hotkey(mp[cur].name) == toupper(c))
+                key = '\n';
+        }
+
+    }
+
+    rmerror();
+    touchwin(wbody);
+    wrefresh(wbody);
+}
+
+static void cleanup(void)   /* cleanup curses settings */
+{
+    if (incurses)
+    {
+        delwin(wtitl);
+        delwin(wmain);
+        delwin(wbody);
+        delwin(wstat);
+        curs_set(1);
+        endwin();
+        incurses = FALSE;
+    }
+}
+
+
+/******************************* EXTERNAL **********************************/
+
+void clsbody(void)
+{
+    werase(wbody);
+    wmove(wbody, 0, 0);
+}
+
+int bodylen(void)
+{
+#ifdef PDCURSES
+    return getmaxy(wbody);
+#else
+    int maxy, maxx;
+
+    getmaxyx(wbody, maxy, maxx);
+    return maxy;
+#endif
+}
+
+WINDOW *bodywin(void)
+{
+    return wbody;
+}
+
+void rmerror(void)
+{
+    rmline(wstat, 0);
+}
+
+void rmstatus(void)
+{
+    rmline(wstat, 1);
+}
+
+void titlemsg(char *msg)
+{
+    mvwaddstr(wtitl, 0, 2, padstr(msg, bw - 3));
+    wrefresh(wtitl);
+}
+
+void bodymsg(char *msg)
+{
+    waddstr(wbody, msg);
+    wrefresh(wbody);
+}
+
+void errormsg(char *msg)
+{
+    beep();
+    mvwaddstr(wstat, 0, 2, padstr(msg, bw - 3));
+    wrefresh(wstat);
+}
+
+void statusmsg(char *msg)
+{
+    mvwaddstr(wstat, 1, 2, padstr(msg, bw - 3));
+    wrefresh(wstat);
+}
+
+bool keypressed(void)
+{
+    ch = wgetch(wbody);
+
+    return ch != ERR;
+}
+
+int getkey(void)
+{
+    int c = ch;
+
+    ch = ERR;
+#ifdef ALT_X
+    quit = (c == ALT_X);    /* PC only ! */
+#endif
+    return c;
+}
+
+int waitforkey(void)
+{
+    do idle(); while (!keypressed());
+    return getkey();
+}
+
+void DoExit(void)   /* terminate program */
+{
+    quit = TRUE;
+}
+
+void domenu(menu *mp)
+{
+    int y, x, nitems, barlen, mheight, mw, old = -1, cur = 0, cur0;
+    bool stop = FALSE;
+    WINDOW *wmenu;
+
+    curs_set(0);
+    getmenupos(&y, &x);
+    menudim(mp, &nitems, &barlen);
+    mheight = nitems + 2;
+    mw = barlen + 2;
+    wmenu = newwin(mheight, mw, y, x);
+    colorbox(wmenu, SUBMENUCOLOR, 1);
+    repaintmenu(wmenu, mp);
+
+    key = ERR;
+
+    while (!stop && !quit)
+    {
+        if (cur != old)
+        {
+            if (old != -1)
+                mvwaddstr(wmenu, old + 1, 1,
+                          prepad(padstr(mp[old].name, barlen - 1), 1));
+
+            setcolor(wmenu, SUBMENUREVCOLOR);
+            mvwaddstr(wmenu, cur + 1, 1,
+                      prepad(padstr(mp[cur].name, barlen - 1), 1));
+
+            setcolor(wmenu, SUBMENUCOLOR);
+            statusmsg(mp[cur].desc);
+
+            old = cur;
+            wrefresh(wmenu);
+        }
+
+        switch (key = ((key != ERR) ? key : waitforkey()))
+        {
+        case '\n':          /* menu item selected */
+            touchwin(wbody);
+            wrefresh(wbody);
+            setmenupos(y + 1, x + 1);
+            rmerror();
+
+            key = ERR;
+            curs_set(1);
+            (mp[cur].func)();   /* perform function */
+            curs_set(0);
+
+            repaintmenu(wmenu, mp);
+
+            old = -1;
+            break;
+
+        case KEY_UP:
+            cur = (cur + nitems - 1) % nitems;
+            key = ERR;
+            break;
+
+        case KEY_DOWN:
+            cur = (cur + 1) % nitems;
+            key = ERR;
+            break;
+
+        case KEY_ESC:
+        case KEY_LEFT:
+        case KEY_RIGHT:
+            if (key == KEY_ESC)
+                key = ERR;  /* return to prev submenu */
+
+            stop = TRUE;
+            break;
+
+        default:
+            cur0 = cur;
+
+            do
+            {
+                cur = (cur + 1) % nitems;
+
+            } while ((cur != cur0) &&
+                     (hotkey(mp[cur].name) != toupper((int)key)));
+
+            key = (hotkey(mp[cur].name) == toupper((int)key)) ? '\n' : ERR;
+        }
+
+    }
+
+    rmerror();
+    delwin(wmenu);
+    touchwin(wbody);
+    wrefresh(wbody);
+}
+
+void startmenu(menu *mp, char *mtitle)
+{
+    initscr();
+    incurses = TRUE;
+    initcolor();
+
+    wtitl = subwin(stdscr, th, bw, 0, 0);
+    wmain = subwin(stdscr, mh, bw, th, 0);
+    wbody = subwin(stdscr, bh, bw, th + mh, 0);
+    wstat = subwin(stdscr, sh, bw, th + mh + bh, 0);
+
+    colorbox(wtitl, TITLECOLOR, 0);
+    colorbox(wmain, MAINMENUCOLOR, 0);
+    colorbox(wbody, BODYCOLOR, 0);
+    colorbox(wstat, STATUSCOLOR, 0);
+
+    if (mtitle)
+        titlemsg(mtitle);
+
+    cbreak();              /* direct input (no newline required)... */
+    noecho();              /* ... without echoing */
+    curs_set(0);           /* hide cursor (if possible) */
+    nodelay(wbody, TRUE);  /* don't wait for input... */
+    halfdelay(10);         /* ...well, no more than a second, anyway */
+    keypad(wbody, TRUE);   /* enable cursor keys */
+    scrollok(wbody, TRUE); /* enable scrolling in main window */
+
+    leaveok(stdscr, TRUE);
+    leaveok(wtitl, TRUE);
+    leaveok(wmain, TRUE);
+    leaveok(wstat, TRUE);
+
+    mainmenu(mp);
+
+    cleanup();
+}
+
+static void repainteditbox(WINDOW *win, int x, char *buf)
+{
+#ifndef PDCURSES
+    int maxy;
+#endif
+    int maxx;
+
+#ifdef PDCURSES
+    maxx = getmaxx(win);
+#else
+    getmaxyx(win, maxy, maxx);
+#endif
+    werase(win);
+    mvwprintw(win, 0, 0, "%s", padstr(buf, maxx));
+    wmove(win, 0, x);
+    wrefresh(win);
+}
+
+/*
+
+  weditstr()     - edit string
+
+  Description:
+    The initial value of 'str' with a maximum length of 'field' - 1,
+    which is supplied by the calling routine, is editted. The user's
+    erase (^H), kill (^U) and delete word (^W) chars are interpreted.
+    The PC insert or Tab keys toggle between insert and edit mode.
+    Escape aborts the edit session, leaving 'str' unchanged.
+    Enter, Up or Down Arrow are used to accept the changes to 'str'.
+    NOTE: editstr(), mveditstr(), and mvweditstr() are macros.
+
+  Return Value:
+    Returns the input terminating character on success (Escape,
+    Enter, Up or Down Arrow) and ERR on error.
+
+  Errors:
+    It is an error to call this function with a NULL window pointer.
+    The length of the initial 'str' must not exceed 'field' - 1.
+
+*/
+
+int weditstr(WINDOW *win, char *buf, int field)
+{
+    char org[MAXSTRLEN], *tp, *bp = buf;
+    bool defdisp = TRUE, stop = FALSE, insert = FALSE;
+    int cury, curx, begy, begx;
+    chtype oldattr;
+    WINDOW *wedit;
+    int c = 0;
+
+    if ((field >= MAXSTRLEN) || (buf == NULL) ||
+        ((int)strlen(buf) > field - 1))
+        return ERR;
+
+    strcpy(org, buf);   /* save original */
+
+    wrefresh(win);
+    getyx(win, cury, curx);
+    getbegyx(win, begy, begx);
+
+    wedit = subwin(win, 1, field, begy + cury, begx + curx);
+    oldattr = getattrs(wedit);
+    colorbox(wedit, EDITBOXCOLOR, 0);
+
+    keypad(wedit, TRUE);
+    curs_set(1);
+
+    while (!stop)
+    {
+        idle();
+        repainteditbox(wedit, (int)( bp - buf), buf);
+
+        switch (c = wgetch(wedit))
+        {
+        case ERR:
+            break;
+
+        case KEY_ESC:
+            strcpy(buf, org);   /* restore original */
+            stop = TRUE;
+            break;
+
+        case '\n':
+        case KEY_UP:
+        case KEY_DOWN:
+            stop = TRUE;
+            break;
+
+        case KEY_LEFT:
+            if (bp > buf)
+                bp--;
+            break;
+
+        case KEY_RIGHT:
+            defdisp = FALSE;
+            if (bp - buf < (int)strlen(buf))
+                bp++;
+            break;
+
+        case '\t':            /* TAB -- because insert
+                                  is broken on HPUX */
+        case KEY_IC:          /* enter insert mode */
+        case KEY_EIC:         /* exit insert mode */
+            defdisp = FALSE;
+            insert = !insert;
+
+            curs_set(insert ? 2 : 1);
+            break;
+
+        default:
+            if (c == erasechar())       /* backspace, ^H */
+            {
+                if (bp > buf)
+                {
+                    memmove((void *)(bp - 1), (const void *)bp, strlen(bp) + 1);
+                    bp--;
+                }
+            }
+            else if (c == killchar())   /* ^U */
+            {
+                bp = buf;
+                *bp = '\0';
+            }
+            else if (c == wordchar())   /* ^W */
+            {
+                tp = bp;
+
+                while ((bp > buf) && (*(bp - 1) == ' '))
+                    bp--;
+                while ((bp > buf) && (*(bp - 1) != ' '))
+                    bp--;
+
+                memmove((void *)bp, (const void *)tp, strlen(tp) + 1);
+            }
+            else if (isprint(c))
+            {
+                if (defdisp)
+                {
+                    bp = buf;
+                    *bp = '\0';
+                    defdisp = FALSE;
+                }
+
+                if (insert)
+                {
+                    if ((int)strlen(buf) < field - 1)
+                    {
+                        memmove((void *)(bp + 1), (const void *)bp,
+                                strlen(bp) + 1);
+
+                        *bp++ = (char)c;
+                    }
+                }
+                else if (bp - buf < field - 1)
+                {
+                    /* append new string terminator */
+
+                    if (!*bp)
+                        bp[1] = '\0';
+
+                    *bp++ = (char)c;
+                }
+            }
+        }
+    }
+
+    curs_set(0);
+
+    wattrset(wedit, oldattr);
+    repainteditbox(wedit, (int)( bp - buf), buf);
+    delwin(wedit);
+
+    return c;
+}
+
+WINDOW *winputbox(WINDOW *win, int nlines, int ncols)
+{
+    WINDOW *winp;
+    int cury, curx, begy, begx;
+
+    getyx(win, cury, curx);
+    getbegyx(win, begy, begx);
+
+    winp = newwin(nlines, ncols, begy + cury, begx + curx);
+    colorbox(winp, INPUTBOXCOLOR, 1);
+
+    return winp;
+}
+
+int getstrings(char *desc[], char *buf[], int field)
+{
+    WINDOW *winput;
+    int oldy, oldx, maxy, maxx, nlines, ncols, i, n, l, mmax = 0;
+    int c = 0;
+    bool stop = FALSE;
+
+    for (n = 0; desc[n]; n++)
+        if ((l = (int)strlen(desc[n])) > mmax)
+            mmax = l;
+
+    nlines = n + 2; ncols = mmax + field + 4;
+    getyx(wbody, oldy, oldx);
+    getmaxyx(wbody, maxy, maxx);
+
+    winput = mvwinputbox(wbody, (maxy - nlines) / 2, (maxx - ncols) / 2,
+        nlines, ncols);
+
+    for (i = 0; i < n; i++)
+        mvwprintw(winput, i + 1, 2, "%s", desc[i]);
+
+    i = 0;
+
+    while (!stop)
+    {
+        switch (c = mvweditstr(winput, i+1, mmax+3, buf[i], field))
+        {
+        case KEY_ESC:
+            stop = TRUE;
+            break;
+
+        case KEY_UP:
+            i = (i + n - 1) % n;
+            break;
+
+        case '\n':
+        case '\t':
+        case KEY_DOWN:
+            if (++i == n)
+                stop = TRUE;    /* all passed? */
+        }
+    }
+
+    delwin(winput);
+    touchwin(wbody);
+    wmove(wbody, oldy, oldx);
+    wrefresh(wbody);
+
+    return c;
+}
diff --git a/lib/PDCursesMod/demos/tui.h b/lib/PDCursesMod/demos/tui.h
new file mode 100644
index 00000000000..98bfd5f25b6
--- /dev/null
+++ b/lib/PDCursesMod/demos/tui.h
@@ -0,0 +1,65 @@
+/*
+ * 'textual user interface'
+ *
+ * Author : P.J. Kunst <kunst@prl.philips.nl>
+ * Date   : 25-02-93
+ */
+
+#ifndef _TUI_H_
+#define _TUI_H_
+
+#include <curses.h>
+
+#ifdef A_COLOR
+#define A_ATTR  (A_ATTRIBUTES ^ A_COLOR)  /* A_BLINK, A_REVERSE, A_BOLD */
+#else
+#define A_ATTR  (A_ATTRIBUTES)            /* standard UNIX attributes */
+#endif
+
+#define MAXSTRLEN  256
+#define KEY_ESC    0x1b     /* Escape */
+
+typedef void (*FUNC)(void);
+
+typedef struct 
+{
+    char *name; /* item label */
+    FUNC  func; /* (pointer to) function */
+    char *desc; /* function description */
+} menu;
+
+/* ANSI C function prototypes: */
+
+void    clsbody(void);
+int     bodylen(void);
+WINDOW *bodywin(void);
+
+void    rmerror(void);
+void    rmstatus(void);
+
+void    titlemsg(char *msg);
+void    bodymsg(char *msg);
+void    errormsg(char *msg);
+void    statusmsg(char *msg);
+
+bool    keypressed(void);
+int     getkey(void);
+int     waitforkey(void);
+
+void    DoExit(void);
+void    startmenu(menu *mp, char *title);
+void    domenu(menu *mp);
+
+int     weditstr(WINDOW *win, char *buf, int field);
+WINDOW *winputbox(WINDOW *win, int nlines, int ncols);
+int     getstrings(char *desc[], char *buf[], int field);
+
+#define editstr(s,f)           (weditstr(stdscr,s,f))
+#define mveditstr(y,x,s,f)     (move(y,x)==ERR?ERR:editstr(s,f))
+#define mvweditstr(w,y,x,s,f)  (wmove(w,y,x)==ERR?ERR:weditstr(w,s,f))
+
+#define inputbox(l,c)          (winputbox(stdscr,l,c))
+#define mvinputbox(y,x,l,c)    (move(y,x)==ERR?w:inputbox(l,c))
+#define mvwinputbox(w,y,x,l,c) (wmove(w,y,x)==ERR?w:winputbox(w,l,c))
+
+#endif
diff --git a/lib/PDCursesMod/demos/tuidemo.c b/lib/PDCursesMod/demos/tuidemo.c
new file mode 100644
index 00000000000..585e348aca5
--- /dev/null
+++ b/lib/PDCursesMod/demos/tuidemo.c
@@ -0,0 +1,228 @@
+/*
+ * Author : P.J. Kunst <kunst@prl.philips.nl>
+ * Date   : 1993-02-25
+ *
+ * Purpose: This program demonstrates the use of the 'curses' library
+ *          for the creation of (simple) menu-operated programs.
+ *          In the PDCurses version, use is made of colors for the
+ *          highlighting of subwindows (title bar, status bar etc).
+ *
+ * Acknowledgement: some ideas were borrowed from Mark Hessling's
+ *                  version of the 'testcurs' program.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <locale.h>
+#include "tui.h"
+
+/* change this if source at other location */
+
+#ifdef PDC_FORCE_UTF8
+# define FNAME "../demos/UTF-8-demo.txt"
+#else
+# define FNAME "../demos/tui.c"
+#endif
+
+/**************************** strings entry box ***************************/
+
+void address(void)
+{
+    char *fieldname[6] =
+    {
+        "Name", "Street", "City", "State", "Country", (char *)0
+    };
+
+    char *fieldbuf[5];
+    WINDOW *wbody = bodywin();
+    int i, field = 50;
+
+    for (i = 0; i < 5; i++)
+        fieldbuf[i] = calloc(1, field + 1);
+
+    if (getstrings(fieldname, fieldbuf, field) != KEY_ESC)
+    {
+        for (i = 0; fieldname[i]; i++)
+            wprintw(wbody, "%10s : %s\n",
+                fieldname[i], fieldbuf[i]);
+
+        wrefresh(wbody);
+    }
+
+    for (i = 0; i < 5; i++)
+        free(fieldbuf[i]);
+}
+
+/**************************** string entry box ****************************/
+
+char *getfname(char *desc, char *fname, int field)
+{
+    char *fieldname[2];
+    char *fieldbuf[1];
+
+    fieldname[0] = desc;
+    fieldname[1] = 0;
+    fieldbuf[0] = fname;
+
+    return (getstrings(fieldname, fieldbuf, field) == KEY_ESC) ? NULL : fname;
+}
+
+/**************************** a very simple file browser ******************/
+
+void showfile(char *fname)
+{
+    int i, bh = bodylen();
+    FILE *fp;
+    char buf[MAXSTRLEN];
+    bool ateof = FALSE;
+
+    statusmsg("FileBrowser: Hit key to continue, Q to quit");
+
+    if ((fp = fopen(fname, "r")) != NULL)   /* file available? */
+    {
+        while (!ateof)
+        {
+            clsbody();
+
+            for (i = 0; i < bh - 1 && !ateof; i++)
+            {
+                if (fgets(buf, MAXSTRLEN, fp))
+                    bodymsg(buf);
+                else
+                    ateof = TRUE;
+            }
+
+            switch (waitforkey())
+            {
+            case 'Q':
+            case 'q':
+            case 0x1b:
+                ateof = TRUE;
+            }
+        }
+
+        fclose(fp);
+    }
+    else
+    {
+        sprintf(buf, "ERROR: file '%s' not found", fname);
+        errormsg(buf);
+    }
+}
+
+/***************************** forward declarations ***********************/
+
+void sub0(void), sub1(void), sub2(void), sub3(void);
+void func1(void), func2(void);
+void subfunc1(void), subfunc2(void);
+void subsub(void);
+
+/***************************** menus initialization ***********************/
+
+menu MainMenu[] =
+{
+    { "Asub", sub0, "Go inside first submenu" },
+    { "Bsub", sub1, "Go inside second submenu" },
+    { "Csub", sub2, "Go inside third submenu" },
+    { "Dsub", sub3, "Go inside fourth submenu" },
+    { "", (FUNC)0, "" }   /* always add this as the last item! */
+};
+
+menu SubMenu0[] =
+{
+    { "Exit", DoExit, "Terminate program" },
+    { "", (FUNC)0, "" }
+};
+
+menu SubMenu1[] =
+{
+    { "OneBeep", func1, "Sound one beep" },
+    { "TwoBeeps", func2, "Sound two beeps" },
+    { "", (FUNC)0, "" }
+};
+
+menu SubMenu2[] =
+{
+    { "Browse", subfunc1, "Source file lister" },
+    { "Input", subfunc2, "Interactive file lister" },
+    { "Address", address, "Get address data" },
+    { "", (FUNC)0, "" }
+};
+
+menu SubMenu3[] =
+{
+    { "SubSub", subsub, "Go inside sub-submenu" },
+    { "", (FUNC)0, "" }
+};
+
+/***************************** main menu functions ************************/
+
+void sub0(void)
+{
+    domenu(SubMenu0);
+}
+
+void sub1(void)
+{
+    domenu(SubMenu1);
+}
+
+void sub2(void)
+{
+    domenu(SubMenu2);
+}
+
+void sub3(void)
+{
+    domenu(SubMenu3);
+}
+
+/***************************** submenu1 functions *************************/
+
+void func1(void)
+{
+    beep();
+    bodymsg("One beep! ");
+}
+
+void func2(void)
+{
+    beep();
+    bodymsg("Two beeps! ");
+    beep();
+}
+
+/***************************** submenu2 functions *************************/
+
+void subfunc1(void)
+{
+    showfile(FNAME);
+}
+
+void subfunc2(void)
+{
+    char fname[MAXSTRLEN];
+
+    strcpy(fname, FNAME);
+    if (getfname ("File to browse:", fname, 50))
+        showfile(fname);
+}
+
+/***************************** submenu3 functions *************************/
+
+void subsub(void)
+{
+    domenu(SubMenu2);
+}
+
+/***************************** start main menu  ***************************/
+
+int main( void)
+{
+    setlocale(LC_ALL, "");
+
+    startmenu(MainMenu, "TUI - 'textual user interface' demonstration program");
+
+    return 0;
+}
diff --git a/lib/PDCursesMod/demos/version.c b/lib/PDCursesMod/demos/version.c
new file mode 100644
index 00000000000..41a0d060ab0
--- /dev/null
+++ b/lib/PDCursesMod/demos/version.c
@@ -0,0 +1,65 @@
+#include <stdio.h>
+#include <curses.h>
+
+/* Example usage of the PDC_get_version function declared in curses.h.  The
+general idea is that,  while we have various macros defined to tell us
+which version of PDCurses we're using (PDC_VER_MAJOR,  PDC_VER_MINOR,
+PDC_WIDE,  etc.),  these may not match the library to which we are linked;
+it may have been compiled with different flags,  or a different chtype size
+(16,  32,  or 64-bit),  etc. This is a small issue with static libraries,
+but with DLLs (Windows and OS/2) or shared libraries (*nix and *BSD),  we
+may not really control which DLL/shared library happens to be available.
+
+In such cases,  the PDC_VERSION structure tells us how the library was
+compiled.
+
+Note that this can be used even though we never call initscr().  The idea
+is that version checking can be done without attempting function calls,
+some of which would fail if (for example) the library had been compiled
+with wide characters and the application had not,  or the version numbers
+didn't match,  or the size of chtypes differed.  */
+
+int main( const int argc, const char **argv)
+{
+   static const char *port_text[] = { "X11", "Win32 console", "Win32a",
+         "DOS", "OS/2", "SDL1", "SDL2", "VT" };
+   PDC_VERSION vinfo;
+
+   printf( "Compiled as version %d.%d.%d, chtype size %d\n",
+            PDC_VER_MAJOR, PDC_VER_MINOR, PDC_VER_CHANGE,
+            (int)sizeof( chtype));
+#ifdef PDC_WIDE
+   printf( "Compiled with PDC_WIDE defined\n");
+#else
+   printf( "Compiled with PDC_WIDE undefined\n");
+#endif
+#ifdef PDC_FORCE_UTF8
+   printf( "Compiled with PDC_FORCE_UTF8 defined\n");
+#else
+   printf( "Compiled with PDC_FORCE_UTF8 undefined\n");
+#endif
+
+   PDC_get_version( &vinfo);
+   printf( "\nInformation on the library :\n");
+   printf( "PDCurses version %d.%d.%d, chtype size %d\n",
+         (int)vinfo.major, (int)vinfo.minor,
+         (int)vinfo.change, (int)vinfo.csize);
+   printf( "Port %d (%s)\n",
+         vinfo.port,
+         port_text[vinfo.port]);
+   printf( "debug = %c   is_wide = %c    is_utf8 = %c\n",
+         vinfo.flags & PDC_VFLAG_DEBUG ? 'Y' : 'N',
+         vinfo.flags & PDC_VFLAG_WIDE ? 'Y' : 'N',
+         vinfo.flags & PDC_VFLAG_UTF8 ? 'Y' : 'N');
+   printf( "is_rgb = %c    is_dll = %c\n",
+         vinfo.flags & PDC_VFLAG_RGB ? 'Y' : 'N',
+         vinfo.flags & PDC_VFLAG_DLL ? 'Y' : 'N');
+   printf( "longname is '%s'\n", longname( ));
+   printf( "Curses version string is '%s'\n", curses_version( ));
+
+   if( vinfo.major != PDC_VER_MAJOR
+             || vinfo.minor != PDC_VER_MINOR
+             || vinfo.change != PDC_VER_CHANGE)
+      printf( "Versions do not match!\n");
+   return( 0);
+}
diff --git a/lib/PDCursesMod/demos/worm.c b/lib/PDCursesMod/demos/worm.c
new file mode 100644
index 00000000000..5102ab601c3
--- /dev/null
+++ b/lib/PDCursesMod/demos/worm.c
@@ -0,0 +1,446 @@
+/****************************************************************************
+ * Copyright (c) 2005 Free Software Foundation, Inc.                        *
+ *                                                                          *
+ * Permission is hereby granted, free of charge, to any person obtaining a  *
+ * copy of this software and associated documentation files (the            *
+ * "Software"), to deal in the Software without restriction, including      *
+ * without limitation the rights to use, copy, modify, merge, publish,      *
+ * distribute, distribute with modifications, sublicense, and/or sell       *
+ * copies of the Software, and to permit persons to whom the Software is    *
+ * furnished to do so, subject to the following conditions:                 *
+ *                                                                          *
+ * The above copyright notice and this permission notice shall be included  *
+ * in all copies or substantial portions of the Software.                   *
+ *                                                                          *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
+ * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
+ *                                                                          *
+ * Except as contained in this notice, the name(s) of the above copyright   *
+ * holders shall not be used in advertising or otherwise to promote the     *
+ * sale, use or other dealings in this Software without prior written       *
+ * authorization.                                                           *
+ ****************************************************************************/
+
+/*
+
+         @@@        @@@    @@@@@@@@@@     @@@@@@@@@@@    @@@@@@@@@@@@
+         @@@        @@@   @@@@@@@@@@@@    @@@@@@@@@@@@   @@@@@@@@@@@@@
+         @@@        @@@  @@@@      @@@@   @@@@           @@@@ @@@  @@@@
+         @@@   @@   @@@  @@@        @@@   @@@            @@@  @@@   @@@
+         @@@  @@@@  @@@  @@@        @@@   @@@            @@@  @@@   @@@
+         @@@@ @@@@ @@@@  @@@        @@@   @@@            @@@  @@@   @@@
+          @@@@@@@@@@@@   @@@@      @@@@   @@@            @@@  @@@   @@@
+           @@@@  @@@@     @@@@@@@@@@@@    @@@            @@@  @@@   @@@
+            @@    @@       @@@@@@@@@@     @@@            @@@  @@@   @@@
+
+                                 Eric P. Scott
+                          Caltech High Energy Physics
+                                 October, 1980
+
+                           Color by Eric S. Raymond
+                                  July, 1995
+
+Options:
+        -f                      fill screen with copies of 'WORM' at start.
+        -l <n>                  set worm length
+        -n <n>                  set number of worms
+        -t                      make worms leave droppings
+*/
+
+#include <curses.h>
+#include <stdlib.h>
+#include <time.h>
+
+#define FLAVORS 7
+
+static chtype flavor[FLAVORS] =
+{
+    'O', '*', '#', '$', '%', '0', '@'
+};
+
+static const short xinc[] =
+{
+    1, 1, 1, 0, -1, -1, -1, 0
+},
+yinc[] =
+{
+    -1, 0, 1, 1, 1, 0, -1, -1
+};
+
+static struct worm
+{
+    int orientation, head;
+    short *xpos, *ypos;
+} worm[40];
+
+static const char *field;
+static int length = 16, number = 3;
+static chtype trail = ' ';
+
+static const struct options
+{
+    int nopts;
+    int opts[3];
+} normal[8] =
+{
+    { 3, { 7, 0, 1 } }, { 3, { 0, 1, 2 } }, { 3, { 1, 2, 3 } },
+    { 3, { 2, 3, 4 } }, { 3, { 3, 4, 5 } }, { 3, { 4, 5, 6 } },
+    { 3, { 5, 6, 7 } }, { 3, { 6, 7, 0 } }
+},
+upper[8] =
+{
+    { 1, { 1, 0, 0 } }, { 2, { 1, 2, 0 } }, { 0, { 0, 0, 0 } },
+    { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } }, { 2, { 4, 5, 0 } },
+    { 1, { 5, 0, 0 } }, { 2, { 1, 5, 0 } }
+},
+left[8] =
+{
+    { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } },
+    { 2, { 2, 3, 0 } }, { 1, { 3, 0, 0 } }, { 2, { 3, 7, 0 } },
+    { 1, { 7, 0, 0 } }, { 2, { 7, 0, 0 } }
+},
+right[8] =
+{
+    { 1, { 7, 0, 0 } }, { 2, { 3, 7, 0 } }, { 1, { 3, 0, 0 } },
+    { 2, { 3, 4, 0 } }, { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } },
+    { 0, { 0, 0, 0 } }, { 2, { 6, 7, 0 } }
+},
+lower[8] =
+{
+    { 0, { 0, 0, 0 } }, { 2, { 0, 1, 0 } }, { 1, { 1, 0, 0 } },
+    { 2, { 1, 5, 0 } }, { 1, { 5, 0, 0 } }, { 2, { 5, 6, 0 } },
+    { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } }
+},
+upleft[8] =
+{
+    { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } },
+    { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } }, { 1, { 3, 0, 0 } },
+    { 2, { 1, 3, 0 } }, { 1, { 1, 0, 0 } }
+},
+upright[8] =
+{
+    { 2, { 3, 5, 0 } }, { 1, { 3, 0, 0 } }, { 0, { 0, 0, 0 } },
+    { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } },
+    { 0, { 0, 0, 0 } }, { 1, { 5, 0, 0 } }
+},
+lowleft[8] =
+{
+    { 3, { 7, 0, 1 } }, { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } },
+    { 1, { 1, 0, 0 } }, { 2, { 1, 7, 0 } }, { 1, { 7, 0, 0 } },
+    { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } }
+},
+lowright[8] =
+{
+    { 0, { 0, 0, 0 } }, { 1, { 7, 0, 0 } }, { 2, { 5, 7, 0 } },
+    { 1, { 5, 0, 0 } }, { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } },
+    { 0, { 0, 0, 0 } }, { 0, { 0, 0, 0 } }
+};
+
+static void cleanup(void)
+{
+    standend();
+    refresh();
+    curs_set(1);
+    endwin();
+#ifdef PDCURSES
+    delscreen( SP);
+#endif
+}
+
+int main(int argc, char *argv[])
+{
+    const struct options *op;
+    struct worm *w;
+    short **ref, *ip;
+    time_t seed;
+    int x, y, n, h, last, bottom;
+
+    for (x = 1; x < argc; x++)
+    {
+        char *p = argv[x];
+
+        if (*p == '-')
+            p++;
+
+        switch (*p)
+        {
+        case 'f':
+            field = "WORM";
+            break;
+        case 'l':
+            if (++x == argc)
+                goto usage;
+
+            if ((length = atoi(argv[x])) < 2 || length > 1024)
+            {
+                fprintf(stderr, "%s: Invalid length\n", *argv);
+                return EXIT_FAILURE;
+            }
+
+            break;
+        case 'n':
+            if (++x == argc)
+                goto usage;
+
+            if ((number = atoi(argv[x])) < 1 || number > 40)
+            {
+                fprintf(stderr, "%s: Invalid number of worms\n", *argv);
+                return EXIT_FAILURE;
+            }
+
+            break;
+        case 't':
+            trail = '.';
+            break;
+        default:
+              usage:
+            fprintf(stderr, "usage: %s [-field] [-length #] "
+                            "[-number #] [-trail]\n", *argv);
+            return EXIT_FAILURE;
+        }
+    }
+
+#ifdef XCURSES
+    Xinitscr(argc, argv);
+#else
+    initscr();
+#endif
+    seed = time((time_t *)0);
+    srand( (unsigned)seed);
+
+    noecho();
+    cbreak();
+    nonl();
+    keypad(stdscr, TRUE);
+
+    curs_set(0);
+
+    bottom = LINES - 1;
+    last = COLS - 1;
+
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        short bg = COLOR_BLACK;
+        start_color();
+
+# if defined(NCURSES_VERSION) || (defined(PDC_BUILD) && PDC_BUILD > 3000)
+        if (use_default_colors() == OK)
+            bg = -1;
+# endif
+
+# define SET_COLOR(num, fg) \
+        init_pair(num + 1, fg, bg); \
+        flavor[num] |= COLOR_PAIR(num + 1) | A_BOLD
+
+        SET_COLOR(0, COLOR_GREEN);
+        SET_COLOR(1, COLOR_RED);
+        SET_COLOR(2, COLOR_CYAN);
+        SET_COLOR(3, COLOR_WHITE);
+        SET_COLOR(4, COLOR_MAGENTA);
+        SET_COLOR(5, COLOR_BLUE);
+        SET_COLOR(6, COLOR_YELLOW);
+    }
+#endif
+
+    ref = malloc(sizeof(short *) * LINES);
+
+    for (y = 0; y < LINES; y++)
+    {
+        ref[y] = malloc(sizeof(short) * COLS);
+
+        for (x = 0; x < COLS; x++)
+            ref[y][x] = 0;
+    }
+
+#ifdef BADCORNER
+    /* if addressing the lower right corner doesn't work in your curses */
+
+    ref[bottom][last] = 1;
+#endif
+
+    for (n = number, w = &worm[0]; --n >= 0; w++)
+    {
+        w->orientation = w->head = 0;
+
+        if ((ip = malloc(sizeof(short) * (length + 1))) == NULL)
+        {
+            fprintf(stderr, "%s: out of memory\n", *argv);
+            return EXIT_FAILURE;
+        }
+
+        w->xpos = ip;
+
+        for (x = length; --x >= 0;)
+            *ip++ = -1;
+
+        if ((ip = malloc(sizeof(short) * (length + 1))) == NULL)
+        {
+            fprintf(stderr, "%s: out of memory\n", *argv);
+            return EXIT_FAILURE;
+        }
+
+        w->ypos = ip;
+
+        for (y = length; --y >= 0;)
+            *ip++ = -1;
+    }
+
+    if (field)
+    {
+        const char *p = field;
+
+        for (y = bottom; --y >= 0;)
+            for (x = COLS; --x >= 0;)
+            {
+                addch((chtype) (*p++));
+
+                if (!*p)
+                    p = field;
+            }
+    }
+
+    napms(12);
+    refresh();
+    nodelay(stdscr, TRUE);
+
+    for (;;)
+    {
+        int ch;
+
+        if ((ch = getch()) > 0)
+        {
+#ifdef KEY_RESIZE
+            if (ch == KEY_RESIZE)
+            {
+# ifdef PDCURSES
+                resize_term(0, 0);
+# endif
+                if (last != COLS - 1)
+                {
+                    for (y = 0; y <= bottom; y++)
+                    {
+                        ref[y] = realloc(ref[y], sizeof(short) * COLS);
+
+                        for (x = last + 1; x < COLS; x++)
+                            ref[y][x] = 0;
+                    }
+
+                    last = COLS - 1;
+                }
+
+                if (bottom != LINES - 1)
+                {
+                    for (y = LINES; y <= bottom; y++)
+                        free(ref[y]);
+
+                    ref = realloc(ref, sizeof(short *) * LINES);
+
+                    for (y = bottom + 1; y < LINES; y++)
+                    {
+                        ref[y] = malloc(sizeof(short) * COLS);
+
+                        for (x = 0; x < COLS; x++)
+                            ref[y][x] = 0;
+                    }
+
+                    bottom = LINES - 1;
+                }
+            }
+
+#endif /* KEY_RESIZE */
+
+            /* Make it simple to put this into single-step mode,
+               or resume normal operation - T. Dickey */
+
+            if (ch == 'q')
+            {
+                for (y = 0; y < LINES; y++)
+                    free( ref[y]);
+                free( ref);
+                for( n = 0; n < number; n++)
+                {
+                    free( worm[n].xpos);
+                    free( worm[n].ypos);
+                }
+                cleanup();
+                return EXIT_SUCCESS;
+            }
+            else if (ch == 's')
+                nodelay(stdscr, FALSE);
+            else if (ch == ' ')
+                nodelay(stdscr, TRUE);
+        }
+
+        for (n = 0, w = &worm[0]; n < number; n++, w++)
+        {
+            if ((x = w->xpos[h = w->head]) < 0)
+            {
+                move(y = w->ypos[h] = (short)bottom, x = w->xpos[h] = 0);
+                addch(flavor[n % FLAVORS]);
+                ref[y][x]++;
+            }
+            else
+                y = w->ypos[h];
+
+            if (x > last)
+                x = last;
+
+            if (y > bottom)
+                y = bottom;
+
+            if (++h == length)
+                h = 0;
+
+            if (w->xpos[w->head = h] >= 0)
+            {
+                int x1 = w->xpos[h];
+                int y1 = w->ypos[h];
+
+                if (y1 < LINES && x1 < COLS && --ref[y1][x1] == 0)
+                {
+                    move(y1, x1);
+                    addch(trail);
+                }
+            }
+
+            op = &(x == 0 ? (y == 0 ? upleft :
+                  (y == bottom ? lowleft : left)) :
+                  (x == last ? (y == 0 ? upright :
+                  (y == bottom ? lowright : right)) :
+                  (y == 0 ? upper :
+                  (y == bottom ? lower : normal))))
+                  [w->orientation];
+
+            switch (op->nopts)
+            {
+            case 0:
+                for (y = 0; y < LINES; y++)
+                    free( ref[y]);
+                free( ref);
+                cleanup();
+                return EXIT_SUCCESS;
+            case 1:
+                w->orientation = op->opts[0];
+                break;
+            default:
+                w->orientation = op->opts[rand() % op->nopts];
+            }
+
+            move(y += yinc[w->orientation], x += xinc[w->orientation]);
+
+            if (y < 0)
+                y = 0;
+
+            addch(flavor[n % FLAVORS]);
+            ref[w->ypos[h] = (short)y][w->xpos[h] = (short)x]++;
+        }
+        napms(12);
+        refresh();
+    }
+}
diff --git a/lib/PDCursesMod/demos/xmas.c b/lib/PDCursesMod/demos/xmas.c
new file mode 100644
index 00000000000..99b2dd85a6c
--- /dev/null
+++ b/lib/PDCursesMod/demos/xmas.c
@@ -0,0 +1,958 @@
+/******************************************************************************/
+/* asciixmas                                                                  */
+/* December 1989             Larry Bartz           Indianapolis, IN           */
+/*                                                                            */
+/*                                                                            */
+/* I'm dreaming of an ascii character-based monochrome Christmas,             */
+/* Just like the one's I used to know!                                        */
+/* Via a full duplex communications channel,                                  */
+/* At 9600 bits per second,                                                   */
+/* Even though it's kinda slow.                                               */
+/*                                                                            */
+/* I'm dreaming of an ascii character-based monochrome Christmas,             */
+/* With ev'ry C program I write!                                              */
+/* May your screen be merry and bright!                                       */
+/* And may all your Christmases be amber or green,                            */
+/* (for reduced eyestrain and improved visibility)!                           */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/* IMPLEMENTATION                                                             */
+/*                                                                            */
+/* Feel free to modify the defined string FROMWHO to reflect you, your        */
+/* organization, your site, whatever.                                         */
+/*                                                                            */
+/* This looks a lot better if you can turn off your cursor before execution.  */
+/* The cursor is distracting but it doesn't really ruin the show.             */
+/*                                                                            */
+/* At our site, we invoke this for our users just after login and the         */
+/* determination of terminal type.                                            */
+/*                                                                            */
+/*                                                                            */
+/* PORTABILITY                                                                */
+/*                                                                            */
+/* I wrote this using only the very simplest curses functions so that it      */
+/* might be the most portable. I was personally able to test on five          */
+/* different cpu/UNIX combinations.                                           */
+/*                                                                            */
+/*                                                                            */
+/* COMPILE                                                                    */
+/*                                                                            */
+/* usually this:                                                              */
+/*                                                                            */
+/* cc -O xmas.c -lcurses -o xmas -s                                           */
+/*                                                                            */
+/******************************************************************************/
+
+#include <curses.h>
+
+void lil(WINDOW *);
+void midtop(WINDOW *);
+void bigtop(WINDOW *);
+void bigface(WINDOW *, chtype);
+void legs1(WINDOW *);
+void legs2(WINDOW *);
+void legs3(WINDOW *);
+void legs4(WINDOW *);
+void initdeer(void);
+void boxit(void);
+void seas(void);
+void greet(void);
+void fromwho(void);
+void del_msg(void);
+void tree(void);
+void balls(void);
+void star(void);
+void strng1(void);
+void strng2(void);
+void strng3(void);
+void strng4(void);
+void strng5(void);
+void blinkit(void);
+void reindeer(void);
+
+#define FROMWHO "From Larry Bartz, Mark Hessling and William McBrine"
+
+int y_pos, x_pos;
+
+WINDOW *treescrn, *treescrn2, *treescrn3, *treescrn4, *treescrn5,
+       *treescrn6, *treescrn7, *treescrn8, *dotdeer0, *stardeer0,
+       *lildeer0, *lildeer1, *lildeer2, *lildeer3, *middeer0,
+       *middeer1, *middeer2, *middeer3, *bigdeer0, *bigdeer1,
+       *bigdeer2, *bigdeer3, *bigdeer4, *lookdeer0, *lookdeer1,
+       *lookdeer2, *lookdeer3, *lookdeer4, *w_holiday, *w_del_msg;
+
+#define INTENTIONALLY_UNUSED_PARAMETER( param) (void)(param)
+
+int main(int argc, char **argv)
+{
+    int loopy;
+
+#ifdef XCURSES
+    Xinitscr(argc, argv);
+#else
+    INTENTIONALLY_UNUSED_PARAMETER( argc);
+    INTENTIONALLY_UNUSED_PARAMETER( argv);
+    initscr();
+#endif
+    nodelay(stdscr, TRUE);
+    noecho();
+    nonl();
+    refresh();
+
+#ifdef A_COLOR
+    if (has_colors())
+        start_color();
+#endif
+    curs_set(0);
+
+    treescrn = newwin(16, 27, 3, 53);
+    treescrn2 = newwin(16, 27, 3, 53);
+    treescrn3 = newwin(16, 27, 3, 53);
+    treescrn4 = newwin(16, 27, 3, 53);
+    treescrn5 = newwin(16, 27, 3, 53);
+    treescrn6 = newwin(16, 27, 3, 53);
+    treescrn7 = newwin(16, 27, 3, 53);
+    treescrn8 = newwin(16, 27, 3, 53);
+
+    w_holiday = newwin(1, 26, 3, 27);
+
+    w_del_msg = newwin(1, 12, 23, 60);
+
+    mvwaddstr(w_holiday, 0, 0, "H A P P Y  H O L I D A Y S");
+
+    initdeer();
+
+    clear();
+    werase(treescrn);
+    touchwin(treescrn);
+    werase(treescrn2);
+    touchwin(treescrn2);
+    werase(treescrn8);
+    touchwin(treescrn8);
+    refresh();
+    napms(1000);
+
+    boxit();
+    del_msg();
+    napms(1000);
+
+    seas();
+    del_msg();
+    napms(1000);
+
+    greet();
+    del_msg();
+    napms(1000);
+
+    fromwho();
+    del_msg();
+    napms(1000);
+
+    tree();
+    napms(1000);
+
+    balls();
+    napms(1000);
+
+    star();
+    napms(1000);
+
+    strng1();
+    strng2();
+    strng3();
+    strng4();
+    strng5();
+
+    /* set up the windows for our blinking trees */
+    /* **************************************** */
+    /* treescrn3 */
+
+    overlay(treescrn, treescrn3);
+
+    /* balls */
+    mvwaddch(treescrn3, 4, 18, ' ');
+    mvwaddch(treescrn3, 7, 6, ' ');
+    mvwaddch(treescrn3, 8, 19, ' ');
+    mvwaddch(treescrn3, 11, 22, ' ');
+
+    /* star */
+    mvwaddch(treescrn3, 0, 12, '*');
+
+    /* strng1 */
+    mvwaddch(treescrn3, 3, 11, ' ');
+
+    /* strng2 */
+    mvwaddch(treescrn3, 5, 13, ' ');
+    mvwaddch(treescrn3, 6, 10, ' ');
+
+    /* strng3 */
+    mvwaddch(treescrn3, 7, 16, ' ');
+    mvwaddch(treescrn3, 7, 14, ' ');
+
+    /* strng4 */
+    mvwaddch(treescrn3, 10, 13, ' ');
+    mvwaddch(treescrn3, 10, 10, ' ');
+    mvwaddch(treescrn3, 11, 8, ' ');
+
+    /* strng5 */
+    mvwaddch(treescrn3, 11, 18, ' ');
+    mvwaddch(treescrn3, 12, 13, ' ');
+
+    /* treescrn4 */
+
+    overlay(treescrn, treescrn4);
+
+    /* balls */
+    mvwaddch(treescrn4, 3, 9, ' ');
+    mvwaddch(treescrn4, 4, 16, ' ');
+    mvwaddch(treescrn4, 7, 6, ' ');
+    mvwaddch(treescrn4, 8, 19, ' ');
+    mvwaddch(treescrn4, 11, 2, ' ');
+    mvwaddch(treescrn4, 12, 23, ' ');
+
+    /* star */
+    mvwaddch(treescrn4, 0, 12, '*' | A_STANDOUT);
+
+    /* strng1 */
+    mvwaddch(treescrn4, 3, 13, ' ');
+
+    /* strng2 */
+
+    /* strng3 */
+    mvwaddch(treescrn4, 7, 15, ' ');
+    mvwaddch(treescrn4, 8, 11, ' ');
+
+    /* strng4 */
+    mvwaddch(treescrn4, 9, 16, ' ');
+    mvwaddch(treescrn4, 10, 12, ' ');
+    mvwaddch(treescrn4, 11, 8, ' ');
+
+    /* strng5 */
+    mvwaddch(treescrn4, 11, 18, ' ');
+    mvwaddch(treescrn4, 12, 14, ' ');
+
+    /* treescrn5 */
+
+    overlay(treescrn, treescrn5);
+
+    /* balls */
+    mvwaddch(treescrn5, 3, 15, ' ');
+    mvwaddch(treescrn5, 10, 20, ' ');
+    mvwaddch(treescrn5, 12, 1, ' ');
+
+    /* star */
+    mvwaddch(treescrn5, 0, 12, '*');
+
+    /* strng1 */
+    mvwaddch(treescrn5, 3, 11, ' ');
+
+    /* strng2 */
+    mvwaddch(treescrn5, 5, 12, ' ');
+
+    /* strng3 */
+    mvwaddch(treescrn5, 7, 14, ' ');
+    mvwaddch(treescrn5, 8, 10, ' ');
+
+    /* strng4 */
+    mvwaddch(treescrn5, 9, 15, ' ');
+    mvwaddch(treescrn5, 10, 11, ' ');
+    mvwaddch(treescrn5, 11, 7, ' ');
+
+    /* strng5 */
+    mvwaddch(treescrn5, 11, 17, ' ');
+    mvwaddch(treescrn5, 12, 13, ' ');
+
+    /* treescrn6 */
+
+    overlay(treescrn, treescrn6);
+
+    /* balls */
+    mvwaddch(treescrn6, 6, 7, ' ');
+    mvwaddch(treescrn6, 7, 18, ' ');
+    mvwaddch(treescrn6, 10, 4, ' ');
+    mvwaddch(treescrn6, 11, 23, ' ');
+
+    /* star */
+    mvwaddch(treescrn6, 0, 12, '*' | A_STANDOUT);
+
+    /* strng1 */
+
+    /* strng2 */
+    mvwaddch(treescrn6, 5, 11, ' ');
+
+    /* strng3 */
+    mvwaddch(treescrn6, 7, 13, ' ');
+    mvwaddch(treescrn6, 8, 9, ' ');
+
+    /* strng4 */
+    mvwaddch(treescrn6, 9, 14, ' ');
+    mvwaddch(treescrn6, 10, 10, ' ');
+    mvwaddch(treescrn6, 11, 6, ' ');
+
+    /* strng5 */
+    mvwaddch(treescrn6, 11, 16, ' ');
+    mvwaddch(treescrn6, 12, 12, ' ');
+
+    /* treescrn7 */
+
+    overlay(treescrn, treescrn7);
+
+    /* balls */
+    mvwaddch(treescrn7, 3, 15, ' ');
+    mvwaddch(treescrn7, 6, 7, ' ');
+    mvwaddch(treescrn7, 7, 18, ' ');
+    mvwaddch(treescrn7, 10, 4, ' ');
+    mvwaddch(treescrn7, 11, 22, ' ');
+
+    /* star */
+    mvwaddch(treescrn7, 0, 12, '*');
+
+    /* strng1 */
+    mvwaddch(treescrn7, 3, 12, ' ');
+
+    /* strng2 */
+    mvwaddch(treescrn7, 5, 13, ' ');
+    mvwaddch(treescrn7, 6, 9, ' ');
+
+    /* strng3 */
+    mvwaddch(treescrn7, 7, 15, ' ');
+    mvwaddch(treescrn7, 8, 11, ' ');
+
+    /* strng4 */
+    mvwaddch(treescrn7, 9, 16, ' ');
+    mvwaddch(treescrn7, 10, 12, ' ');
+    mvwaddch(treescrn7, 11, 8, ' ');
+
+    /* strng5 */
+    mvwaddch(treescrn7, 11, 18, ' ');
+    mvwaddch(treescrn7, 12, 14, ' ');
+
+    napms(1000);
+    reindeer();
+
+    touchwin(w_holiday);
+    wrefresh(w_holiday);
+    wrefresh(w_del_msg);
+
+    napms(1000);
+
+    for (loopy = 0; loopy < 50; loopy++)
+        blinkit();
+
+    clear();
+    refresh();
+    endwin();
+
+    return 0;
+}
+
+void lil(WINDOW *win)
+{
+    mvwaddch(win, 0, 0, (chtype) 'V');
+    mvwaddch(win, 1, 0, (chtype) '@');
+    mvwaddch(win, 1, 3, (chtype) '~');
+}
+
+void midtop(WINDOW *win)
+{
+    mvwaddstr(win, 0, 2, "yy");
+    mvwaddstr(win, 1, 2, "0(=)~");
+}
+
+void bigtop(WINDOW *win)
+{
+    mvwaddstr(win, 0, 17, "\\/");
+    mvwaddstr(win, 0, 20, "\\/");
+    mvwaddch(win, 1, 18, (chtype) '\\');
+    mvwaddch(win, 1, 20, (chtype) '/');
+    mvwaddstr(win, 2, 19, "|_");
+    mvwaddstr(win, 3, 18, "/^0\\");
+    mvwaddstr(win, 4, 17, "//\\");
+    mvwaddch(win, 4, 22, (chtype) '\\');
+    mvwaddstr(win, 5, 7, "^~~~~~~~~//  ~~U");
+}
+
+void bigface(WINDOW *win, chtype noseattr)
+{
+    mvwaddstr(win, 0, 16, "\\/     \\/");
+    mvwaddstr(win, 1, 17, "\\Y/ \\Y/");
+    mvwaddstr(win, 2, 19, "\\=/");
+    mvwaddstr(win, 3, 17, "^\\o o/^");
+    mvwaddstr(win, 4, 17, "//( )");
+    mvwaddstr(win, 5, 7, "^~~~~~~~~// \\");
+    waddch(win, 'O' | noseattr);
+    waddstr(win, "/");
+}
+
+void legs1(WINDOW *win)
+{
+    mvwaddstr(win, 6, 7, "( \\_____( /");
+    mvwaddstr(win, 7, 8, "( )    /");
+    mvwaddstr(win, 8, 9, "\\\\   /");
+    mvwaddstr(win, 9, 11, "\\>/>");
+}
+
+void legs2(WINDOW *win)
+{
+    mvwaddstr(win, 6, 7, "(( )____( /");
+    mvwaddstr(win, 7, 7, "( /      |");
+    mvwaddstr(win, 8, 8, "\\/      |");
+    mvwaddstr(win, 9, 9, "|>     |>");
+}
+
+void legs3(WINDOW *win)
+{
+    mvwaddstr(win, 6, 6, "( ()_____( /");
+    mvwaddstr(win, 7, 6, "/ /       /");
+    mvwaddstr(win, 8, 5, "|/          \\");
+    mvwaddstr(win, 9, 5, "/>           \\>");
+}
+
+void legs4(WINDOW *win)
+{
+    mvwaddstr(win, 6, 6, "( )______( /");
+    mvwaddstr(win, 7, 5, "(/          \\");
+    mvwaddstr(win, 8, 0, "v___=             ----^");
+}
+
+void initdeer(void)
+{
+    chtype noseattr;
+
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(31, COLOR_RED, COLOR_BLACK);
+        noseattr = COLOR_PAIR(31);
+    }
+    else
+#endif
+        noseattr = A_NORMAL;
+
+    /* set up the windows for our various reindeer */
+
+    dotdeer0 = newwin(3, 71, 0, 8);
+    stardeer0 = newwin(4, 56, 0, 8);
+    lildeer0 = newwin(7, 54, 0, 8);
+    middeer0 = newwin(15, 42, 0, 8);
+    bigdeer0 = newwin(10, 23, 0, 0);
+    lookdeer0 = newwin(10, 25, 0, 0);
+
+    /* lildeer1 */
+    lildeer1 = newwin(2, 4, 0, 0);
+    lil(lildeer1);
+    mvwaddstr(lildeer1, 1, 1, "<>");
+
+    /* lildeer2 */
+    lildeer2 = newwin(2, 4, 0, 0);
+    lil(lildeer2);
+    mvwaddstr(lildeer2, 1, 1, "||");
+
+    /* lildeer3 */
+    lildeer3 = newwin(2, 4, 0, 0);
+    lil(lildeer3);
+    mvwaddstr(lildeer3, 1, 1, "><");
+
+    /* middeer1 */
+    middeer1 = newwin(3, 7, 0, 0);
+    midtop(middeer1);
+    mvwaddstr(middeer1, 2, 3, "\\/");
+
+    /* middeer2 */
+    middeer2 = newwin(3, 7, 0, 0);
+    midtop(middeer2);
+    mvwaddch(middeer2, 2, 3, (chtype) '|');
+    mvwaddch(middeer2, 2, 5, (chtype) '|');
+
+    /* middeer3 */
+    middeer3 = newwin(3, 7, 0, 0);
+    midtop(middeer3);
+    mvwaddch(middeer3, 2, 2, (chtype) '/');
+    mvwaddch(middeer3, 2, 6, (chtype) '\\');
+
+    /* bigdeer1 */
+    bigdeer1 = newwin(10, 23, 0, 0);
+    bigtop(bigdeer1);
+    legs1(bigdeer1);
+
+    /* bigdeer2 */
+    bigdeer2 = newwin(10, 23, 0, 0);
+    bigtop(bigdeer2);
+    legs2(bigdeer2);
+
+    /* bigdeer3 */
+    bigdeer3 = newwin(10, 23, 0, 0);
+    bigtop(bigdeer3);
+    legs3(bigdeer3);
+
+    /* bigdeer4 */
+    bigdeer4 = newwin(10, 23, 0, 0);
+    bigtop(bigdeer4);
+    legs4(bigdeer4);
+
+    /* lookdeer1 */
+    lookdeer1 = newwin(10, 25, 0, 0);
+    bigface(lookdeer1, noseattr);
+    legs1(lookdeer1);
+
+    /* lookdeer2 */
+    lookdeer2 = newwin(10, 25, 0, 0);
+    bigface(lookdeer2, noseattr);
+    legs2(lookdeer2);
+
+    /* lookdeer3 */
+    lookdeer3 = newwin(10, 25, 0, 0);
+    bigface(lookdeer3, noseattr);
+    legs3(lookdeer3);
+
+    /* lookdeer4 */
+    lookdeer4 = newwin(10, 25, 0, 0);
+    bigface(lookdeer4, noseattr);
+    legs4(lookdeer4);
+}
+
+void boxit(void)
+{
+    int x;
+
+    for (x = 0; x < 20; ++x)
+        mvaddch(x, 7, '|');
+
+    for (x = 0; x < 80; ++x)
+    {
+        if (x > 7)
+            mvaddch(19, x, '_');
+
+        mvaddch(22, x, '_');
+    }
+}
+
+void seas(void)
+{
+    mvaddch(4, 1, 'S');
+    mvaddch(6, 1, 'E');
+    mvaddch(8, 1, 'A');
+    mvaddch(10, 1, 'S');
+    mvaddch(12, 1, 'O');
+    mvaddch(14, 1, 'N');
+    mvaddch(16, 1, '`');
+    mvaddch(18, 1, 'S');
+}
+
+void greet(void)
+{
+    mvaddch(3, 5, 'G');
+    mvaddch(5, 5, 'R');
+    mvaddch(7, 5, 'E');
+    mvaddch(9, 5, 'E');
+    mvaddch(11, 5, 'T');
+    mvaddch(13, 5, 'I');
+    mvaddch(15, 5, 'N');
+    mvaddch(17, 5, 'G');
+    mvaddch(19, 5, 'S');
+}
+
+void fromwho(void)
+{
+    mvaddstr(21, 13, FROMWHO);
+}
+
+void del_msg(void)
+{
+    refresh();
+}
+
+void tree(void)
+{
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(30, COLOR_GREEN, COLOR_BLACK);
+        wattrset(treescrn, COLOR_PAIR(30));
+    }
+#endif
+    mvwaddch(treescrn, 1, 11, (chtype) '/');
+    mvwaddch(treescrn, 2, 11, (chtype) '/');
+    mvwaddch(treescrn, 3, 10, (chtype) '/');
+    mvwaddch(treescrn, 4, 9, (chtype) '/');
+    mvwaddch(treescrn, 5, 9, (chtype) '/');
+    mvwaddch(treescrn, 6, 8, (chtype) '/');
+    mvwaddch(treescrn, 7, 7, (chtype) '/');
+    mvwaddch(treescrn, 8, 6, (chtype) '/');
+    mvwaddch(treescrn, 9, 6, (chtype) '/');
+    mvwaddch(treescrn, 10, 5, (chtype) '/');
+    mvwaddch(treescrn, 11, 3, (chtype) '/');
+    mvwaddch(treescrn, 12, 2, (chtype) '/');
+
+    mvwaddch(treescrn, 1, 13, (chtype) '\\');
+    mvwaddch(treescrn, 2, 13, (chtype) '\\');
+    mvwaddch(treescrn, 3, 14, (chtype) '\\');
+    mvwaddch(treescrn, 4, 15, (chtype) '\\');
+    mvwaddch(treescrn, 5, 15, (chtype) '\\');
+    mvwaddch(treescrn, 6, 16, (chtype) '\\');
+    mvwaddch(treescrn, 7, 17, (chtype) '\\');
+    mvwaddch(treescrn, 8, 18, (chtype) '\\');
+    mvwaddch(treescrn, 9, 18, (chtype) '\\');
+    mvwaddch(treescrn, 10, 19, (chtype) '\\');
+    mvwaddch(treescrn, 11, 21, (chtype) '\\');
+    mvwaddch(treescrn, 12, 22, (chtype) '\\');
+
+    mvwaddch(treescrn, 4, 10, (chtype) '_');
+    mvwaddch(treescrn, 4, 14, (chtype) '_');
+    mvwaddch(treescrn, 8, 7, (chtype) '_');
+    mvwaddch(treescrn, 8, 17, (chtype) '_');
+
+    mvwaddstr(treescrn, 13, 0,
+          "//////////// \\\\\\\\\\\\\\\\\\\\\\\\");
+
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(20, COLOR_YELLOW, COLOR_BLACK);
+        wattrset(treescrn, COLOR_PAIR(20));
+    }
+#endif
+    mvwaddstr(treescrn, 14, 11, "| |");
+    mvwaddstr(treescrn, 15, 11, "|_|");
+
+    wrefresh(treescrn);
+    wrefresh(w_del_msg);
+}
+
+void balls(void)
+{
+    chtype ball1, ball2, ball3, ball4, ball5, ball6;
+
+    overlay(treescrn, treescrn2);
+
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(1, COLOR_BLUE, COLOR_BLACK);
+        init_pair(2, COLOR_RED, COLOR_BLACK);
+        init_pair(3, COLOR_MAGENTA, COLOR_BLACK);
+        init_pair(4, COLOR_CYAN, COLOR_BLACK);
+        init_pair(5, COLOR_YELLOW, COLOR_BLACK);
+        init_pair(6, COLOR_WHITE, COLOR_BLACK);
+        ball1 = COLOR_PAIR(1) | '@';
+        ball2 = COLOR_PAIR(2) | '@';
+        ball3 = COLOR_PAIR(3) | '@';
+        ball4 = COLOR_PAIR(4) | '@';
+        ball5 = COLOR_PAIR(5) | '@';
+        ball6 = COLOR_PAIR(6) | '@';
+    }
+    else
+#endif
+        ball1 = ball2 = ball3 = ball4 = ball5 = ball6 = '@';
+
+    mvwaddch(treescrn2, 3, 9, ball1);
+    mvwaddch(treescrn2, 3, 15, ball2);
+    mvwaddch(treescrn2, 4, 8, ball3);
+    mvwaddch(treescrn2, 4, 16, ball4);
+    mvwaddch(treescrn2, 5, 7, ball5);
+    mvwaddch(treescrn2, 5, 17, ball6);
+    mvwaddch(treescrn2, 7, 6, ball1 | A_BOLD);
+    mvwaddch(treescrn2, 7, 18, ball2 | A_BOLD);
+    mvwaddch(treescrn2, 8, 5, ball3 | A_BOLD);
+    mvwaddch(treescrn2, 8, 19, ball4 | A_BOLD);
+    mvwaddch(treescrn2, 10, 4, ball5 | A_BOLD);
+    mvwaddch(treescrn2, 10, 20, ball6 | A_BOLD);
+    mvwaddch(treescrn2, 11, 2, ball1);
+    mvwaddch(treescrn2, 11, 22, ball2);
+    mvwaddch(treescrn2, 12, 1, ball3);
+    mvwaddch(treescrn2, 12, 23, ball4);
+
+    wrefresh(treescrn2);
+    wrefresh(w_del_msg);
+}
+
+void star(void)
+{
+    mvwaddch(treescrn2, 0, 12, (chtype) '*' | A_STANDOUT);
+
+    wrefresh(treescrn2);
+    wrefresh(w_del_msg);
+}
+
+void strng1(void)
+{
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(10, COLOR_YELLOW, COLOR_BLACK);
+        wattrset(treescrn2, COLOR_PAIR(10) | A_BOLD);
+    }
+#endif
+    mvwaddstr(treescrn2, 3, 11, ".:'");
+
+    wrefresh(treescrn2);
+    wrefresh(w_del_msg);
+}
+
+void strng2(void)
+{
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(11, COLOR_RED, COLOR_BLACK);
+        wattrset(treescrn2, COLOR_PAIR(11) | A_BOLD);
+    }
+#endif
+    mvwaddstr(treescrn2, 5, 11, ",.:'");
+    mvwaddstr(treescrn2, 6, 9, ":'");
+
+    wrefresh(treescrn2);
+    wrefresh(w_del_msg);
+}
+
+void strng3(void)
+{
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(12, COLOR_GREEN, COLOR_BLACK);
+        wattrset(treescrn2, COLOR_PAIR(12) | A_BOLD);
+    }
+#endif
+    mvwaddstr(treescrn2, 7, 13, ",.:'");
+    mvwaddstr(treescrn2, 8, 9, ",.:'");
+
+    wrefresh(treescrn2);
+    wrefresh(w_del_msg);
+}
+
+void strng4(void)
+{
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(13, COLOR_WHITE, COLOR_BLACK);
+        wattrset(treescrn2, COLOR_PAIR(13) | A_BOLD);
+    }
+#endif
+    mvwaddstr(treescrn2, 9, 14, ",.:'");
+    mvwaddstr(treescrn2, 10, 10, ",.:'");
+    mvwaddstr(treescrn2, 11, 6, ",.:'");
+    mvwaddch(treescrn2, 12, 5, (chtype) '\'');
+
+    wrefresh(treescrn2);
+    wrefresh(w_del_msg);
+}
+
+void strng5(void)
+{
+#ifdef A_COLOR
+    if (has_colors())
+    {
+        init_pair(14, COLOR_CYAN, COLOR_BLACK);
+        wattrset(treescrn2, COLOR_PAIR(14) | A_BOLD);
+    }
+#endif
+    mvwaddstr(treescrn2, 11, 16, ",.:'");
+    mvwaddstr(treescrn2, 12, 12, ",.:'");
+
+    /* save a fully lit tree */
+    overlay(treescrn2, treescrn);
+
+    wrefresh(treescrn2);
+    wrefresh(w_del_msg);
+}
+
+void blinkit(void)
+{
+    static int cycle;
+
+    if (cycle > 4)
+        cycle = 0;
+
+    touchwin(treescrn8);
+
+    switch (cycle)
+    {
+    case 0:
+        overlay(treescrn3, treescrn8);
+        break;
+
+    case 1:
+        overlay(treescrn4, treescrn8);
+        break;
+
+    case 2:
+        overlay(treescrn5, treescrn8);
+        break;
+
+    case 3:
+        overlay(treescrn6, treescrn8);
+        break;
+
+    case 4:
+        overlay(treescrn7, treescrn8);
+    }
+
+    wrefresh(treescrn8);
+    wrefresh(w_del_msg);
+
+    napms(50);
+    touchwin(treescrn8);
+
+    /*ALL ON************************************************** */
+
+    overlay(treescrn, treescrn8);
+    wrefresh(treescrn8);
+    wrefresh(w_del_msg);
+
+    ++cycle;
+}
+
+#define TSHOW(win, pause) touchwin(win); wrefresh(win); \
+              wrefresh(w_del_msg); napms(pause)
+
+#define SHOW(win, pause) mvwin(win, y_pos, x_pos); wrefresh(win); \
+             wrefresh(w_del_msg); napms(pause)
+
+void reindeer(void)
+{
+    int looper;
+
+    y_pos = 0;
+
+    for (x_pos = 70; x_pos > 62; x_pos--)
+    {
+        if (x_pos < 62)
+            y_pos = 1;
+
+        for (looper = 0; looper < 4; looper++)
+        {
+            mvwaddch(dotdeer0, y_pos, x_pos, (chtype) '.');
+            wrefresh(dotdeer0);
+            wrefresh(w_del_msg);
+            werase(dotdeer0);
+            wrefresh(dotdeer0);
+            wrefresh(w_del_msg);
+        }
+    }
+
+    y_pos = 2;
+
+    for (; x_pos > 50; x_pos--)
+    {
+        for (looper = 0; looper < 4; looper++)
+        {
+            if (x_pos < 56)
+            {
+                y_pos = 3;
+
+                mvwaddch(stardeer0, y_pos, x_pos, (chtype) '*');
+                wrefresh(stardeer0);
+                wrefresh(w_del_msg);
+                werase(stardeer0);
+                wrefresh(stardeer0);
+            }
+            else
+            {
+                mvwaddch(dotdeer0, y_pos, x_pos, (chtype) '*');
+                wrefresh(dotdeer0);
+                wrefresh(w_del_msg);
+                werase(dotdeer0);
+                wrefresh(dotdeer0);
+            }
+            wrefresh(w_del_msg);
+        }
+    }
+
+    x_pos = 58;
+
+    for (y_pos = 2; y_pos < 5; y_pos++)
+    {
+        TSHOW(lildeer0, 50);
+
+        for (looper = 0; looper < 4; looper++)
+        {
+            SHOW(lildeer3, 50);
+            SHOW(lildeer2, 50);
+            SHOW(lildeer1, 50);
+            SHOW(lildeer2, 50);
+            SHOW(lildeer3, 50);
+
+            TSHOW(lildeer0, 50);
+
+            x_pos -= 2;
+        }
+    }
+
+    x_pos = 35;
+
+    for (y_pos = 5; y_pos < 10; y_pos++)
+    {
+        touchwin(middeer0);
+        wrefresh(middeer0);
+        wrefresh(w_del_msg);
+
+        for (looper = 0; looper < 2; looper++)
+        {
+            SHOW(middeer3, 50);
+            SHOW(middeer2, 50);
+            SHOW(middeer1, 50);
+            SHOW(middeer2, 50);
+            SHOW(middeer3, 50);
+
+            TSHOW(middeer0, 50);
+
+            x_pos -= 3;
+        }
+    }
+
+    napms(2000);
+
+    y_pos = 1;
+
+    for (x_pos = 8; x_pos < 16; x_pos++)
+    {
+        SHOW(bigdeer4, 30);
+        SHOW(bigdeer3, 30);
+        SHOW(bigdeer2, 30);
+        SHOW(bigdeer1, 30);
+        SHOW(bigdeer2, 30);
+        SHOW(bigdeer3, 30);
+        SHOW(bigdeer4, 30);
+        SHOW(bigdeer0, 30);
+    }
+
+    --x_pos;
+
+    for (looper = 0; looper < 6; looper++)
+    {
+        SHOW(lookdeer4, 40);
+        SHOW(lookdeer3, 40);
+        SHOW(lookdeer2, 40);
+        SHOW(lookdeer1, 40);
+        SHOW(lookdeer2, 40);
+        SHOW(lookdeer3, 40);
+        SHOW(lookdeer4, 40);
+    }
+
+    SHOW(lookdeer0, 40);
+
+    for (; y_pos < 10; y_pos++)
+    {
+        for (looper = 0; looper < 2; looper++)
+        {
+            SHOW(bigdeer4, 30);
+            SHOW(bigdeer3, 30);
+            SHOW(bigdeer2, 30);
+            SHOW(bigdeer1, 30);
+            SHOW(bigdeer2, 30);
+            SHOW(bigdeer3, 30);
+            SHOW(bigdeer4, 30);
+        }
+
+        SHOW(bigdeer0, 30);
+    }
+
+    --y_pos;
+
+    mvwin(lookdeer3, y_pos, x_pos);
+    wrefresh(lookdeer3);
+    wrefresh(w_del_msg);
+}
diff --git a/lib/PDCursesMod/docs/CNAME b/lib/PDCursesMod/docs/CNAME
new file mode 100644
index 00000000000..1f4a84b6db1
--- /dev/null
+++ b/lib/PDCursesMod/docs/CNAME
@@ -0,0 +1 @@
+pdcurses.org
\ No newline at end of file
diff --git a/lib/PDCursesMod/docs/HISTORY.md b/lib/PDCursesMod/docs/HISTORY.md
new file mode 100644
index 00000000000..522339d8d10
--- /dev/null
+++ b/lib/PDCursesMod/docs/HISTORY.md
@@ -0,0 +1,2782 @@
+PDCursesMod 4.2 - 2020 Oct 03
+=========================
+
+Major new features
+------------------
+
+-  Pulled in almost all of William McBrine's 3.8 and 3.9 changes.
+   These include the single-process X11 port (much simpler and
+   less prone to bugs),  common copy/paste,  some extended colors,
+   and much other good work from wmcbrine over the last few years.
+
+-  See history entries for versions 3.8 and 3.9 below for details.
+
+-  Added chasonr's DOSVGA port and Federico G. Benavento and Jens
+   Staal's Plan 9 port.
+
+-  Automated builds again work and have been extended to new platforms.
+
+-  Added ncurses-style init_extended_color(), init_extended_pair(),
+   extended_color_content(),  extended_pair_content() functions.
+   VT and WinGUI versions can now access 2^20 = over a million color
+   pairs and 2^24+256 = 16777472 colors.  This should be extended
+   to SDLx and X11,  and possibly WinCon.
+
+-  As a result of all this,  A_RGB is now completely gone (and not
+   really needed anyway).
+
+-  Attempts to mis-link a wide-character library to code compiled for
+   8-bit characters,  or a mismatch of a 32-bit chtype library to
+   64-bit chtype code,  etc.,  will usually result in an undefined
+   variant of initscr.  (Previously,  everything would compile,  then
+   crash or produce odd output when the program was run.)  See GitHub
+   issue #133.
+
+-  Added 'picsview' demo,  something of a ripoff/homage to Thomas
+   E. Dickey's 'picsmap' demo for ncurses.  It has a similar purpose:
+   demonstrating the functions in the above paragraph and the new
+   ability to access lots and lots of colors.
+
+-  HISTORY.md brought up to date for 4.2 (which meant bringing in
+   changes for 3.8 and 3.9).  Also,  4.1.0 was almost completely
+   undocumented.
+
+Minor new features
+------------------
+
+-  Name changed from 'PDCurses' to 'PDCursesMod',  in hopes of
+   simultaneously making its origin clear and also making it clear
+   that it's somewhat modified from the parent project.
+
+-  Makefiles are better organized and more 'standard'.  'make' builds
+   the PDCurses library,  'make demos' all demos.  The .mif files are
+   all now in the 'common' directory.
+
+-  VT port is much faster,  mostly thanks to not writing data to
+   stdout with no buffering and with printf().  It also will use
+   SGR mouse commands if available,  which makes things more bullet
+   proof in cases of confused mouse input,  and means windows can
+   be more than 224 columns wide without crashes happening when
+   the mouse reaches that column.
+
+-  Added ncurses extension functions ceiling_panel() and
+   ground_panel().
+
+-  'speed' demo tests out speed of the code.
+
+-  'test_pan' allows one to move panels around the screen and adjust
+   the panel depth.
+
+-  Added ability to change SDL1/SDL2 font rendering mode by setting
+   pdc_sdl_render_mode
+
+Bug fixes and such
+------------------
+
+-  Valgrind found three small memory leaks in the VT port (which
+   would apply to all other ports as well).  There are still more
+   leaks in other ports,  which should be addressed.
+
+-  Double-clicking in WinGUI got you a click message followed by
+   a double-click.  This does conform to 'standard' Windows practice,
+   but was both stupid and did _not_ conform with the way VT did
+   it,  nor the way I'd want it to be on any port.  To do : enable
+   double and triple clicks on all ports,  not just VT and WinGUI.
+
+-  Handling of default background/foreground in VT was just plain
+   wrong.  Now fixed.
+
+-  Mouse wheel events now report the correct mouse position,  instead
+   of always reporting (-1, -1).
+
+-  Fixed spurious resize events at startup and for window moves on
+   the X11 platform.
+
+-  raw() and noraw() now work as specified on WinGUI and VT.  (They
+   still don't work on X11,  SDLn,  or WinCon.)
+
+-  User shrinking of the screen to a degree causing a window to be
+   partly off-screen caused a crash.  (In PDCurses,  windows are
+   theoretically always on-screen;  we were not properly prepared
+   for the possibility that the screen might shrink and put windows
+   partly or totally off-screen.)  We no longer crash,  and the part
+   of the window that is still on-screen is refreshed correctly.
+
+See the git log for more details.
+
+PDCurses 4.1.0 - 2019-05-10
+=========================
+
+New features
+------------
+
+- VT backend improved to support different cursors,  mouse move events,
+  and Ctrl/Alt/Shift flags.
+
+- Fixes to allow WinCon builds on platforms lacking INFOEX struct.
+
+- Improved DOS napms to convert milliseconds to BIOS ticks accurately.
+
+- Followed wmcbrine's 'rebranding' of Public Domain Curses to PDCurses.
+
+See the git log for more details.
+
+PDCurses 4.0.4 - 2019-01-20
+=========================
+
+Major new feature:
+-------------------
+
+- New VT backend.  Works within an xterm or xterm-based terminal and some
+  other terminals.  Mostly works in the Linux console,  and on Win10
+  directly and on Win9x/DOS if ANSI.SYS (or NANSI or NNANSI .SYS or .COM)
+  are installed.
+
+Minor new features:
+-------------------
+
+- SDL2 variant: dimmed,  bold,  blinking,  and RGB text are handled,  as is
+  window resizing.
+
+- DOS variant: cross-compilation from GNU/Linux works with both DJGPP and
+  Watcom C/C++; and, 16-bit and 32-bit Watcom makefiles have been combined
+  into one
+
+- Many modifications (and some bug fixes) taken from William McBrine's
+  branch.  An effort has been made to narrow the gap between the forks
+  where possible.  But both forks are moving targets with different
+  design choices and priorities.
+
+- Demos improved to show version info
+
+Bug fixes
+-------------------
+
+- compilation warnings/errors with some compilers in some variants #53, #57, #58, #65, ...
+
+- newtest sample was broken in all wide variants #60
+
+- the paste button printed debug output #62
+
+- some corner cases (midnight crossing, atomicity of tick count reads) in
+  DOS version of napms() were not handled well
+
+See the git log for more details.
+------------------------------------------------------------------------
+
+PDCurses 4.0.2 - 2017-09-12
+=========================
+
+Major new features:
+-------------------
+
+- New Win32a(Windows GUI) and SDL2 backends.  SDL1 is still supported,
+  but may eventually go away.
+
+- Bold, italic, underlined, overlined, dimmed, 'strikeout', blinking
+  text, 256 colors and color pairs, and full RGB colors.  These are
+  all supported in Win32a and mostly supported in X11, SDL1 and SDL2.
+
+- In Win32a, one can choose a font, and both programmatic and user
+  resizing are supported.  (Recompiling is necessary to change the
+  font in X11.)
+
+- (Win32a only) Support of SMP Unicode (points beyond 64K) and
+  combining characters.  This may be extended to X11 and SDL2 eventually.
+
+- Demos corrected to be buildable and testable with ncurses.
+
+Minor new features:
+-------------------
+
+  (Note that not all of these are available on all backends)
+
+- Support for up to nine mouse buttons and wheel and tilt-wheel mice,
+  and double and triple mouse clicks.
+
+- (X11, Win32a, Win32) Extended range of keys that are recognized.
+  This now includes most of the "oddball" keys such as 'browser back
+  and 'favorites' found on some keyboards.
+
+- Blinking cursors in Win32a and X11 of various shapes (this could be
+  extended to SDLx eventually).
+
+- In X11 and Win32a, one can call resize_term( ) before initscr( ) to
+  set the initial window size.
+
+- Soft Label Keys (SLKs) are considerably more flexible, with the
+  ability to set arbitrary numbers of keys and groupings.   See slk.c
+  for details. This applies to all backends.
+
+- Many changes to testcurs to test all these new features, and newtest
+  added to test still more features.
+
+- Option to get detailed version information of the used PDCurses
+  library at run time with new exported PDC_version as PDC_version_info
+  structure.
+
+- ACS_x and WACS_x #defines extended to include a lot of "alternative
+  characters" that overlap in Unicode and CP-437: double-line box chars,
+  card suits, vulgar fractions, etc.  This applies to all backends. See
+  acs_defs.h for the full list.
+
+- Cleaned up some makefiles for Win32 and Win32a.  On both platforms,
+  vcwin32.mak can now be used with the Intel(R) compiler, and
+  mingwin32.mak can be used to cross-compile from Linux, or in
+  command.com under Windows, or with Cygwin/MSYS.  Also added a
+  makefile for Digital Mars for the DOS version.
+
+- The "def" files that were needed before to create PDCurses on
+  Windows are removed as they are no longer necessary.
+
+See the git log for more details.
+
+PDCurses 3.9 - 2019-09-04
+=========================
+
+IMPORTANT NOTE: This is actually wmcbrine's 3.9 version.  Its
+changes did not actually make it into this fork until 4.1 and 4.2.
+
+768 colors, single-process X11, copy-and-paste for all, and more.
+
+New features
+------------
+
+- Single-process, single-thread version of the X11 port. Much, much
+  faster than the two-process version. Needs more testing. This version
+  omits translations.
+
+- A common copy-and-paste system for all platforms, based on the
+  PDC_*clipboard() functions. (This is the first time copy-and-paste is
+  available for the SDL ports, and it replaces the old X11-specific
+  C&P.) Press and hold button 1 while selecting; paste with button 2.
+  Add Shift if mouse events are activated in curses. You can also paste
+  via Shift-Ctrl-V, and copy with Shift-Ctrl-C (although selecting
+  already sets the buffer). Note that paste is implemented via
+  ungetch(), and is currently limited to 256 characters at a time. (You
+  can get more via PDC_getclipboard().) With some ports (e.g. Wincon),
+  the existing terminal C&P mechanism may override PDCurses'. DOS and
+  SDL1 can only C&P within the same app.
+
+- A new maximum of 768 colors, for Wincon, SDL and X11. COLOR_PAIRS is
+  still limited to 256. The idea is that each pair can have a unique
+  foreground and background, without having to redefine any of the first
+  256 (predefined) colors. Colors 256-767 have no initial definitions,
+  and are intended to be set via init_color(). An example has been added
+  to testcurs (loosely based on part of newtest, by Bill Gray).
+
+- Wincon now allows redefinition of all 768 colors, and allows it even
+  under ConEmu.
+
+- True italics for ConEmu. (It seems it should also support true bold,
+  but I couldn't make that work.)
+
+- Added new functions from ncurses and/or NetBSD: has_mouse(),
+  is_keypad(), is_leaveok(), is_pad(), set_tabsize(), touchoverlap(),
+  underscore(), underend(), wunderscore(), and wunderend(). See the man
+  pages for descriptions. Partly due to Karthik Kumar Viswanathan, and
+  suggestions of Simon Sobisch.
+
+Bug fixes and such
+------------------
+
+- Check for standard C++ (>= 98), where native bool should exist, and use
+  that; otherwise (pre-/non-standard C++) fall back to the old behavior.
+  Satisfies clang, hopefully doesn't mess anything else up.
+
+- Recent versions of clang throw an error over "-install_name".
+
+- Most curses functions assumed a valid SP (i.e. that initscr() had
+  already been called). Now, instead, they return ERR or other
+  appropriate values. Suggestion of S.S.
+
+- Deprecated PDC_save_key_modifiers() -- there's no benefit to NOT
+  saving them.
+
+- Hold back screen updates due to palette changes until paused; always
+  do this update now (previously only in X11 and SDL, seems necessary in
+  Windows 10 1903).
+
+- SDL2 windows were freezing on moving to another screen (reported by
+  Mark Hessling). Still issues with moving between screens of different
+  scaling.
+
+- Find the X libraries in some additional locations. After M.H.
+
+- Converted default X11 icons to XPM, fixing their non-display in Ubuntu.
+
+- Made XIM standard, removed "classic" X11 compose system.
+
+- Made wide-character build the default for X11 (--disable-widec for
+  narrow).
+
+- Smoother resizing in X11, when not in scrollbar mode.
+
+- Dropped X11 options "borderWidth" (broken since at least 2.7) and
+  "cursorColor" (now set automatically for contrast).
+
+- Correctly restore Insert mode and QuickEdit mode in Wincon's
+  PDC_reset_shell_mode(). Patch by "vyv03354".
+
+- Add a WINDRES variable to wincon/Makefile for the sake of cross-
+  compilers. Patch by Marc-Andre Lureau.
+
+- Suppress cursor movement during color tests in testcurs.
+
+- Added UTF-8-demo.txt for tuidemo to browse (by default, only in forced
+  UTF-8 mode). File by Markus Kuhn.
+
+- Moved the doc files from "man" to "docs" -- the docs/man thing was too
+  confusing. Streamlined the web page into two files.
+
+- Rewrote the "Portability" sections of the man pages to reflect current
+  ncurses and NetBSD. The old charts weren't very accurate.
+
+- Document resolution of timeout() and napms(). Suggested by S.S.
+
+- Rewrote manext (again) in Awk.
+
+- Changed most dates to ISO format.
+
+See the git log (for both PDCursesMod and for wmcbrine's PDCurses,  the
+original source of these changes) for more details.
+
+------------------------------------------------------------------------
+
+PDCurses 3.8 - 2019-02-02
+=========================
+
+IMPORTANT NOTE: This is actually wmcbrine's 3.8 version.  Its
+changes did not actually make it into this fork until 4.1.
+
+It's that time again.
+
+
+New features
+------------
+
+- PDC_VERSION structure and PDC_get_version() function, to provide run-
+  time information on version and compile options, in case they don't
+  match the header; along with new compile-time defines PDC_VER_MAJOR,
+  PDC_VER_MINOR and PDC_VERDOT. Suggested by Simon Sobisch, designed
+  partly after Bill Gray and partly after SDL_VERSION.
+
+- Extensive documentation revisions, now covering many previously
+  undocumented functions.
+
+- Allow building the DLL with MinGW for SDL. (This also changes the
+  non-DLL library name from libpdcurses.a to pdcurses.a.)
+
+- Consolidated Watcom makefiles for DOS, after Tee-Kiah Chia; added
+  MODEL option to Makefile.bcc for consistency.
+
+- Added another ncurses_test, "lrtest"; updated for ncurses 6.1.
+
+
+Bug fixes and such
+------------------
+
+- T.H.'s update rect clipper (a resize fix for SDL2) broke sdltest,
+  because it didn't take the offsets into account for a non-owned
+  window.
+
+- The version number is now hardwired only in curses.h and configure.ac.
+
+- Revised pdcurses.rc to correctly show all fields when checking the
+  properties on a DLL; use it with MinGW as well as MSVC.
+
+- Allow building both 32- and 64-bit SDL2 versions in MinGW without
+  editing the Makefile, by using the proper dev package.
+
+- Build SDL2 demos in "Windows" mode (i.e. no controlling terminal) with
+  MSVC, as with MinGW.
+
+- Build sdltest.exe with MSVC.
+
+- Changed sample pathname in tuidemo to always use slashes -- the
+  backslashes failed in, e.g., SDL under Linux or macOS. Patch by B.G.
+
+- Warning fix for Borland OS/2.
+
+- Minor file reorganization / renaming.
+
+- mmask_t is now used in both the classic and ncurses mouse interfaces,
+  and is defined in such a way as to keep it at 32 bits.
+
+- Dropped map_button() and getbmap().
+
+- Dropped the ability to build BBS-ready archives from the Makefiles.
+
+- Made manext.py compatible with Python 3.x.
+
+See the git log (for both PDCursesMod and for wmcbrine's PDCurses,  the
+original source of these changes) for more details.
+
+PDCurses 3.7 - 2018-12-31
+=========================
+
+New features
+------------
+
+- Avoid conflict with ncurses by having apps define PDC_NCMOUSE before
+  including curses.h to invoke the ncurses-style mouse interface,
+  instead of NCURSES_MOUSE_VERSION. (The old way will also still work.)
+  After Simon Sobisch (see PR #33).
+
+- In SDL (TTF mode), the box-drawing and block ACS characters are now
+  rendered in a font-independent way, to ensure their correct alignment
+  across cells. Underlining is now handled in a similar way.
+
+- TTF fonts in SDL are now rendered in Blended mode instead of Solid.
+  Partly after Joachim de Groot.
+
+- New default fonts and font sizes for SDL/TTF.
+
+- SDL2 now builds under MSVC. Partly due to Alexandru Afrasinei.
+
+- Documentation re-org -- more Markdown internal links; moved to man/
+  dir (the doc/ dir name was too similar to docs/, which is needed for
+  GitHub Pages hosting); concatenated man page document now made
+  permanent, under the name MANUAL.md; new man build utils; merged
+  sdl.md and x11.md into their respective READMEs; changed some
+  redundant and unclear comments.
+
+- Directory re-org -- in addition to the above, created common/, to
+  unclutter the root, and eliminate a few more redundant files from
+  platform directories. (We already had "pdcurses", but that's for the
+  portable core; "common" is for files that are more platform-specific,
+  though shared by more than one platform.)
+
+- Broke out the redundant ACS tables and moved them to common/.
+
+- PDcurses' "bool" type is now based on stdbool.h, when available. There
+  should be no conflicts when including stdbool.h either before or after
+  curses.h.
+
+- The demos are no longer built by default, since they add a lot of time
+  to the build, and often aren't wanted. But you can still build them via
+  "make demos" (tweak as needed).
+
+- Makefile tweaks for cross-compiling by Simon Sobisch.
+
+
+Bug fixes and such
+------------------
+
+- Improved Windows console resizing, when reducing the vertical size.
+  After Ulf Magnusson. (See GitHub issue #26.)
+
+- Bring back ifdef'd CONSOLE_SCREEN_BUFFER_INFOEX, for the benefit of
+  older compile environments. (Not automatic -- must specify INFOEX=N on
+  the command line.) After Simon Sobisch.
+
+- Replaced COMMON_LVB_* with numbers to appease some old compilers.
+  After Simon Sobisch.
+
+- KEY_RESIZE should be key_code = TRUE. Reported by Ulf Magnusson.
+
+- SDL2 resize fixes to prevent crashes, by Tim Hentenarr.
+
+- SDL2 fixes for handling of SDL_TEXTINPUT, keys with modifiers, and
+  modifier keystrokes, by Tim Hentenarr.
+
+- Fixed cursor rendering in SDL/TTF.
+
+- SDL1 support is now dropped for Windows and macOS, and deprecated for
+  Linux. Use SDL2. The SDL1 port is likely to be dropped in the future.
+
+- The setsyx() function is now void, after ncurses, and simplified.
+
+- Warning fixes by Patrick Georgi and Stefan Reinauer.
+
+- X11 used SP->resized in a non-boolean way, so it's now a short.
+
+- Under some conditions (see issue #47), the X11 port could "free" colors
+  that it hadn't allocated. Reported by rin-kinokocan.
+
+- New scroller for ozdemo -- no memory allocation, less copying -- to
+  resolve issue #46.
+
+- Various minor Makefile tweaks.
+
+- Eliminated term.h and terminfo.c, and moved mvcur() to move.c. These
+  stub functions, done on request (with others then requesting that I
+  take them away -- can't win), were a misguided attempt to facilitate
+  using PDCurses with certain non-C languages -- which, apparently, they
+  didn't end up actually doing. They're also, regrettably, specified as
+  part of the X/Open curses standard, even though they in effect
+  describe an entirely different interface layer (one on which
+  traditional curses, but not PDCurses, is built).
+
+- Dropped support for short (16-bit) chtypes.
+
+- Finally removed deprec.c, as it promised.
+
+- Dropped the XOPEN, SYSVcurses and BSDcurses defines from curses.h, as
+  well as NULL (which is defined in stdio.h, included). TRUE, FALSE, ERR
+  and OK are now defined unconditionally.
+
+- Moved pdcurses.org hosting to GitHub -- as a result, the site is now
+  part of the repo, in the docs/ directory. (Also, it has SSL again.)
+
+See the git log for more details.
+
+------------------------------------------------------------------------
+
+PDCurses 3.6 - 2018-02-14
+=========================
+
+[Note : this is a copy of wmcbrine's update history for that version.
+The changes involved have,  however,  now been integrated into
+this fork.]
+
+Tidying up some loose ends from 3.5, and trying to bring all platforms
+up to the same level, as much as possible.
+
+New features
+------------
+
+- 256 colors for the Windows console -- under Windows 10 or ConEmu,
+  only. This version doesn't allow init_color() or color_content() for
+  colors 16-255, just uses Windows' predefined palette (which matches
+  xterm-256color, like the default colors in X11 and SDL).
+
+- Real blinking for the Windows console (all), and for OS/2 -- done in
+  software, like the Windows version -- replacing the erraticly working
+  Vio-based version (which didn't work at all in my OS/2 4.5 VM). OS/2
+  now always has 16 colors, and bright backgrounds can combine with
+  blinking.
+
+- In DOS, OS/2 and Windows, attribute behavior now more closely matches
+  that of the more "advanced" ports (X11 and SDL) -- see the Attribute
+  test in testcurs.
+
+- All of the A_* and WA_* attributes from X/Open are now defined in
+  curses.h, although some are no-ops, pending the availablity of more
+  attribute bits. A_INVIS is now a no-op on all platforms, instead of
+  overloading A_ITALIC, and so is A_PROTECT. A_LEFT and A_RIGHT are now
+  synonyms for PDCurses' old *LINE attributes.
+
+
+Bug fixes and such
+------------------
+
+- For the X11 port, "make install" and the dynamic library build were
+  broken, since the configure move. Fixes partly after Mark Hessling.
+
+- Renamed "win32" to the more accurate/descriptive "wincon" (i.e.
+  WINdows CONsole). Makefiles for all platforms renamed to remove the
+  redundant platform names, and to allow better sorting.
+
+- In SDL2, apps that didn't explicitly handle resizing locked up. Now,
+  they can continue running, at their old size. (To Do: xmas is still a
+  basket case.)
+
+- Added "/MACHINE:$(PLATFORM)" to wincon/Makefile.vc -- Thomas Dickey
+  says this is needed to build 64-bit with Visual Studio Express 2012.
+  With 2017, it suppresses a warning.
+
+- Suppressed "Possibly incorrect assignment" warnings with BCC, which
+  also results in more readable code.
+
+- Cleaned up obsolete comments, dead code, unneeded includes, typos, and
+  outdated documentation.
+
+- Dropped support for EMXVIDEO.
+
+- Dropped color remapping for OS/2 (broken).
+
+- Dropped X11 DLL support for Cygwin (broken).
+
+- Rearranged extended color display in testcurs.
+
+- In ptest, handle resizing, and check for screens too small to run in.
+
+- Allow KEY_* codes (including KEY_RESIZE) to exit firework, as other
+  keys do.
+
+- Slightly faster Windows compilation (most noticeable in Watcom).
+
+See the git log for more details.
+
+------------------------------------------------------------------------
+
+PDCurses 3.5 - 2018-01-15
+=========================
+
+So, it's been a while, eh?
+
+This release is an attempt to bring PDCurses mostly up to date, without
+breaking too many things in the process.
+
+
+New features
+------------
+
+- SDL2 port, and TTF and Unicode support for both SDL1 and SDL2. Credit
+  for these goes mostly to Laura Michaels and Robin Gustafsson.
+
+- 256 colors for SDL and X11, by Bill Gray. Colors 16-255 are set up to
+  match xterm colors, but can be redefined, as with 0-15.
+
+- Bold and italic font options for SDL and X11. A_BOLD's behavior is
+  controlled by the new function PDC_set_bold() -- TRUE to select bold
+  font, FALSE to choose high foregound intensity (as before). Italic
+  fonts are selected by A_ITALIC (always on). X11 originally from Mark
+  Hessling.
+
+- Real blinking in SDL and X11, controlled by PDC_set_blink(). Largely
+  due to Kevin Lamonte and Bill Gray.
+
+- Support for A_UNDERLINE, A_LEFTLINE and A_RIGHTLINE in the Windows
+  console. This requires a recent version of Windows (10, maybe 8?) to
+  work with the standard console, but underlining also works with
+  ConEmu, at least as far back as XP.
+
+- User resizing (i.e. grab window edges or maximize button) for Windows
+  console -- needs recent Windows or ConEmu.
+
+- New-style color-changing code for the Windows console (using the new
+  offical API instead of undocumented functions), supporting
+  redefinition of colors 0-15 via init_color(). Works at least as far
+  back as Windows XP SP3. Patch by "Didrole".
+
+- The Windows console port now creates a separate console buffer by
+  default, making for a cleaner and more complete restoration of the
+  original buffer. The old behavior can be used by setting
+  "PDC_RESTORE_SCREEN=0". Patch by Jason Hood.
+
+- Left/right scroll wheel support for Windows console, SDL and X11. X11
+  by Mark Hessling.
+
+- testcurs now includes an additional test to show various attributes,
+  and a display of the extended colors, where applicable.
+
+
+Bug fixes and such
+------------------
+
+- termattrs() now returns something vaguely resembling the actual
+  capabilities of the specific "terminal". Specifically, A_BOLD and
+  A_BLINK reflect the availability of true bold fonts, and real
+  blinking; when not set in termattrs(), the attributes still work, but
+  control foreground and background intensity, as before. *LINE are also
+  meaningful, and even A_COLOR is set (or not).
+
+- pad size check in pnoutrefresh() was broken since 3.0. Reported by
+  Peter Hull.
+
+- In newpad(), begx and begy should be set to zero, otherwise creating a
+  subpad of the same width or height fails due to the check in subpad().
+  Patch by Raphael Assenat.
+
+- More straightforward math for subpad(), plus another off-by-one error.
+  Reported by Werner Wenzel, John Hartmann et al.
+
+- New subwindows/subpads/resized windows should copy _delayms. Patch by
+  "xaizek".
+
+- Potentially invalid saved cursor position in resize_window() --
+  another off-by-one _maxx/_maxy error. Patch after "Luke-Jr".
+
+- copywin() needs to disallow corner values equal to _maxx or _maxy, not
+  just less than. Reported by "Aleksandr".
+
+- Misaligned soft-label keys in 4-4-4 mode. Reported by Werner Wenzel.
+
+- Missing prototypes for bkgrnd() and bkgrndset().
+
+- Missing WA_NORMAL and WA_ATTRIBUTES from the X/Open spec.
+
+- keyname() and termname() now return static buffers, as documented.
+
+- In the X11 port, due to (post-PDCurses-3.4) changes in Xt,
+  XtAppMainLoop() always hung. Fixed by re-implementing it within
+  PDCurses, basically.
+
+- Fix blinking X11 cursor for clients that call move() more frequently
+  than cursorBlinkRate -- patch by Kevin Lamonte.
+
+- Improved cursor rendering for X11, by John P. Hartmann.
+
+- ALT key combos sometimes not reported in X11, per Mark Hessling et al.
+
+- Support for XK_ISO_Left_Tab in X11, by John P. Hartmann.
+
+- Support for "Super" keys in X11, by Bill Gray.
+
+- Make xcurses-config include -DPDC_WIDE when appropriate, per M.H.
+
+- The configure script and accompanying files, which were always
+  specific only to the X11 port (causing considerable confusion), have
+  been moved to the x11 directory.
+
+- In SDL, SP->key_code wasn't being set for KEY_MOUSE events. Reported
+  by Bill Gray.
+
+- SDL events need to keep pumping through non-input delays. (Really
+  messed up on current macOS before this change.)
+
+- SDL2 is outperforming SDL1 by about 10x on the platforms I've tried
+  that support both, so I've removed Makefile.mng from the SDL1 port.
+
+- Updated for the most current compilers, wherever possible; various
+  warning suppressions. All included makefiles were tested with their
+  respective compilers, shortly before release (including the POSIX
+  stuff on macOS with clang, and on Ubuntu Linux with gcc). The oldest
+  compiler I tested with was Turbo C++ 3.0, from 1992; the latest,
+  several compilers from 2017.
+
+- Dropped support for LCC-Win32 -- the official site is shut down.
+
+- Dropped support for Digital Mars -- not updated since 2014, limited
+  makefile, library missing some needed Windows APIs.
+
+- Dropped MS C for DOS, and Cset/2 for OS/2.
+
+- Dropped support for building DLLs with EMX.
+
+- Minor code and makefile reorganization; mingwin32.mak merged into
+  gccwin32.mak (i.e. you can use it with both compilers). Some
+  contributions by Bill Gray and Simon Sobisch.
+
+- Watcom makefile paths and option markers changed to Unix-friendly
+  style, after Tee-Kiah Chia.
+
+- The *.def files are no longer needed, replaced by more PDCEX
+  declarations in the include files. After Bill Gray and Simon Sobisch.
+
+- When building with DEBUG=Y, no longer strip the executables. After
+  Simon Sobisch.
+
+- Hold debug file ("trace") open after traceon(), for greater
+  performance. Set PDC_TRACE_FLUSH to make it fflush() after each write
+  (slower but safer in case of a crash). Patch by Ellie Timoney.
+
+- Since 3.2, the panel library was simply a copy of the main library.
+  This kludge is now dropped. (panel.h remains separate from curses.h.)
+
+- Removed PDCurses.spec, and the RPM-building makefile option. I think
+  this is better left to the various package/distro maintainers.
+
+- Various formatting corrections (e.g., trailing spaces stripped), and
+  variables renamed to avoid clashes. Some contributed by Stefan
+  Reinauer and Bill Gray.
+
+- Various documentation corrections and updates. All documentation
+  "converted" to Markdown format (involving few actual changes -- mainly
+  the file extension), for better rendering on GitHub, SourceForge, etc.
+  Some contributed by Anatoly Techtonik.
+
+- The "Win32" label is deprecated by Microsoft, and accordingly I've
+  replaced references in the documentation, although not yet changed the
+  filenames. The Windows console code can just as well be built for
+  64-bit (and always could be, AFAIK, although there are minor tweaks
+  to support it in this version).
+
+- The ncurses_tests can now be built under SDL as well as X11. Also, all
+  our tests (still/again) build under recent ncurses.
+
+- Put testcurs' "Output test" into real blink mode, if possible; and if
+  COLORS >= 16, use colors 0-15 directly in the color test, instead of
+  or'ing with A_BOLD to get the high-intensity colors.
+
+- Renamed the (by now rather old) "newdemo" to "ozdemo".
+
+- Moved from CVS to git; source is now on GitHub as well as SourceForge;
+  central site is now pdcurses.org.
+
+See the git log for more details.
+
+------------------------------------------------------------------------
+
+PDCurses 4.0.2 - 2017 Sep 12   (Bill Gray fork)
+=========================
+   (Note that history gets confused here;  we have things happening
+in two forks.)
+
+Major new features:
+-------------------
+
+- New WinGUI (Windows GUI) and SDL2 backends.
+  SDL1 is still supported, but may eventually go away.
+
+- Bold, italic, underlined, overlined, dimmed, 'strikeout', blinking text,
+  256 colors and color pairs,  and full RGB colors.
+  These are all supported in WinGUI and mostly supported in X11, SDL1 and SDL2.
+
+- In WinGUI, one can choose a font, and both programmatic and user resizing
+  are supported.
+  (Recompiling is necessary to change the font in X11.)
+
+- (WinGUI only) Support of SMP Unicode (points beyond 64K) and combining
+  characters.
+  This may be extended to X11 and SDL2 eventually.
+
+- Demos corrected to be buildable and testable with `ncurses`.
+
+Minor new features
+-------------------
+(note that not all of these are available on all backends)
+
+- Support for up to nine mouse buttons and wheel and tilt-wheel mice, and
+  double and triple mouse clicks
+
+- (X11, WinGUI, Win32) Extended range of keys that are recognized. This
+  now includes most of the "oddball" keys such as 'browser back' and
+  'favorites' found on some keyboards.
+
+- Blinking cursors in WinGUI and X11 of various shapes (this could be
+  extended to SDLx eventually).
+
+- In X11 and WinGUI, one can call resize_term( ) before initscr( ) to set
+  the initial window size.
+
+- Soft Label Keys (SLKs) are considerably more flexible,  with the ability
+  to set arbitrary numbers of keys and groupings.
+  See slk.c for details. This applies to all backends.
+
+- Many changes to `testcurs` to test all these new features, and `newtest`
+  added to test still more features.
+
+- Option to get detailed version information of the used PDCurses library
+  at run time with new exported `PDC_version` as `PDC_version_info` structure.
+
+- ACS_x and WACS_x #defines extended to include a lot of "alternative
+  characters" that overlap in Unicode and CP-437:  double-line box chars,
+  card suits,  vulgar fractions,  etc.
+  This applies to all backends.  See `acs_defs.h` for the full list.
+
+- Cleaned up some makefiles for Win32 and WinGUI.
+  On both platforms, `vcwin32.mak` can now be used with the Intel(R) compiler,
+  and `mingwin32.mak` can be used to cross-compile from Linux, or in
+  `command.com` under Windows, or with Cygwin/MSYS.
+  Also added a makefile for Digital Mars for the DOS version.
+
+------------------------------------------------------------------------
+
+PDCurses 3.4 - 2008-09-08
+=========================
+
+Nothing much new this time, but I've been sitting on some bug fixes for
+almost a year, so it's overdue. Apart from bugs, the main changes are in
+the documentation.
+
+New features:
+
+- setsyx() is now a function rather than a macro.
+
+Bug fixes and such:
+
+- In x11, the xc_atrtab table size was under-calculated by half,
+  resulting in crashes at (oddly) certain line counts. (It should've
+  crashed a lot more.) Reported by Mark Hessling.
+
+- Test for moved cursor was omitting the window origin offset. Reported
+  by Carey Evans.
+
+- Is DOS and OS/2, the value for max items in key_table was still wrong.
+  Reported by C.E.
+
+- Changed isendwin() so it won't crash after delscreen().
+
+- Ensure zero-termination in PDC_mbstowcs() and PDC_wcstombs().
+
+- Disable QuickEdit Mode when enabling mouse input for the Win32
+  console; reported by "Zalapkrakna".
+
+- Fix for building under Innotek C (I hope). Report by Elbert Pol, fix
+  courtesy of Paul Smedley.
+
+- Unified exports list with no duplicates -- pdcurses.def is now built
+  from components at compile time.
+
+- Don't install curspriv.h, and don't include it with binary
+  distributions.
+
+- Building DLLs with LCC is no longer supported, due to the primitive
+  nature of its make.exe.
+
+- Export the terminfo stub functions from the DLLs, too.
+
+- Added support for Apple's ".dylib" in configure. Suggested by Marc
+  Vaillant (who says it's needed with OS 10.5.)
+
+- In sdl1/Makefile.mng, ensure that CC is set.
+
+- In the gcc makefiles, "$?" didn't really have the desired effect --
+  _all_ the dependencies showed up on the command line, including
+  curses.h, and pdcurses.a twice.  And apparently, this can mess up some
+  old version (?) of MinGW. So, revert to spelling out "tuidemo.o
+  tui.o". Reported by "Howard L."
+
+- Extensive documentation revision and reorganizing. More to do here.
+  For example, I moved the build instructions from INSTALL (which never
+  really described installation) to the platform-specific READMEs.
+
+- New indentation standard: four spaces, no tabs.
+
+------------------------------------------------------------------------
+
+PDCurses 3.3 - 2007-07-11
+=========================
+
+This release adds an SDL backend, refines the demos, and is faster in
+some cases.
+
+New features:
+
+- SDL port. See INSTALL, doc/sdl.txt and sdl1/* for details.
+
+- Double-buffering -- minimize screen writes by checking, in doupdate()
+  and wnoutrefresh(), whether the changes to curscr are really changes.
+  In most cases, this makes no difference (writes were already limited
+  to areas marked as changed), but it can greatly reduce the overhead
+  from touchwin(). It also helps if you have small, separated updates on
+  the same line.
+
+- The PDC_RGB colors can now be used, or not, with any platform (as long
+  as the same options are used when compiling both the library and
+  apps). This may help if you have apps that are hardwired to assume
+  certain definitions.
+
+- Restored the use_default_colors() stuff from the ncurses versions of
+  the rain and worm demos, to make them "transparent" (this is useful
+  now, with the SDL port); added transparency to newdemo.
+
+- Added setlocale() to tuidemo, to make it easier to browse files with
+  non-ASCII characters.
+
+- Sped up firework demo by replacing unneeded clear() and init_pair()
+  calls.
+
+- Allow exit from ptest demo by typing 'q'.
+
+- New functions for implementors: PDC_pair_content() and PDC_init_pair()
+  (the old pdc_atrtab stuff was arguably the last remnant of code in the
+  pdcurses directory that was based on platform details).
+
+Bug fixes and such:
+
+- Implicit wrefresh() needs to be called from wgetch() when the window's
+  cursor position is changed, even if there are no other changes.
+
+- Set SP->audible on a per-platform basis, as was documented in
+  IMPLEMNT, but not actually being done.
+
+- Minor tweaks for efficiency and readability, notably with wscrl().
+
+- tuidemo didn't work correctly on monochrome screens when A_COLOR was
+  defined -- the color pair numbers appeared as the corresponding
+  character; also, the input box was (I now realize) broken with ncurses
+  since our 2.7, and broke more subtly with PDCurses' new implicit
+  refresh handling; also, the path to the default file for the Browse
+  function was a bit off.
+
+- Assume in the demos that curs_set() is always available -- there's no
+  good test for this, and the existing tests were bogus.
+
+- Made the command-line parameter for ptest work. (If given an argument,
+  it delays that number of milliseconds between changes, instead of
+  waiting for a key, and automatically loops five times.)
+
+- Building the Win32 DLL with MinGW or Cygwin wouldn't work from outside
+  the platform directory.
+
+- Building the X11 port with Cygwin required manually editing the
+  Makefile after configuring; no longer. Reported by Warren W. Gay.
+
+- Minor tightening of configure and makefiles.
+
+- Bogus references to "ACS_BLCORNER" in the border man page. Reported by
+  "Walrii".
+
+- slk_wlabel() was not documented.
+
+- Spelling cleanup.
+
+- Changed RCSIDs to not end with a semicolon -- avoids warnings when
+  compiling with the -pedantic option.
+
+- Merged latin-1.txt into x11.txt.
+
+- Updated config.guess and config.sub to more recent versions.
+
+------------------------------------------------------------------------
+
+PDCurses 3.2 - 2007-06-06
+=========================
+
+This release mainly covers changes to the build process, along with a
+few structural changes.
+
+New features:
+
+- The panel library has been folded into the main library. What this
+  means is that you no longer need to specify "-lpanel" or equivalent
+  when linking programs that use panel functionality with PDCurses;
+  however, panel.lib/.a is still provided (as a copy of pdcurses.lib/.a)
+  so that you can, optionally, build your projects with no changes. It
+  also means that panel functionality is available with the DLL or
+  shared library. Note that panel.h remains separate from curses.h.
+
+- Setting the PDCURSES_SRCDIR environment variable is no longer required
+  before building, unless you want to build in a location other than the
+  platform directory. (See INSTALL.)
+
+- MinGW and Cygwin makefiles support building DLLs, via the "DLL=Y"
+  option. Partly due to Timofei Shatrov.
+
+- Support for the Digital Mars compiler.
+
+- Watcom makefiles now use the "loaddll" feature.
+
+Bug fixes and such:
+
+- Eliminated the platform defines (DOS, WIN32, OS2, XCURSES) from
+  curses.h, except for X11-specific SCREEN elements and functions.
+  Dynamically-linked X11 apps built against an old version will have
+  their red and blue swapped until rebuilt. (You can define PDC_RGB to
+  build the library with the old color scheme, but it would also have to
+  be defined when building any new app.) Any app that depends on
+  PDCurses to determine the platform it's building on will have to make
+  other arrangements.
+
+- Documentation cleanup -- added more details; removed some content that
+  didn't apply to PDCurses; moved the doc-building tool to the doc
+  directory; changed *.man to *.txt.
+
+- The EMX makefile now accepts "DLL=Y", builds pdcurses.dll instead of
+  curses.dll, builds either the static library or the DLL (not both at
+  once), and links all the demos with the DLL when building it.
+
+- In Win32, read the registry only when needed: when init_color() or
+  color_content() is called, instead of at startup.
+
+- A few additional consts in declarations.
+
+- The Win32 compilers that build DLLs now use common .def files.
+
+- panel.h functions sorted by name, as with other .h files; curses.h is
+  no longer included by repeated inclusions of panel.h or term.h.
+
+- Simplified Borland makefiles.
+
+- Makefile.aix.in depended on a file, xcurses.exp, that was never there.
+  This problem was fixed as part of the change to common .def files;
+  however, I still haven't been able to test building on AIX.
+
+------------------------------------------------------------------------
+
+PDCurses 3.1 - 2007-05-03
+=========================
+
+Primarily clipboard-related fixes, and special UTF-8 support.
+
+New features:
+
+- "Force UTF-8" mode, a compile-time option to force the use of UTF-8
+  for multibyte strings, instead of the system locale. (Mainly for
+  Windows, where UTF-8 doesn't work well in the console.) See INSTALL.
+
+- Multibyte string support in PDC_*clipboard() functions, and in Win32's
+  PDC_set_title().
+
+- Added the global string "ttytype", per other curses implementations,
+  for compatibility with old BSD curses.
+
+- Real functions for the "quasi-standard aliases" -- crmode(),
+  nocrmode(), draino(), resetterm(), fixterm() and saveterm().
+  (Corresponding macros removed.)
+
+Bug fixes and such:
+
+- In Win32, under NT-family OSes, the scrollback buffer would be
+  restored by endwin(), but would not be turned off again when resuming
+  curses after an endwin(). The result was an odd, partly-scrolled-up
+  display. Now, the buffer is toggled by PDC_reset_prog_mode() and
+  PDC_reset_shell_mode(), so it's properly turned off when returning
+  from an endwin().
+
+- In 3.0, selection in X11 didn't work. (Well, the selecting worked, but
+  the pasting elsewhere didn't.) This was due to the attempted fix
+  "don't return selection start as a press event," so that's been
+  reverted for now.
+
+- PDC_setclipboard() was locking up in X11. Reported by Mark Hessling.
+
+- Missing underscore in the declaration of XC_say() prevented
+  compilation with PDCDEBUG defined.  Reported by M.H.
+
+- Off-by-one error in copywin() -- the maximum coordinates for the
+  destination window should be inclusive. Reported by Tiago Dionizio.
+
+- Start in echo mode, per X/Open. Reported by T.D.
+
+- Strip leading and trailing spaces from slk labels, per a literal
+  reading of X/Open. Suggested by Alexey Miheev (about ncurses, but it
+  also applies here).
+
+- The #endif for __PDCURSES__ needs to come _after_ the closing of the
+  extern "C". This has been broken since June 2005. Fortunately (?), it
+  only shows up if the file is included multiple times, and then only in
+  C++. Reported on the DOSBox forums.
+
+- Use CF_OEMTEXT instead of CF_TEXT in the narrow versions of the
+  clipboard functions in Win32, to match the console.
+
+- Changed the format of the string returned from longname().
+
+- In the clipboard test in the testcurs demo, use a single mvprintw() to
+  display the return from PDC_getclipboard(), instead of a loop of
+  addch(), which was incompatible with multibyte strings.
+
+- Moved has_key() into the keyname module, and documented it.
+
+- Moved RIPPEDOFFLINE to curspriv.h.
+
+- Typos in IMPLEMNT.
+
+------------------------------------------------------------------------
+
+PDCurses 3.0 - 2007-04-01
+=========================
+
+The focuses for this release are X/Open conformance, i18n, better color
+support, cleaner code, and more consistency across platforms.
+
+This is only a brief summary of the changes. For more details, consult
+the CVS log.
+
+New features:
+
+- An almost complete implementation of X/Open curses, including the
+  wide-character and attr_t functions (but excluding terminfo). The
+  wide-character functions work only in Win32 and X11, for now, and
+  require building the library with the appropriate options (see
+  INSTALL). Note that this is a simplistic implementation, with exactly
+  one wchar_t per cchar_t; the only characters it handles properly are
+  those that are one column wide.
+
+- Support for X Input Methods in the X11 port (see INSTALL). When built
+  this way, the internal compose key support is disabled in favor of
+  XIM's, which is a lot more complete, although you lose the box cursor.
+
+- Multibyte character support in the non-wide string handling functions,
+  per X/Open. This only works when the library is built with wide-
+  character support enabled.
+
+- Mouse support for DOS and OS/2. The DOS version includes untested
+  support for scroll wheels, via the "CuteMouse" driver.
+
+- An ncurses-compatible mouse interface, which can work in parallel with
+  the traditional PDCurses mouse interface. See the man page (or
+  mouse.c) for details.
+
+- DOS and OS/2 can now return modifiers as keys, as in Win32 and X11.
+
+- COLORS, which had been fixed at 8, is now either 8 or 16, depending on
+  the terminal -- usually 16. When it's 8, blinking mode is enabled
+  (controlled as before by the A_BLINK attribute); when it's 16, bright
+  background colors are used instead. On platforms where it can be
+  changed, the mode is toggled by the new function PDC_set_blink().
+  PDCurses tries to set PDC_set_blink(FALSE) at startup. (In Win32, it's
+  always set to FALSE; in DOS, with other than an EGA or VGA card, it
+  can't be.) Also, COLORS is now set to 0 until start_color() is called.
+
+- Corresponding to the change in COLORS, COLOR_PAIRS is now 256.
+
+- Working init_color() and color_content(). The OS/2 version of
+  init_color() works only in a full-screen session; the Win32 version
+  works only in windowed mode, and only in NT-family OSes; the DOS
+  version works only with VGA adapters (real or simulated). The Win32
+  version is based mostly on James Brown's setconsoleinfo.c
+  (www.catch22.net).
+
+- use_default_colors(), assume_default_colors(), and curses_version(),
+  after ncurses.
+
+- Added global int TABSIZE, after ncurses and Solaris curses; removed
+  window-specific _tabsize.
+
+- Logical extension to the wide-character slk_ funcs: slk_wlabel(), for
+  retrieving the label as a wide-character string.
+
+- A non-macro implementation of ncurses' wresize().
+
+- Working putwin(), getwin(), scr_dump() and scr_restore().
+
+- A working acs_map[]. Characters from the ACS are now stored in window
+  structures as a regular character plus the A_ALTCHARSET attribute, and
+  rendered to the ACS only when displayed. (This allows, for example,
+  the correct display on one platform of windows saved from another.)
+
+- In X11, allow selection and paste of UTF8_STRING.
+
+- The testcurs demo now includes a color chart and init_color() test, a
+  wide character input test, a display of wide ACS characters with
+  sample Unicode text, a specific test of flash(), more info in the
+  resize test, and attempts to change the width as well as the height.
+
+- Command-line option for MSVC to build DLLs (see INSTALL). Also, the
+  naming distinction for DLLs ("curses" vs. "pdcurses") is abandoned,
+  and either the static lib or DLL is built, not both at once (except
+  for X11).
+
+- For backwards compatibility, a special module just for deprecated
+  functions -- currently PDC_check_bios_key(), PDC_get_bios_key(),
+  PDC_get_ctrl_break() and PDC_set_ctrl_break(). These shouldn't be used
+  in applications, but currently are... in fact, all the "private"
+  functions (in curspriv.h) are subject to change and should be avoided.
+
+- A new document, IMPLEMNT, describing PDCurses' internal functions for
+  those wishing to port it to new platforms.
+
+- Mark Hessling has released the X11 port to the public domain.
+  (However, x11/ScrollBox* retain their separate copyright and MIT-like
+  license.)
+
+Bug fixes and such:
+
+- Most of the macros have been removed (along with the NOMACROS ifdef).
+  The only remaining ones are those which have to be macros to work, and
+  those that are required by X/Open to be macros. There were numerous
+  problems with the macros, and no apparent reason to keep them, except
+  tradition -- although it was PCcurses 1.x that first omitted them.
+
+- Clean separation of platform-specific code from the rest. Outside of
+  the platform directories, there remain only a few ifdefs in curses.h
+  and curspriv.h.
+
+- General reorganization and simplification.
+
+- Documentation revisions.
+
+- When expanding control characters in addch() or insch(), retain the
+  attributes from the chtype.
+
+- Preserve the A_ALTCHARSET attribute in addch() and insch().
+
+- Per X/Open, beep() should always return OK.
+
+- On platforms with a controlling terminal (i.e., not X11), curs_set(1)
+  now sets the cursor to the shape it had at the time of initscr(),
+  rather than always making it small. (Exception for DOS: If the video
+  mode has been changed by PDC_resize_screen(), curs_set(1) reverts to
+  line 6/7.) The shape is taken from SP->orig_cursor (the meaning of
+  which is platform-specific).
+
+- Stop updating the cursor position when the cursor is invisible (this
+  gives a huge performance boost in Win 9x); update the cursor position
+  from curs_set() if changing from invisible to visible.
+
+- Some tweaking of the behavior of def_prog_mode(), def_shell_mode(),
+  savetty(), reset_prog_mode(), reset_shell_mode() and resetty()...
+  still not quite right.
+
+- flash() was not implemented for Win32 or X. A portable implementation
+  is now used for all platforms. Note that it's much slower than the
+  old (DOS and OS/2) version, but this is only apparent on an extremely
+  slow machine, such as an XT.
+
+- In getstr(), backspacing on high-bit characters caused a double
+  backspace.
+
+- hline() and vline() used an incorrect (off by one) interpretation of
+  _maxx and _maxy. If values of n greater than the max were specified,
+  these functions could access unallocated memory.
+
+- innstr() is supposed to return the number of characters read, not just
+  OK or ERR. Reported by Mike Aubury.
+
+- A proper implementation of insch() -- the PDC_chadd()-based version
+  wasn't handling the control characters correctly.
+
+- Return ASCII and control key names from keyname() (problem revealed by
+  ncurses' movewindow test); also, per X/Open, return "UNKNOWN KEY" when
+  appropriate, rather than "NO KEY NAME".
+
+- Turn off the cursor from leaveok(TRUE), even in X11; leaveok(FALSE)
+  now calls curs_set(1), regardless of the previous state of the cursor.
+
+- In the slk area, BUTTON_CLICKED events now translate to function keys,
+  along with the previously recognized BUTTON_PRESSED events. Of course,
+  it should really be checking the events specified by map_button(),
+  which still doesn't work.
+
+- napms(0) now returns immediately.
+
+- A unified napms() implementation for DOS -- no longer throttles the
+  CPU when built with any compiler.
+
+- Allow backspace editing of the nocbreak() buffer.
+
+- pair_content(0, ...) is valid.
+
+- There was no check to ensure that the pnoutrefresh() window fit within
+  the screen. It now returns an ERR if it doesn't.
+
+- In X11, resize_term() must be called with parameters (0, 0), and only
+  when SP->resized is set, else it returns ERR.
+
+- Copy _bkgd in resize_window(). Patch found on Frederic L. W. Meunier's
+  web site.
+
+- slk_clear() now removes the buttons completely, as in ncurses.
+
+- Use the current foreground color for the line attributes (underline,
+  left, right), unless PDC_set_line_color() is explicitly called. After
+  setting the line color, you can reset it to this mode via
+  "PDC_set_line_color(-1)".
+
+- Removed non-macro implementations of COLOR_PAIR() and PAIR_NUMBER().
+
+- Dispensed with PDC_chadd() and PDC_chins() -- waddch() and winsch()
+  are now (again) the core functions.
+
+- Dropped or made static many obsolete, unused, and/or broken functions,
+  including PDC_chg_attrs(), PDC_cursor_on() and _off(),
+  PDC_fix_cursor(), PDC_get_attribute(), PDC_get_cur_col() and _row(),
+  PDC_set_80x25(), PDC_set_cursor_mode(), PDC_set_rows(),
+  PDC_wunderline(), PDC_wleftline(), PDC_wrightline(),
+  XCursesModifierPress() and XCurses_refresh_scrollbar().
+
+- Obsolete/unused defines: _BCHAR, _GOCHAR, _STOPCHAR, _PRINTCHAR
+  _ENDLINE, _FULLWIN and _SCROLLWIN.
+
+- Obsolete/unused elements of the WINDOW struct: _pmax*, _lastp*,
+  _lasts*.
+
+- Obsolete/unused elements of the SCREEN struct: orgcbr, visible_cursor,
+  sizeable, shell, blank, cursor, orig_emulation, font, orig_font,
+  tahead, adapter, scrnmode, kbdinfo, direct_video, video_page,
+  video_seg, video_ofs, bogus_adapter. (Some of these persist outside
+  the SCREEN struct, in the platform directories.) Added mouse_wait and
+  key_code.
+
+- Removed all the EMALLOC stuff. Straight malloc calls were used
+  elsewhere; it was undocumented outside of comments in curspriv.h; and
+  there are better ways to use a substitute malloc().
+
+- Single mouse clicks are now reportable on all platforms (not just
+  double-clicks). And in general, mouse event reporting is more
+  consistent across platforms.
+
+- The mouse cursor no longer appears in full-screen mode in Win32 unless
+  a nonzero mouse event mask is used.
+
+- ALT-keypad input now works in Win32.
+
+- In Win32, SetConsoleMode(ENABLE_WINDOW_INPUT) is not useful, and
+  appears to be the source of a four-year-old bug report (hanging in
+  THE) by Phil Smith.
+
+- Removed the PDC_THREAD_BUILD stuff, which has never worked. For the
+  record: PDCurses is not thread-safe. Neither is ncurses; and the
+  X/Open curses spec explicitly makes it a non-requirement.
+
+- With the internal compose key system in the X11 port, modifier keys
+  were breaking out of the compose state, making it impossible to type
+  accented capitals, etc. Also, Multi_key is now the default compose
+  key, instead of leaving it undefined by default; and a few more combos
+  are supported.
+
+- In X11, the first reported mouse event after startup always read as a
+  double-click at position 0, 0. (This bug was introduced in 2.8.)
+
+- In X11, don't return selection start as a press event. (Shift-click on
+  button 1 is still returned.)
+
+- In X11, properly handle pasting of high-bit chars. (It was doing an
+  unwanted sign extension.)
+
+- In X11, BUTTON_MOVED was never returned, although PDC_MOUSE_MOVED was
+  set.
+
+- The fix in 2.8 for the scroll wheel in X11 wasn't very good -- it did
+  report the events as scroll wheel events, but it doubled them. Here's
+  a proper fix.
+
+- Changed mouse handling in X11: Simpler translation table, with
+  XCursesPasteSelection() called from XCursesButton() instead of the
+  translation table; require shift with button 1 or 2 for select or
+  paste when mouse events are being reported (as with ncurses), allowing
+  passthrough of simple button 2 events. This fixes the previously
+  unreliable button 2 behavior.
+
+- Modifier keys are now returned on key up in X11, as in Win32. And in
+  general, modifier key reporting is more consistent across platforms.
+
+- Modifiers are not returned as keys when a mouse click has occurred
+  since the key press.
+
+- In BIOS mode (in DOS), count successive identical output bytes, and
+  make only one BIOS call for all of them. This dramatically improves
+  performance.
+
+- The cursor position was not always updated correctly in BIOS mode.
+
+- In testcurs, the way the ACS test was written, it would really only
+  work with a) PDCurses (with any compiler), or b) gcc (with any
+  curses). Here's a more portable implementation.
+
+- Better reporting of mouse events in testcurs.
+
+- Blank out buffer and num before the scanw() test in testcurs, in case
+  the user just hits enter or etc.; clear the screen after resizing.
+
+- Allow tuidemo to use the last line.
+
+- Separate left/right modifier keys are now reported properly in Win32.
+  (Everything was being reported as _R.)
+
+- Attempts to redirect input in Win32 now cause program exit and an
+  error message, instead of hanging.
+
+- Dropped support for the Microway NDP compiler.
+
+- Some modules renamed, rearranged.
+
+- Fixes for errors and warnings when building with Visual C++ 2005.
+
+- In MSVC, the panel library didn't work with the DLL.
+
+- Complete export lists for DLLs.
+
+- Simplified makefiles; moved common elements to .mif files; better
+  optimization; strip demos when possible.
+
+- Changed makefile targets of "pdcurses.a/lib" and "panel.a/lib" to
+  $(LIBCURSES) and $(LIBPANEL). Suggestion of Doug Kaufman.
+
+- Changed "install" target in the makefile to a double-colon rule, to
+  get around a conflict with INSTALL on non-case-sensitive filesystems,
+  such as Mac OS X's HFS+. Reported by Douglas Godfrey et al.
+
+- Make PDCurses.man dependent on manext. Suggestion of Tiziano Mueller.
+
+- Set up configure.ac so autoheader works; removed some obsolescent
+  macros. Partly the suggestion of T.M.
+
+- The X11 port now builds in the x11 directory (including the demos), as
+  with other ports.
+
+- The X11 port should now build on more 64-bit systems. Partly due to
+  M.H.
+
+- The default window title and icons for the X11 port are now "PDCurses"
+  instead of "XCurses".
+
+- Internal functions and variables made static where possible.
+
+- Adopted a somewhat more consistent naming style: Internal functions
+  with external linkage, and only those, have the prefix "PDC_";
+  external variables that aren't part of the API use "pdc_"; static
+  functions use "_"; and "XC_" and "xc_" prefixes are used for functions
+  and variables, respectively, that are shared between both processes in
+  the X11 port. Also eliminated camel casing, where possible.
+
+- Changed the encoding for non-ASCII characters in comments and
+  documentation from Latin-1 to UTF-8.
+
+------------------------------------------------------------------------
+
+PDCurses 2.8 - 2006-04-01
+=========================
+
+As with the previous version, you should assume that apps linked against
+older dynamic versions of the library won't work with this one until
+recompiled.
+
+New features:
+
+- Simpler, faster.
+
+- Declarations for all supported, standard functions, per the X/Open
+  Curses 4.2 spec, with the notable exception of getch() and ungetch().
+  You can disable the use of the macro versions by defining NOMACROS
+  before including curses.h (see xmas.c for an example). NOMACROS yields
+  smaller but theoretically slower executables.
+
+- New functions: vwprintw(), vwscanw(), vw_printw() and vw_scanw(). This
+  completes the list of X/Open 4.2 functions, except for those concerned
+  with attr_t and wide characters. Some (especially the terminfo/termcap
+  functions) aren't yet fully fleshed out, though.
+
+- Non-macro implementations for COLOR_PAIR(), PAIR_NUMBER(), getbkgd(),
+  mvgetnstr(), mvwgetnstr(), mvhline(), mvvline(), mvwhline(), and
+  mvwvline(). (The macros are still available, too.)
+
+- newterm() works now, in a limited way -- the parameters are ignored,
+  and only the first invocation will work (i.e., only one SCREEN can be
+  used).
+
+- start_color() works now -- which is to say, if you _don't_ call it,
+  you'll only get monochrome output. Also, without calling it, the
+  terminal's default colors will be used, where supported (currently
+  only in Win32). This is equivalent to the PDC_ORIGINAL_COLORS behavior
+  introduced in 2.7, except that _only_ the default colors will be used.
+  (PDC_ORIGINAL_COLORS is still available, if you want to combine the
+  use of specific colors and the default colors.)
+
+- New logic for termname() and longname(): termname() always returns
+  "pdcurses"; longname() returns "PDCurses for [platform] [adapter]
+  [COLOR/MONO]-YxX" (adapter is only defined for DOS and OS/2). This is
+  the first time these functions return _anything_ in Win32.
+
+- New installation method for XCurses: the header files are placed in a
+  subdirectory "xcurses" within the include directory, rather than being
+  renamed. (But the renamed xcurses.h and xpanel.h are also installed,
+  for backwards compatibility.) curspriv.h and term.h are now available,
+  and existing curses-based code need no longer be edited to use
+  XCurses' curses.h. And with no more need for explicit XCursesExit()
+  calls (see below), your code need not be changed at all to move from
+  another curses implementation to XCurses. It can be as simple as "gcc
+  -I/usr/local/include/xcurses -lXCurses -oprogname progname.c".
+
+- Combined readme.* into this HISTORY file, and incorporated the old 1.x
+  (PCcurses) history.
+
+- New functionality for the testcurs demo: ACS character display; menu
+  support for PgUp, PgDn, Home and End; centered menu; and it can now
+  be resized in X.
+
+- Added modified versions of the rain and worm demos from ncurses.
+
+Bug fixes and such:
+
+- Big cleanup of dead and redundant code, including unneeded defines,
+  ifdefs, and structure elements.
+
+- flushinp() was not implemented for Win32.
+
+- resetty() was not restoring LINES and COLS.
+
+- nonl() made '\n' print a line feed without carriage return. This was
+  incorrect.
+
+- Removed bogus implementation of intrflush().
+
+- The line-breakout optimization system, disabled by default in 2.7, is
+  removed in 2.8. It simply didn't work, and never has. (The typeahead()
+  function remains, for compatibility, but does nothing.)
+
+- The declarations for the printw() and scanw() function families were
+  erroneously ifdef'd.
+
+- Safer printw() calls on platforms that support vsnprintf().
+
+- Use the native vsscanf() in DJGPP, MinGW and Cygwin.
+
+- ACS_BLOCK now works in X.
+
+- Explicit calls to XCursesExit() are no longer needed.
+
+- XCURSES is now defined automatically if not DOS, OS2 or WIN32.
+
+- The default icon for XCurses wasn't working (had to remove the focus
+  hint code to fix this). Also, the default title is now "XCurses"
+  instead of "main".
+
+- Incorrect dimensions (undercounting by two in each direction) were
+  shown while resizing in X.
+
+- Scroll wheel events were not always correctly reported in X.
+
+- 32 bits are enough for the "long" chtype, but 64 bits were used on a
+  64-bit system, wasting memory. Now conditioned on _LP64. This could be
+  faster, too.
+
+- The short, 16-bit chtype now works with XCurses.
+
+- Corrected return value for is_linetouched(), is_wintouched(),
+  can_change_color() and isendwin() (bool instead of int).
+
+- timeout(), wtimeout(), idcok() and immedok() return void.
+
+- pair_content() takes a short.
+
+- Replaced incorrect usages of attr_t with chtype. attr_t is still
+  typedef'd, for backwards compatibility. (It's supposed to be used for
+  the WA_*-style functions, which PDCurses doesn't yet support.)
+
+- Added const where required by the spec, and in other appropriate
+  places.
+
+- Removed PDC_usleep(). napms() is now the core delay routine.
+
+- Fixed poll() support in napms().
+
+- Various changes to the internal PDC_* functions -- don't depend on
+  these, and don't use them unless you absolutely have to.
+
+- Some routines accessed window structures in their variable
+  declarations, _before_ checking for a NULL window pointer.
+
+- Dropped support for the undocumented PDC_FULL_DISPLAY, wtitle(), and
+  PDC_print().
+
+- Cleaned up remaining warnings.
+
+- Reduced unnecessary #include directives -- speeds up compilation.
+
+- Fix for demos build in Borland/DOS -- the makefile in 2.7 didn't
+  specify the memory model. Reported by Erwin Waterlander.
+
+- Simplified the makefiles; e.g., some now build each demo in a single
+  step, and Watcom no longer uses demos.lnk. Also, the demo exes are now
+  stripped when possible; maximum compression used for archives built
+  by the makefiles; xcurses-config removed as part of "make distclean";
+  and I tweaked optimization for some platforms.
+
+- Reverted to /usr/local/ as default installation directory for XCurses.
+
+- Upgraded to autoconf 2.59... instantly doubling the size of the
+  configure script. Ah well. Otherwise, simplified the build system.
+
+- Dropped support for pre-ANSI compilers. (It hasn't worked since at
+  least version 2.4, anyway.)
+
+- Revised and, I hope, clarified the boilerplate and other comments.
+
+- Simplified logging and RCS ids; added RCS ids where missing.
+
+- Consistent formatting for all code, approximately equivalent to
+  "indent -kr -i8 -bl -bli0", with adjustments for 80 columns.
+
+------------------------------------------------------------------------
+
+PDCurses 2.7 - 2005-12-30
+=========================
+
+INTRODUCTION:
+
+Hello all. As of a few weeks ago, I'm the new maintainer for PDCurses.
+Here's a brief summary of changes in this release. (More details are
+available in the CVS log and trackers on SourceForge.)
+
+NEW FEATURES:
+
+- Functions: delscreen(), getattrs(), has_key(), slk_color(),
+  wcolor_set(), wtimeout().
+
+- Macros: color_set(), mvhline(), mvvline(), mvwgetnstr(), mvwhline(),
+  mvwvline(), timeout(), wresize().
+
+- Stub implementations of terminfo functions (including a term.h).
+
+- More stubs for compatibility: filter(), getwin(), putwin(),
+  noqiflush(), qiflush(), scr_dump(), scr_init(), scr_restore(),
+  scr_set(), use_env(), vidattr(), vidputs().
+
+- The terminal's default colors are used as curses' default colors when
+  the environment variable "PDC_ORIGINAL_COLORS" is set to any value
+  (Win32 only at the moment).
+
+- Simplified build system.
+
+- Replaced PDC_STATIC_BUILD with its opposite, PDC_DLL_BUILD (see .mak
+  files for more info).
+
+- Minimal implementation of color_content() -- no longer a stub.
+
+- Added the remaining ACS defines (ACS_S3, ACS_BBSS, etc.) for
+  DOS/OS2/Win; "enhanced" versions of existing ACS characters used.
+
+- Support for scroll wheels.
+
+- Support for Pacific C.
+
+BUGS FIXED:
+
+- Builds correctly (including demos) on all tested platforms (see
+  below); nearly all compiler warnings have been cleaned up; the ptest
+  demo is built on all platforms; "clean" targets are improved.
+
+- The ability to build ncurses_tests has been restored (see demos dir).
+
+- Line-breakout optimization now defaults to off (equivalent to
+  "typeahead(-1)"), so output is not interrupted by keystrokes (it's
+  supposed to resume on the next refresh(), which wasn't working).
+
+- Implicit wrefresh() in wgetch() was not being invoked in nodelay mode.
+
+- subpad() was erroneously offsetting from the origin coordinates of the
+  parent pad (which are always -1,-1).
+
+- In wborder(), whline(), and wvline(), the current (wattrset) attribute
+  was being used, but not the current background (wbkgd).
+
+- Allow Russian 'r' character ASCII 0xe0 to be returned.
+
+- termattrs() now also returns A_UNDERLINE, A_REVERSE.
+
+- In Win32, with large scrollback buffers set, there was an unwanted
+  "scrollup" effect on startup.
+
+- Revamped keyboard handling for Win32.
+
+- New screen resize method for Win32.
+
+- napms(), delay_output(), etc. now work with Cygwin.
+
+- curs_set(0) wasn't working in Win32 in full-screen (ALT-ENTER) mode --
+  the cursor stayed on.
+
+- The A_REVERSE attribute was broken in XCurses.
+
+- On 64-bit systems, XCurses was ignoring every other keystroke.
+
+- Added focus hints for XCurses.
+
+- Demos (except for tuidemo) once again have their proper titles in
+  XCurses (using Xinitscr() instead of the obsolete XCursesProgramName).
+
+- The 16-bit chtype is a working option again (by removing #define
+  CHTYPE_LONG from curses.h), except in XCurses. It's not recommended;
+  but if your needs are limited, it still works.
+
+- Reset screen size in resetty() under DOS, as in Win32 and OS/2.
+
+- Changes for cursor size under DOS.
+
+- Automatic setting of BIOS mode for CGA under DOS now works.
+
+- The cursor is now always updated in PDC_gotoxy(); this fixes the
+  problem of missing characters in BIOS mode.
+
+- Macros nocbreak(), cbreak(), nocrmode(), crmode(), nodelay(),
+  nl() and nonl() now return OK.
+
+- ERR and OK are now defined as -1 and 0, respectively, for
+  compatibility with other curses implementations -- note that this
+  change is not binary compatible; you'll have to rebuild programs that
+  use shared/dynamic libraries.
+
+- Added "const" to prototypes where appropriate.
+
+- Miscellaneous code cleanup.
+
+ACKNOWLEDGEMENTS:
+
+ - Walter Briscoe
+ - Jean-Pierre Demailly
+ - Ruslan Fedyarov
+ - Warren Gay
+ - Florian Grosse-Coosmann
+ - Vladimir Kokovic
+ - Matt Maloy
+ - K.H. Man
+ - Michael Ryazanov
+ - Ron Thibodeau
+ - Alexandr Zamaraev
+
+and of course, MARK HESSLING, for his over 13 years of service as the
+maintainer of PDCurses. Plus, thanks to all who've reported bugs or
+requested features. Apologies to anyone I've forgotten.
+
+I've tested this version on Turbo C++ 3.0 and Borland C++ 3.1 for DOS;
+DJGPP 2.X; Open Watcom 1.3 for DOS (16 and 32-bit), Windows and OS/2;
+EMX 0.9d and the "newgcc" version of EMX; Borland C++ 5.5 for Windows;
+recent versions of MinGW, Cygwin, LCC-Win32 and Microsoft Visual C++;
+and gcc under several flavors of Linux, Mac OS X, *BSD and Solaris.
+
+-- William McBrine
+
+------------------------------------------------------------------------
+
+PDCurses 2.6 - 2003-01-08
+=========================
+
+INTRODUCTION:
+
+ This release of PDCurses includes the following changes:
+
+BUGS FIXED:
+
+- Allow accented characters on Win32 platform when run on non-English
+  keyboards.
+
+- Allow "special" characters like Ctrl-S, Ctrl-Q under OS/2 to be returned.
+
+- Some bugs with halfdelay() fixed by William McBrine.
+
+- pechochar() should now work correctly.
+
+- redrawwin() macro in curses.h was incorrect - fixed by Alberto Ornaghi
+
+- Don't include "special" characters like KEY_SHIFT_L to be returned in
+  getnstr() family. Bug 542913
+
+- Entering TAB in wgetnstr() no longer exceeds requested buffer size.
+  Bug 489233
+
+- Fixed bug 550066, scrollok() and pads.
+  Also beep() called when buffer exceeded. Bug 562041.
+
+- Reverse video of X11 selection reinstated. Pablo Garcia Abio??
+
+- Right Alt modifier now works like left Alt modifier under Win32
+
+- Add support for all libXaw replacement libraries with Scrollbar bug.
+  Note that for this to work, you still have to change the libXaw
+  replacement libraries to fix the bug :-(
+
+- Don't trap signals in XCurses if calling application has ignored them.
+  Change by Frank Heckenbach.
+
+- Bug reports from Warren W. Gay:
+  - Fix termattrs() to return A_REVERSE and A_BLINK on all platforms.
+  - Fix definition of getsyx() and setsyx() to be consistent with
+    ncurses. Bug 624424.
+  - Fix definition of echo() and noecho(). Bug 625001.
+  - Fix definition of keypad() and leaveok(). Bug 632653.
+  - Missing panel_hidden() prototype. Bug 649320.
+
+- Fixed bug with calling def_prog_mode(), resize_term(),
+  reset_prog_mode(); the resize details were being lost.
+
+NEW FEATURES:
+
+- Clipboard support now available on DOS platform, but handled
+  internally to the currently running process.
+
+- New X11 resource: textCursor, allows the text cursor to be specified
+  as a vertical bar, or the standard horizontal bar. Thanks to Frank
+  Heckenbach for the suggestion.
+
+NEW COMPILER SUPPORT:
+
+- lcc-win32 now works correctly
+
+------------------------------------------------------------------------
+
+PDCurses 2.5 - 2001-11-26
+=========================
+
+INTRODUCTION:
+
+ This release of PDCurses includes the following changes:
+
+- Set BASE address for Win32 DLL
+
+- Add KEY_SUP and KEY_SDOWN.
+
+- Add PDC_set_line_color()
+
+- Add blink support as bold background
+
+- Add bold colors
+
+- Add getbkgd() macro
+
+- Add new PDC functions for adding underline, overline, leftline and
+  rightline
+
+- Add support for shifted keypad keys.
+
+- Allow more keypad keys to work under Win32
+
+- Change Win32 and OS/2 DLL name to curses.dll
+
+- Change example resources to allow overriding from the command line
+
+- Changes for building cleanly on OS/2
+
+- Changes to handle building XCurses under AIX
+
+- Check if prefresh() and pnoutrefresh() parameters are valid.
+
+- Ensure build/install works from any directory
+
+- Handle platforms where X11 headers do not typedef XPointer.
+
+- Mention that Flexos is likely out-of-date.
+
+- Pass delaytenths to XCurses_rawgetch()
+
+- Remove boldFont
+
+- Updates for cursor blinking and italic.
+
+BUGS FIXED:
+
+- Fix bug with getting Win32 clipboard contents. Added new
+  PDC_freeclipboard() function.
+
+- Fix bug with halfdelay()
+
+- Fix bug with mouse interrupting programs that are not trapping mouse
+  events under Win32.
+
+- Fix return value from curs_set()
+
+- Reverse the left and right pointing bars in ALT_CHARSET
+
+NEW COMPILER SUPPORT:
+
+- Add QNX-RTP port
+
+------------------------------------------------------------------------
+
+PDCurses 2.4 - 2000-01-17
+=========================
+
+INTRODUCTION:
+
+ This release of PDCurses includes the following changes:
+
+- full support of X11 selection handling
+
+- removed the need for the cursos2.h file
+
+- enabled the "shifted" key on the numeric keypad
+
+- added native clipboard support for X11, Win32 and OS/2
+
+- added extra functions for obtaining internal PDCurses status
+
+- added clipboard and key modifier tests in testcurs.c
+
+- fixes for panel library
+
+- key modifiers pressed by themselves are now returned as keys:
+  KEY_SHIFT_L KEY_SHIFT_R KEY_CONTROL_L KEY_CONTROL_R KEY_ALT_L KEY_ALT_R
+  This works on Win32 and X11 ports only
+
+- Added X11 shared library support
+
+- Added extra slk formats supported by ncurses
+
+- Fixed bug with resizing the terminal when slk were on.
+
+- Changed behavior of slk_attrset(), slk_attron() slk_attroff()
+  functions to work more like ncurses.
+
+BUGS FIXED:
+
+- some minor bug and portability fixes were included in this release
+
+NEW FUNCTIONS:
+
+- PDC_getclipboard() and PDC_setclipboard() for accessing the native
+  clipboard (X11, Win32 and OS/2)
+
+- PDC_set_title() for setting the title of the window (X11 and Win32
+  only)
+
+- PDC_get_input_fd() for getting the file handle of the PDCurses input
+
+- PDC_get_key_modifiers() for getting the keyboard modifier settings at
+  the time of the last (w)getch()
+
+- Xinitscr() (only for X11 port) which allows standard X11 switches to
+  be passed to the application
+
+NEW COMPILER SUPPORT:
+
+- MingW32 GNU compiler under Win95/NT
+
+- Cygnus Win32 GNU compiler under Win95/NT
+
+- Borland C++ for OS/2 1.0+
+
+- lcc-win32 compiler under Win95/NT
+
+ACKNOWLEDGEMENTS: (for this release)
+
+- Georg Fuchs for various changes.
+- Juan David Palomar for pointing out getnstr() was not implemented.
+- William McBrine for fix to allow black/black as valid color pair.
+- Peter Preus for pointing out the missing bccos2.mak file.
+- Laura Michaels for a couple of bug fixes and changes required to
+  support Mingw32 compiler.
+- Frank Heckenbach for PDC_get_input_fd() and some portability fixes and
+  the fixes for panel library.
+- Matthias Burian for the lcc-win32 compiler support.
+
+------------------------------------------------------------------------
+
+PDCurses 2.3 - 1998-07-09
+=========================
+
+INTRODUCTION:
+
+This release of PDCurses includes the following changes:
+
+- added more System V R4 functions
+
+- added Win32 port
+
+- the X11 port is now fully functional
+
+- the MS Visual C++ Win32 port now includes a DLL
+
+- both the X11 and Win32 ports support the mouse
+
+- the slk..() functions are now functional
+
+- support for scrollbars under X11 are experimental at this stage
+
+- long chtype extended to non-Unix ports
+
+The name of the statically built library is pdcurses.lib (or
+pdcurses.a). The name of the DLL import library (where applicable) is
+curses.lib.
+
+BUGS FIXED:
+
+- some minor bugs were corrected in this release
+
+NEW FUNCTIONS:
+
+- slk..() functions
+
+NEW COMPILER SUPPORT:
+
+- MS Visual C++ under Win95/NT
+
+- Watcom C++ under OS/2, Win32 and DOS
+
+- two EMX ports have been provided:
+  - OS/2 only using OS/2 APIs
+  - OS/2 and DOS using EMX video support routines
+
+EXTRA OPTIONS:
+
+PDCurses recognizes two environment variables which determines the
+initialization and finalization behavior.  These environment variables
+do not apply to the X11 port.
+
+PDC_PRESERVE_SCREEN -
+If this environment variable is set, PDCurses will not clear the screen
+to the default white on black on startup.  This allows you to overlay
+a window over the top of the existing screen background.
+
+PDC_RESTORE_SCREEN -
+If this environment variable is set, PDCurses will take a copy of the
+contents of the screen at the time that PDCurses is started; initscr(),
+and when endwin() is called, the screen will be restored.
+
+
+ACKNOWLEDGEMENTS: (for this release)
+
+- Chris Szurgot for original Win32 port.
+- Gurusamy Sarathy for some updates to the Win32 port.
+- Kim Huron for the slk..() functions.
+- Florian Grosse Coosmann for some bug fixes.
+- Esa Peuha for reducing compiler warnings.
+- Augustin Martin Domingo for patches to X11 port to enable accented
+  characters.
+
+------------------------------------------------------------------------
+
+PDCurses 2.2 - 1995-02-12
+=========================
+
+INTRODUCTION:
+
+ This release of PDCurses has includes a number of major changes:
+
+- The portable library functions are now grouped together into single
+  files with the same arrangement as System V R4 curses.
+
+- A panels library has been included. This panels library was written by
+  Warren Tucker.
+
+- Quite a few more functions have been supplied by Wade Schauer and
+  incorporated into release 2.2. Wade also supplied the support for the
+  Microway NDP C/C++ 32 bit DOS compiler.
+
+- The curses datatype has been changed from an unsigned int to a long.
+  This allows more attributes to be stored as well as increasing the
+  number of color-pairs from 32 to 64.
+
+- Xwindows port (experimental at the moment).
+
+BUGS FIXED:
+
+- mvwin() checked the wrong coordinates
+
+- removed DESQview shadow memory buffer checking bug in curses.h in
+  \#define for wstandout()
+
+- lots of others I can't remember
+
+NEW FUNCTIONS:
+
+- Too many to mention. See intro.man for a complete list of the
+  functions PDCurses now supports.
+
+COMPILER SUPPORT:
+
+- DJGPP 1.12 is now supported. The run-time error that caused programs
+  to crash has been removed.
+
+- emx 0.9a is supported. A program compiled for OS/2 should also work
+  under DOS if you use the VID=EMX switch when compiling. See the
+  makefile for details.
+
+- The Microway NDP C/C++ DOS compiler is now supported. Thanks to Wade
+  Schauer for this port.
+
+- The Watcom C++ 10.0 DOS compiler is now supported. Thanks to Pieter
+  Kunst for this port.
+
+- The library now has many functions grouped together to reduce the size
+  of the library and to improve the speed of compilation.
+
+- The "names" of a couple of the compilers in the makefile has changed;
+  CSET2 is now ICC and GO32 is now GCC.
+
+EXTRA OPTIONS:
+
+ One difference between the behavior of PDCurses and Unix curses is the
+ attributes that are displayed when a character is cleared. Under Unix
+ curses, no attributes are displayed, so the result is always black.
+ Under PDCurses, these functions clear with the current attributes in
+ effect at the time. With the introduction of the bkgd functions, by
+ default, PDCurses clears using the value set by (w)bkgd(). To have
+ PDCurses behave the same way as it did before release 2.2, compile with
+ -DPDCURSES_WCLR
+
+ACKNOWLEDGEMENTS: (for this release)
+
+ Pieter Kunst, David Nugent, Warren Tucker, Darin Haugen, Stefan Strack,
+ Wade Schauer and others who either alerted me to bugs or supplied
+ fixes.
+
+------------------------------------------------------------------------
+
+PDCurses 2.1 - 1993-06-20
+=========================
+
+INTRODUCTION:
+
+ The current code contains bug fixes for the DOS and OS/2 releases and
+ also includes an alpha release for Unix. The Unix release uses another
+ public domain package (mytinfo) to handle the low-level screen writes.
+ mytinfo was posted to comp.sources.unix (or misc) in December 1992 or
+ January 1993. Unless you are a glutton for punishment I would recommend
+ you avoid the Unix port at this stage.
+
+ The other major addition to PDCurses is the support for DJGPP (the DOS
+ port of GNU C++). Thanks to David Nugent <davidn@csource.oz.au>.
+
+ Other additions are copywin() function, function debugging support and
+ getting the small and medium memory models to work. The testcurs.c demo
+ program has also been changed significantly and a new demo program,
+ tuidemo, has been added.
+
+ Some people have suggested including information on where to get dmake
+ from. oak.oakland.edu in /pub/msdos/c
+
+OTHER NOTES:
+
+ Under DOS, by default, screen writes to a CGA monitor are done via the
+ video BIOS rather than by direct video memory writes. This is due to
+ the CGA "snow" problem. If you have a CGA monitor and do not suffer
+ from snow, you can compile private\_queryad.c with CGA_DIRECT defined.
+ This will then use cause PDCurses to write directly to the CGA video
+ memory.
+
+ Function debugging: Firstly to get function debugging, you have to
+ compile the library with OPT=N in the makefile. This also turns on
+ compiler debugging. You can control when you want PDCurses to write to
+ the debug file (called trace in the current directory) by using the
+ functions traceon() and traceoff() in your program.
+
+ Microsoft C 6.00 Users note:
+ ----------------------------
+
+ With the addition of several new functions, using dmake to compile
+ PDCurses now causes the compiler to run "out of heap space in pass 2".
+ Using the 6.00AX version (DOS-Extended) to compile PDCurses fixes this
+ problem; hence the -EM switch.
+
+ Functional changes
+ ------------------
+
+ Added OS/2 DLL support.
+
+ A few curses functions have been fixed to exhibit their correct
+ behavior and make them more functionally portable with System V
+ curses. The functions that have changed are overlay(), overwrite() and
+ typeahead.
+
+ overlay() and overwrite()
+
+ Both of theses functions in PDCurses 2.0 allowed for one window to be
+ effectively placed on top of another, and the characters in the first
+ window were overlaid or overwritten starting at 0,0 in both windows.
+ This behavior of these functions was not correct. These functions only
+ operate on windows that physically overlap with respect to the
+ displayed screen. To achieve the same functionality as before, use the
+ new function copywin(). See the manual page for further details.
+
+ typeahead()
+
+ This function in PDCurses 2.0 effectively checked to see if there were
+ any characters remaining in the keyboard buffer. This is not the
+ behavior exhibited by System V curses. This function is intended
+ purely to set a flag so that curses can check while updating the
+ physical screen if any keyboard input is pending. To achieve the same
+ effect with typeahead() under PDCurses 2.1 the following code should be
+ used.
+
+ In place of...
+
+       while(!typeahead(stdin))
+        {
+          /* do something until any key is pressed... */
+        }
+
+ use...
+
+       /* getch() to return ERR if no key pending */
+       nodelay(stdscr,TRUE);
+       while(getch() == (ERR))
+        {
+          /* do something until any key is pressed... */
+        }
+
+
+ACKNOWLEDGEMENTS: (in no particular order)
+
+ Jason Shumate, Pieter Kunst, David Nugent, Andreas Otte, Pasi
+ Hamalainen, James McLennan, Duane Paulson, Ib Hojme
+
+ Apologies to anyone I may have left out.
+
+------------------------------------------------------------------------
+
+PDCurses 2.0 - 1992-11-23
+=========================
+
+INTRODUCTION:
+
+ Well, here it finally is; PDCurses v2.0.
+
+ PDCurses v2.0 is an almost total rewrite of PCcurses 1.4 done by John
+ 'Frotz' Fa'atuai, the previous maintainer. It adds support for OS/2 as
+ well as DOS.
+
+ This version has been tested with Microsoft C v6.0, QuickC v2.0 and
+ Borland C++ 2.0 under DOS and Microsoft C v6.0 and TopSpeed c v3.02
+ under OS/2 2.0. Also the library has been compiled successfully with
+ emx 0.8e, C Set/2 and Watcom 9. Most testing was done with the large
+ memory model, where applicable. The large memory model is probably the
+ best model to use.
+
+ The amount of testing has not been as extensive as I would have liked,
+ but demands on releasing a product have outweighed the product's
+ quality. Nothing new with that !! Hopefully with wider circulation,
+ more bugs will be fixed more quickly.
+
+ I have included just 1 makefile which is suitable for dmake 3.8 for
+ both DOS and OS/2. The makefile does not rely on customization of the
+ dmake.ini file.
+
+ If you discover bugs, and especially if you have fixes, please let me
+ know ASAP.
+
+ The source to the library is distributed as a zip file made with zip
+ 1.9. You will need Info-ZIP unzip 5.0 to unzip. Follow the directions
+ below to compile the library.
+
+DIRECTIONS:
+
+ 1. Create a new directory in which to unzip pdcurs20.zip. This will
+    create a curses directory and a number of subdirectories containing
+    source code for the library and utilities and the documentation.
+
+ 2. Make changes to the makefile where necessary:
+    Change the MODEL or model macro to the appropriate value (if it
+    applies to your compiler). Use model for Borland compilers.
+
+    Change any paths in the defined macros to be suitable for your
+    compiler.
+
+ 3. Invoke DMAKE [-e environment_options] [target]
+
+    where environment_options are:
+
+        OS (host operating system)
+        COMP (compiler)
+        OPT (optimized version or debug version) - optional. default Y
+        TOS (target operating system) - optional. default OS
+
+    see the makefile for valid combinations
+
+    targets: all, demos, lcursesd.lib, manual...
+
+    NB. dmake is case sensitive with targets, so those environments that
+    use an upper case model value (eg MSC) MUST specify the library
+    target as for eg. Lcursesd.lib
+
+    The makefile is by default set up for Borland C++. The use of -e
+    environment_options override these defaults. If you prefer, you can
+    just change the defaults in the makefile and invoke it without the
+    -e switch.
+
+OTHER NOTES:
+
+ The documentation for the library is built into each source file, a
+ couple of specific doc files and the header files. A program is
+ supplied (manext) to build the manual. This program gets compiled when
+ you build the documentation.
+
+ To generate the library response file correctly, I had to write a quick
+ and dirty program (buildlrf) to achieve this. Originally the makefiles
+ just had statements like: "echo -+$(OBJ)\$* & >> $(LRF)" which appended
+ a suitable line to the response file. Unfortunately under some
+ combinations of makefiles and command processors (eg. nmake and 4DOS)
+ the & would get treated as stderr and the echo command would fail.
+
+ The original source for PDCurses that I received from the previous
+ maintainer contained support for the FLEXOS operating system. Not
+ having access to it, I could not test the changes I made so its support
+ has fallen by the wayside. If you really need to have PDCurses running
+ under FLEXOS, contact me and I will see what can be arranged.
+
+ Under DOS, by default, screen writes to a CGA monitor are done via the
+ video BIOS rather than by direct video memory writes. This is due to
+ the CGA "snow" problem. If you have a CGA monitor and do not suffer
+ from snow, you can compile private\_queryad.c with CGA_DIRECT defined.
+ This will then use cause PDCurses to write directly to the CGA video
+ memory.
+
+ Added System V color support.
+
+COMPILER-SPECIFIC NOTES:
+
+ Microsoft C
+ -----------
+
+ It is possible with MSC 6.0 to build the OS/2 libraries and demo
+ programs from within DOS. This is the only case where it is possible to
+ specify the value of TOS on the command line to be OS2 and the value of
+ OS be DOS.
+
+ C Set/2
+ -------
+
+ I have only tested the library using the migration libraries. I doubt
+ that the demo programs will work without them.
+
+ emx
+ ---
+
+ Testing has been done with 0.8e of emx together with the 16_to_32
+ libraries. The emx\lib directory should include the vio32.lib and
+ kbd32.lib libraries from the 16_to_32 package.
+
+BUGS and UNFINISHED BUSINESS:
+
+- PDC_set_ctrl_break() function does not work under OS/2.
+
+- win_print() and PDC_print() do not work under OS/2.
+
+- The file todo.man in the doc directory also lists those functions of
+  System V 3.2 curses not yet implemented. Any volunteers?
+
+ACKNOWLEDGEMENTS:
+
+- John 'Frotz' Fa'atuai, the previous maintainer for providing an
+  excellent base for further development.
+- John Burnell <johnb@kea.am.dsir.govt.nz>, for the OS/2 port.
+- John Steele, Jason (finally NOT a John) Shumate....
+  for various fixes and suggestions.
+- Eberhardt Mattes (author of emx) for allowing code based on his
+  C library to be included with PDCurses.
+- Several others for their support, moral and actual.
+
+-- Mark Hessling
+
+------------------------------------------------------------------------
+
+PDCurses 2.0Beta - 1991-12-21
+=============================
+
+Changed back from short to int. (int is the correct size for the default
+platform. Short might be too short on some platforms. This is more
+portable. I, also, made this mistake.)
+
+Many functions are now macros.  If you want the real thing, #undef the
+macro. (X/Open requirement.)
+
+Merged many sources into current release.
+
+Added many X/Open routines (not quite all yet).
+
+Added internal documentation to all routines.
+
+Added a HISTORY file to the environment.
+
+Added a CONTRIB file to the environment.
+
+------------------------------------------------------------------------
+
+PDCurses 1.5Beta - 1990-07-14
+=============================
+
+Added many levels of compiler support. Added mixed prototypes for all
+"internal" routines. Removed all assembly language.  Added EGA/VGA
+support.  Converted all #ifdef to #if in all modules except CURSES.H and
+CURSPRIV.H. Always include ASSERT.H.  Added support for an external
+malloc(), calloc() and free(). Added support for FAST_VIDEO
+(direct-memory writes). Added various memory model support (for
+FAST_VIDEO). Added much of the December 1988 X/Open Curses
+specification.
+
+-- John 'Frotz' Fa'atuai
+
+------------------------------------------------------------------------
+
+PCcurses 1.4 - 1990-01-14
+=========================
+
+  In PCcurses v.1.4, both portability improvements and bugfixes have
+been made. The files have been changed to allow lint-free compilation
+with Microsoft C v.5.1, and with Turbo C v.2.0. The source should still
+compile without problems on older compilers, although this has not been
+verified.
+
+  The makefiles have been changed to suit both the public release and
+the author, who maintains a special kind of libraries for himself. In
+the case of Microsoft C, changes were done in the makefile to lower the
+warning level to 2 (was 3). This was to avoid ANSI warnings which are
+abundant because PCcurses does not attempt to follow strict ANSI C
+standard.
+
+  BUG FIXES FROM V.1.3 TO V.1.4:
+
+  !!!IMPORTANT CHANGE!!!
+
+  The definitions for OK and ERR in curses.h were exchanged. This was
+done to be more consistent with UNIX versions. Also, it permits
+functions like newwin() and subwin() to return 0 (=NULL) when they fail
+due to memory shortage. This incompatibility with UNIX curses was
+pointed out by Fred C. Smith. If you have tested success/failure by
+comparisons to anything other than ERR and OK, your applications will
+need to be be changed on that point. Sorry... but presumably most of you
+used the symbolic constants?
+
+  (END OF IMPORTANT CHANGE)
+
+  Fred also pointed out a bug in the file update.c. The bug caused the
+first character printed after 'unauthorized' screen changes (like during
+a shell escape, for example) to be placed at the wrong screen position.
+This happened even if the normal precautions (clear / touch / refresh)
+were taken. The problem has now been fixed.
+
+  PCcurses is currently also being used on a 68000 system with
+hard-coded ESCape sequences for ANSI terminals. However, ints used by
+the 68000 C compiler are 32 bits. Therefore ints have been turned into
+shorts wherever possible in the code (otherwise all window structures
+occupy twice as much space as required on the 68000). This does not
+affect PC versions since normally both ints and shorts are 16 bits for
+PC C compilers.
+
+  At some places in the source code there are references made to the
+68000 version. There are also a makefile, a curses68.c file, and a
+curses68.cmd file. These are for making, low-level I/O, and linking
+commands when building the 68000 version. These files are probably
+useful to no-one but the author, since it is very specific for its
+special hardware environment. Still in an effort to keep all
+curses-related sources in one place they are included. Note however that
+PCcurses will not officially support a non-PC environment.
+
+  The file cursesio.c, which was included in the package at revision
+level 1.2, and which was to be an alternative to the cursesio.asm file,
+has been verified to behave incorrectly in the function _curseskeytst().
+The problem was that the value of 'cflag' does not contain the proper
+data for the test that is attempted. Furthermore, neither Turbo C or
+Microsoft C allows any way to return the data that is needed, and
+consequently you should not use cursesio.c. The best solution is to
+simply use the ASM version. In v.1.2 and v.1.3, the user could edit the
+makefile to select which version he wanted to use. The makefiles in
+v.1.4 have removed this possibility forcing the use of the ASM file, and
+cursesio.c has been dropped from the distribution.
+
+  A bug in the wgetstr() function caused PCcurses to echo characters
+when reading a keyboard string, even if the echo had been turned off.
+Thanks to Per Foreby at Lund University, Sweden, for this. Per also
+reported bugs concerning the handling of characters with bit 8 set.
+Their ASCII code were considered as lower than 32, so they were erased
+etc. like control characters, i.e. erasing two character positions. The
+control character test was changed to cope with this.
+
+  The overlay() and overwrite() functions were changed so that the
+overlaying window is positioned at its 'own' coordinates inside the
+underlying window (it used to be at the underlying window's [0,0]
+position). There is some controversy about this - the documentation for
+different curses versions say different things. I think the choice made
+is the most reasonable.
+
+  The border() and wborder() functions were changed to actually draw a
+border, since this seems to be the correct behavior of these functions.
+They used to just set the border characters to be used by box(). These
+functions are not present in standard BSD UNIX curses.
+
+  The subwin() function previously did not allow the subwindow to be as
+big as the original window in which it was created. This has now been
+fixed. There was also the problem that the default size (set by
+specifying numlines or numcols (or both) as 0 made the resulting actual
+size 1 line/column too small.
+
+  There were a few spelling errors in function names, both in the
+function declarations and in curses.h. This was reported by Carlos
+Amaral at INESC in Portugal. Thanks! There was also an unnecessary (but
+harmless) parameter in a function call at one place.
+
+------------------------------------------------------------------------
+
+PCcurses 1.3 - 1988-10-05
+=========================
+
+  The file 'border.c' is now included. It allows you to explicitly
+specify what characters should be used as box borders when the box()
+functions are called. If the new border characters are non-0, they
+override the border characters specified in the box() call. In my
+understanding, this functionality is required for AT&T UNIX sV.3
+compatibility. Thanks for this goes to Tony L. Hansen
+(hansen@pegasus.UUCP) for posting an article about it on Usenet
+(newsgroup comp.unix.questions; his posting was not related at all to
+PCcurses).
+
+  The only other difference between v.1.2 and v.1.3 is that the latter
+has been changed to avoid warning diagnostics if the source files are
+compiled with warning switches on (for Microsoft this means '-W3', for
+Turbo C it means '-w -w-pro'). Of these, the Turbo C warning check is
+clearly to be used rather than Microsoft, even if neither of them comes
+even close to a real UNIX 'lint'. Some of the warnings in fact indicated
+real bugs, mostly functions that did not return correct return values or
+types.
+
+  The makefiles for both MSC and TRC have been modified to produce
+warning messages as part of normal compilation.
+
+------------------------------------------------------------------------
+
+PCcurses 1.2 - 1988-10-02
+=========================
+
+  The changes from v.1.1 to v.1.2 are minor. The biggest change is that
+there was a bug related to limiting the cursor movement if the
+application tried to move it outside the screen (something that should
+not be done anyway). Such erroneous application behavior is now handled
+appropriately.
+
+  All modules have been changed to have a revision string in them, which
+makes it easier to determine what version is linked into a program (or
+what library version you have).
+
+  There is now a 'cursesio.c' file. That file does the same as
+'cursesio.asm' (i.e. it provides the interface to the lower-level system
+I/O routines). It is written in C and thus it is (possibly) more
+portable than the assembler version (but still not so portable since it
+uses 8086 INT XX calls directly). When one creates new curses libraries,
+one chooses whether to use the assembler or the C version of cursesio.
+The choice is made by commenting out the appropriate dependencies for
+cursesio.obj, near the end of the makefiles.
+
+  There is now a 'setmode.c' file. That file contains functions that
+save and restore terminal modes. They do it into other variables than do
+savetty() and resetty(), so one should probably use either
+savetty()/resetty() or the new functions only - and not mix the both
+ways unless one really knows what one does.
+
+  Diff lists vs v.1.0 are no longer included in the distribution. The
+make utility still is. PCcurses v.1.2 still compiles with Microsoft C
+v.4.0, and with Borland Turbo C v.1.0. There is as far as I know no
+reason to believe that it does not compile under Microsoft C v.3.0 and
+5.x, or Turbo C v.1.5, but this has not been tested.
+
+  There are two makefiles included, one for Microsoft C, one for Turbo
+C. They are both copies of my personal makefiles, and as such they
+reflect the directory structure on my own computer. This will have to be
+changed before you run make. Check $(INCDIR) and $(LIBDIR) in
+particular, and make the choice of ASM or C cursesio version as
+mentioned above (the distribution version uses the C version of
+cursesio).
+
+  The manual file (curses.man) has been changed at appropriate places.
+
+  I would like to thank the following persons for their help:
+
+       Brandon S. Allbery (alberry@ncoast.UUCP)
+               for running comp.binaries.ibm.pc (at that time)
+               and comp.source.misc.
+
+       Steve Balogh (Steve@cit5.cit.oz.AU)
+               for writing a set of manual pages and posting
+               them to the net.
+
+       Torbjorn Lindh
+               for finding bugs and suggesting raw
+               character output routines.
+
+       Nathan Glasser (nathan@eddie.mit.edu)
+               for finding and reporting bugs.
+
+       Ingvar Olafsson (...enea!hafro!ingvar)
+               for finding and reporting bugs.
+
+       Eric Rosco (...enea!ipmoea!ericr)
+               for finding and reporting bugs.
+
+       Steve Creps (creps@silver.bacs.indiana.edu)
+               for doing a lot of work - among others
+               posting bug fixes to the net, and writing
+               the new cursesio.c module.
+
+       N. Dean Pentcheff (dean@violet.berkeley.edu)
+               for finding bugs and rewriting cursesio.asm
+               for Turbo 'C' 1.5.
+
+  Finally, Jeff Dean (parcvax,hplabs}!cdp!jeff)
+                    (jeff@ads.arpa)
+       has had a shareware version of curses deliverable since
+       about half a year before I released PCcurses 1.0 on Use-
+       Net. He is very concerned about confusion between the two
+       packages, and therefore any references on the network
+       should make clear whether they reference Dean's PCcurses
+       or Larsson's PCcurses.
+
+------------------------------------------------------------------------
+
+PCcurses 1.1 - 1988-03-06
+=========================
+
+  The changes from v.1.0 to v.1.1 are minor. There are a few bug fixes,
+and new (non-portable) functions for verbatim IBM character font display
+have been added (in charadd.c and charins.c). The manual file
+(curses.man) has been changed at appropriate places.
+
+  In the file v10tov11.dif there are listings of the differences between
+version 1.0 and 1.1. The diff listings are in UNIX diff(1) format.
+
+  Version 1.1 compiles with Turbo C v.1.0, as well as Microsoft C v.3.0
+and v.4.0. On the release disk there is a make.exe utility which is very
+similar to UNIX make (If the package was mailed to you, the make utility
+will be in uuencoded format - in make.uu - and must be uudecoded first).
+It is much more powerful than Microsoft's different MAKEs; the latter
+ones will NOT generate libraries properly if used with the PCcurses
+makefiles.
+
+  There are three makefiles:
+
+       makefile      generic MSC 3.0 makefile
+       makefile.ms      MSC 4.0 makefile
+       makefile.tc      Turbo C 1.0 makefile
+
+  To make a library with for example Turbo C, make directories to hold
+.H and .LIB files (these directories are the 'standard places'), edit
+makefile.tc for this, and type
+
+       make -f makefile.tc all
+
+and libraries for all memory models will be created in the .LIB
+directory, while the include files will end up in the .H directory. Also
+read what is said about installation below!
+
+------------------------------------------------------------------------
+
+PCcurses 1.0 - 1987-08-24
+=========================
+
+  This is the release notes for the PCcurses v.1.0 cursor/window control
+package. PCcurses offers the functionality of UNIX curses, plus some
+extras. Normally it should be possible to port curses-based programs
+from UNIX curses to PCcurses on the IBM PC without changes. PCcurses is
+a port/ rewrite of Pavel Curtis' public domain 'ncurses' package. All
+the code has been re-written - it is not just an edit of ncurses (or
+UNIX curses). I mention this to clarify any copyright violation claims.
+The data structures and ideas are very similar to ncurses. As for UNIX
+curses, I have not even seen any sources for it.
+
+  For an introduction to the use of 'curses' and its derivatives, you
+should read 'Screen Updating and Cursor Movement Optimization: A Library
+Package' by Kenneth C. R. C. Arnold, which describes the original
+Berkeley UNIX version of curses. It is available as part of the UNIX
+manuals. The other source of information is 'The Ncurses Reference
+Manual' by Pavel Curtis. The latter is part of Curtis' ncurses package.
+
+  The only other documentation provided is a 'man' page which describes
+all the included functions in a very terse way. In the sources, each
+function is preceded by a rather thorough description of what the
+function does. I didn't have time to write a nice manual/tutorial -
+sorry.
+
+  PCcurses is released as a number of source files, a man page, and a
+make file. A uuencoded copy of a 'make' utility, and a manpage for the
+'make' is also provided to make it easier to put together PCcurses
+libraries. Even if you are not interested in PCcurses, it may be
+worthwhile to grab the make.
+
+  The makefile assumes the presence of the Microsoft C compiler (3.0 or
+4.0), Microsoft MASM and LIB, plus some MS-DOS utilities. The reason for
+supplying MAKE.EXE is that the Microsoft 'MAKE:s' are much inferior to a
+real UNIX make. The supplied make is a port of a public domain make,
+published on Usenet. It is almost completely compatible with UNIX make.
+When generating the curses libraries, the makefile will direct make to
+do some directory creating and file copying, and then re-invoke itself
+with new targets. The workings of the makefile are not absolutely
+crystal clear at first sight... just start it and see what it does.
+
+  For portability, the curses libraries depend on one assembler file for
+access to the BIOS routines. There is no support for the EGA, but both
+CGA, MGA, and the HGA can be used. The libraries are originally for
+Microsoft C, but all C modules should be portable right away. In the
+assembler file, segment names probably need to be changed, and possibly
+the parameter passing scheme. I think Turbo C will work right away - as
+far as I understand, all its conventions are compatible with Microsoft
+C.
+
+  There are some parts left out between ncurses and PCcurses. One is the
+support for multiple terminals - not very interesting on a PC anyway.
+Because we KNOW what terminal we have, there is no need for a termcap or
+terminfo library. PCcurses also has some things that neither curses nor
+ncurses have. Compared to the original UNIX curses, PCcurses has lots of
+extras.
+
+  The BIOS routines are used directly, which gives fast screen updates.
+PCcurses does not do direct writes to screen RAM - in my opinion it is
+a bit ugly to rely that much on hardware compatibility. Anyone could fix
+that, of course...
+
+  One of the more serious problems with PCcurses is the way in which
+normal, cbreak, and raw input modes are done. All those details are in
+the 'charget' module - I do raw I/O via the BIOS, and perform any
+buffering myself. If an application program uses PCcurses, it should do
+ALL its I/O via PCcurses calls, otherwise the mix of normal and
+PCcurses I/O may mess up the display. I think my code is reasonable...
+comments are welcome, provided you express them nicely...
+
+  To install, copy all files to a work directory, edit 'makefile' to
+define the standard include and library file directory names of your
+choice (these directories must exist already, and their path names must
+be relative to the root directory, not to the current one). You must
+also run uudecode on make.uu, to generate MAKE.EXE. You can do that on
+your PC, if you have uudecode there, otherwise you can do it under UNIX
+and do a binary transfer to the PC. When you have MAKE.EXE in your work
+directory (or in your /bin directory), type make.
+
+  Make will now create 4 sub-directories (one for each memory model),
+copy some assembler include files into them, copy two include files to
+your include directory, CHDIR to each sub-directory and re-invoke itself
+with other make targets to compile and assemble all the source files
+into the appropriate directories. Then the library manager is run to
+create the library files in your desired library directory. Presto!
+
+  If you only want to generate a library for one memory model, type
+'make small', 'make large', etc. The name of the memory model must be in
+lower case, like in the makefile.
+
+  I think the package is fairly well debugged - but then again, that's
+what I always think. It was completed in May-87, and no problems found
+yet. Now it's your turn... Comments, suggestions and bug reports and
+fixes (no flames please) to
+
+-- Bjorn Larsson
diff --git a/lib/PDCursesMod/docs/IMPLEMNT.md b/lib/PDCursesMod/docs/IMPLEMNT.md
new file mode 100644
index 00000000000..9b3dd8f2287
--- /dev/null
+++ b/lib/PDCursesMod/docs/IMPLEMNT.md
@@ -0,0 +1,323 @@
+PDCurses Implementor's Guide
+============================
+
+- Version 1.6 - 2019/09/?? - added PDC_doupdate(); removed argc, argv,
+                             lines, cols and SP allocation from
+                             PDC_scr_open(); removed PDC_init_pair(),
+                             PDC_pair_content()
+- Version 1.5 - 2019/09/06 - PDC_has_mouse(), removed PDC_get_input_fd()
+- Version 1.4 - 2018/12/31 - PDCurses.md -> USERS.md, MANUAL.md; new dir
+- Version 1.3 - 2018/01/12 - notes about official ports, new indentation
+                             style; markdown
+- Version 1.2 - 2007/07/11 - added PDC_init_pair(), PDC_pair_content(),
+                             version history; removed pdc_atrtab
+- Version 1.1 - 2007/06/06 - minor cosmetic change
+- Version 1.0 - 2007/04/01 - initial revision
+
+This document is for those wishing to port PDCurses to a new platform,
+or just wanting to better understand how it works. Nothing here should
+be needed for application programming; for that, refer to [USERS.md] and
+[MANUAL.md], in man/ . This document assumes that you've read the user-
+level documentation and are very familiar with application-level curses
+programming.
+
+If you want to submit your port for possible inclusion into the main
+PDCurses distribution, please follow these guidelines:
+
+ - Don't modify anything in the pdcurses directory or in other port
+   directories. Don't modify curses.h or curspriv.h unless absolutely
+   necessary. (And prefer modifying curspriv.h over curses.h.)
+
+ - Use the same indentation style, naming and scope conventions as the
+   existing code.
+
+ - Release all your code to the public domain -- no copyright. Code
+   under GPL, BSD, etc. will not be accepted.
+
+
+Data Structures
+===============
+
+A port of PDCurses must provide acs_map[], a 128-element array of
+chtypes, with values laid out based on the Alternate Character Set of
+the VT100 (see curses.h). PDC_transform_line() must use this table; when
+it encounters a chtype with the A_ALTCHARSET flag set, and an A_CHARTEXT
+value in the range 0-127, it must render it using the A_CHARTEXT portion
+of the corresponding value from this table, instead of the original
+value. Also, values may be read from this table by apps, and passed
+through functions such as waddch(), which does no special processing on
+control characters (0-31 and 127) when the A_ALTCHARSET flag is set.
+Thus, any control characters used in acs_map[] should also have the
+A_ALTCHARSET flag set. Implementations should provide suitable values
+for all the ACS_ macros defined in curses.h; other values in the table
+should be filled with their own indices (e.g., acs_map['E'] == 'E'). The
+table can be either hardwired, or filled by PDC_scr_open(). Existing
+ports define it in pdcdisp.c, but this is not required.
+
+
+Functions
+=========
+
+A port of PDCurses must implement the following functions, with extern
+scope. These functions are traditionally divided into several modules,
+as indicated below; this division is not required (only the functions
+are), but may make it easier to follow for someone familiar with the
+existing ports.
+
+Any other functions you create as part of your implementation should
+have static scope, if possible. If they can't be static, they should be
+named with the "PDC_" prefix. This minimizes the risk of collision with
+an application's choices.
+
+Current PDCurses style also uses a single leading underscore with the
+name of any static function; and modified BSD/Allman-style indentation,
+approximately equivalent to "indent -kr -nut -bl -bli0", with
+adjustments to keep every line under 80 columns.
+
+
+pdcdisp.c:
+----------
+
+### void PDC_doupdate(void);
+
+Called at the end of doupdate(), this function finalizes the update of
+the physical screen to match the virtual screen, if necessary, i.e. if
+updates were deferred in PDC_transform_line().
+
+### void PDC_gotoyx(int y, int x);
+
+Move the physical cursor (as opposed to the logical cursor affected by
+wmove()) to the given location. This is called mainly from doupdate().
+In general, this function need not compare the old location with the new
+one, and should just move the cursor unconditionally.
+
+### void PDC_transform_line(int lineno, int x, int len, const chtype *srcp);
+
+The core output routine. It takes len chtype entities from srcp (a
+pointer into curscr) and renders them to the physical screen at line
+lineno, column x. It must also translate characters 0-127 via acs_map[],
+if they're flagged with A_ALTCHARSET in the attribute portion of the
+chtype. Actual screen updates may be deferred until PDC_doupdate() if
+desired (currently done with SDL and X11).
+
+
+pdcgetsc.c:
+-----------
+
+### int PDC_get_columns(void);
+
+Returns the size of the screen in columns. It's used in initscr() and
+resize_term() to set the value of COLS.
+
+### int PDC_get_cursor_mode(void);
+
+Returns the size/shape of the cursor. The format of the result is
+unspecified, except that it must be returned as an int. This function is
+called from initscr(), and the result is stored in SP->orig_cursor,
+which is used by PDC_curs_set() to determine the size/shape of the
+cursor in normal visibility mode (curs_set(1)).
+
+### int PDC_get_rows(void);
+
+Returns the size of the screen in rows. It's used in initscr() and
+resize_term() to set the value of LINES.
+
+
+pdckbd.c:
+---------
+
+### bool PDC_check_key(void);
+
+Keyboard/mouse event check, called from wgetch(). Returns TRUE if
+there's an event ready to process. This function must be non-blocking.
+
+### void PDC_flushinp(void);
+
+This is the core of flushinp(). It discards any pending key or mouse
+events, removing them from any internal queue and from the OS queue, if
+applicable.
+
+### int PDC_get_key(void);
+
+Get the next available key, or mouse event (indicated by a return of
+KEY_MOUSE), and remove it from the OS' input queue, if applicable. This
+function is called from wgetch(). This function may be blocking, and
+traditionally is; but it need not be. If a valid key or mouse event
+cannot be returned, for any reason, this function returns -1. Valid keys
+are those that fall within the appropriate character set, or are in the
+list of special keys found in curses.h (KEY_MIN through KEY_MAX). When
+returning a special key code, this routine must also set SP->key_code to
+TRUE; otherwise it must set it to FALSE. If SP->return_key_modifiers is
+TRUE, this function may return modifier keys (shift, control, alt),
+pressed alone, as special key codes; if SP->return_key_modifiers is
+FALSE, it must not. If modifier keys are returned, it should only happen
+if no other keys were pressed in the meantime; i.e., the return should
+happen on key up. But if this is not possible, it may return the
+modifier keys on key down (if and only if SP->return_key_modifiers is
+TRUE).
+
+### bool PDC_has_mouse(void);
+
+Called from has_mouse(). Reports whether mouse support is available. Can
+be a static TRUE or FALSE, or dependent on conditions. Note: Activating
+mouse support should depend only on PDC_mouse_set(); don't expect the
+user to call has_mouse() first.
+
+### int PDC_modifiers_set(void);
+
+Called from PDC_return_key_modifiers(). If your platform needs to do
+anything in response to a change in SP->return_key_modifiers, do it
+here. Returns OK or ERR, which is passed on by the caller.
+
+### int PDC_mouse_set(void);
+
+Called by mouse_set(), mouse_on(), and mouse_off() -- all the functions
+that modify SP->_trap_mbe. If your platform needs to do anything in
+response to a change in SP->_trap_mbe (for example, turning the mouse
+cursor on or off), do it here. Returns OK or ERR, which is passed on by
+the caller.
+
+### void PDC_set_keyboard_binary(bool on);
+
+Set keyboard input to "binary" mode. If you need to do something to keep
+the OS from processing ^C, etc. on your platform, do it here. TRUE turns
+the mode on; FALSE reverts it. This function is called from raw() and
+noraw().
+
+
+pdcscrn.c:
+----------
+
+### bool PDC_can_change_color(void);
+
+Returns TRUE if init_color() and color_content() give meaningful
+results, FALSE otherwise. Called from can_change_color().
+
+### int PDC_color_content(short color, short *red, short *green, short *blue);
+
+The core of color_content(). This does all the work of that function,
+except checking for values out of range and null pointers.
+
+### int PDC_init_color(short color, short red, short green, short blue);
+
+The core of init_color(). This does all the work of that function,
+except checking for values out of range.
+
+### void PDC_reset_prog_mode(void);
+
+The non-portable functionality of reset_prog_mode() is handled here --
+whatever's not done in _restore_mode(). In current ports: In OS/2, this
+sets the keyboard to binary mode; in Windows console, it enables or
+disables the mouse pointer to match the saved mode; in others it does
+nothing.
+
+### void PDC_reset_shell_mode(void);
+
+The same thing, for reset_shell_mode(). In OS/2 and Windows console, it
+restores the default console mode; in others it does nothing.
+
+### int PDC_resize_screen(int nlines, int ncols);
+
+This does the main work of resize_term(). It may respond to non-zero
+parameters, by setting the screen to the specified size; to zero
+parameters, by setting the screen to a size chosen by the user at
+runtime, in an unspecified way (e.g., by dragging the edges of the
+window); or both. It may also do nothing, if there's no appropriate
+action for the platform.
+
+### void PDC_restore_screen_mode(int i);
+
+Called from _restore_mode() in kernel.c, this function does the actual
+mode changing, if applicable. Currently used only in DOS and OS/2.
+
+### void PDC_save_screen_mode(int i);
+
+Called from _save_mode() in kernel.c, this function saves the actual
+screen mode, if applicable. Currently used only in DOS and OS/2.
+
+### void PDC_scr_close(void);
+
+The platform-specific part of endwin(). It may restore the image of the
+original screen saved by PDC_scr_open(), if the PDC_RESTORE_SCREEN
+environment variable is set; either way, if using an existing terminal,
+this function should restore it to the mode it had at startup, and move
+the cursor to the lower left corner. (The X11 port does nothing.)
+
+### void PDC_scr_free(void);
+
+Free any memory allocated by PDC_scr_open(). Called by delscreen().
+
+### int PDC_scr_open(void);
+
+The platform-specific part of initscr(). It must initialize acs_map[]
+(unless it's preset) and several members of SP, including mouse_wait,
+orig_attr (and if orig_attr is TRUE, orig_fore and orig_back), mono,
+_restore and _preserve. If using an existing terminal, and the
+environment variable PDC_RESTORE_SCREEN is set, this function may also
+store the existing screen image for later restoration by
+PDC_scr_close().
+
+
+pdcsetsc.c:
+-----------
+
+### int PDC_curs_set(int visibility);
+
+Called from curs_set(). Changes the appearance of the cursor -- 0 turns
+it off, 1 is normal (the terminal's default, if applicable, as
+determined by SP->orig_cursor), and 2 is high visibility. The exact
+appearance of these modes is not specified.
+
+
+pdcutil.c:
+----------
+
+### void PDC_beep(void);
+
+Emits a short audible beep. If this is not possible on your platform,
+you must set SP->audible to FALSE during initialization (i.e., from
+PDC_scr_open() -- not here); otherwise, set it to TRUE. This function is
+called from beep().
+
+### void PDC_napms(int ms);
+
+This is the core delay routine, called by napms(). It pauses for about
+(the X/Open spec says "at least") ms milliseconds, then returns. High
+degrees of accuracy and precision are not expected (though desirable, if
+you can achieve them). More important is that this function gives back
+the process' time slice to the OS, so that PDCurses idles at low CPU
+usage.
+
+### const char *PDC_sysname(void);
+
+Returns a short string describing the platform, such as "DOS" or "X11".
+This is used by longname(). It must be no more than 100 characters; it
+should be much, much shorter (existing platforms use no more than 5).
+
+
+More functions
+==============
+
+The following functions are implemented in the platform directories, but
+are accessed directly by apps. Refer to the user documentation for their
+descriptions:
+
+
+pdcclip.c:
+----------
+
+### int PDC_clearclipboard(void);
+### int PDC_freeclipboard(char *contents);
+### int PDC_getclipboard(char **contents, long *length);
+### int PDC_setclipboard(const char *contents, long length);
+
+
+pdcsetsc.c:
+-----------
+
+### int PDC_set_blink(bool blinkon);
+### int PDC_set_bold(bool boldon);
+### void PDC_set_title(const char *title);
+
+[USERS.md]: USERS.md
+[MANUAL.md]: MANUAL.md
diff --git a/lib/PDCursesMod/docs/MANUAL.md b/lib/PDCursesMod/docs/MANUAL.md
new file mode 100644
index 00000000000..348ac24e258
--- /dev/null
+++ b/lib/PDCursesMod/docs/MANUAL.md
@@ -0,0 +1,3054 @@
+Definitions and Variables (curses.h)
+====================================
+
+Define before inclusion (only those needed):
+
+    XCURSES         if building / built for X11
+    PDC_RGB         if you want to use RGB color definitions
+                    (Red = 1, Green = 2, Blue = 4) instead of BGR
+    PDC_WIDE        if building / built with wide-character support
+    PDC_DLL_BUILD   if building / built as a Windows DLL
+    PDC_NCMOUSE     to use the ncurses mouse API instead
+                    of PDCurses' traditional mouse API
+
+Defined by this header:
+
+    PDCURSES        PDCurses-only features are available
+    PDC_BUILD       API build version
+    PDC_VER_MAJOR   major version number
+    PDC_VER_MINOR   minor version number
+    PDC_VERDOT      version string
+
+
+
+--------------------------------------------------------------------------
+
+
+Text Attributes
+===============
+
+If CHTYPE_32 is #defined,  PDCurses uses a 32-bit integer for its chtype:
+
+    +--------------------------------------------------------------------+
+    |31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|..| 2| 1| 0|
+    +--------------------------------------------------------------------+
+          color pair        |     modifiers         |   character eg 'a'
+
+There are 256 color pairs (8 bits), 8 bits for modifiers, and 16 bits
+for character data. The modifiers are bold, underline, right-line,
+left-line, italic, reverse and blink, plus the alternate character set
+indicator.
+
+   By default,  a 64-bit chtype is used :
+
+-------------------------------------------------------------------------------
+|63|62|61|60|59|..|34|33|32|31|30|29|28|..|22|21|20|19|18|17|16|..| 3| 2| 1| 0|
+-------------------------------------------------------------------------------
+         color number   |        modifiers      |         character eg 'a'
+
+   We take five more bits for the character (thus allowing Unicode values
+past 64K;  the full range of Unicode goes up to 0x10ffff,  requiring 21 bits
+total),  and four more bits for attributes.  Three are currently used as
+A_OVERLINE, A_DIM, and A_STRIKEOUT;  one more is reserved for future use.
+On some platforms,  bits 33-40 are used to select a color pair (can run from
+0 to 255). Bits 41 and 42 have been added to this to get 1024 color pairs.
+On some platforms (as of 2020 May 17,  WinGUI and VT),  bits 33-52 are used,
+allowing 2^20 = 1048576 color pairs.  That should be enough for anybody, and
+leaves twelve bits for other uses.
+
+
+
+--------------------------------------------------------------------------
+
+Functions
+=========
+
+addch
+-----
+
+### Synopsis
+
+    int addch(const chtype ch);
+    int waddch(WINDOW *win, const chtype ch);
+    int mvaddch(int y, int x, const chtype ch);
+    int mvwaddch(WINDOW *win, int y, int x, const chtype ch);
+    int echochar(const chtype ch);
+    int wechochar(WINDOW *win, const chtype ch);
+
+    int addrawch(chtype ch);
+    int waddrawch(WINDOW *win, chtype ch);
+    int mvaddrawch(int y, int x, chtype ch);
+    int mvwaddrawch(WINDOW *win, int y, int x, chtype ch);
+
+    int add_wch(const cchar_t *wch);
+    int wadd_wch(WINDOW *win, const cchar_t *wch);
+    int mvadd_wch(int y, int x, const cchar_t *wch);
+    int mvwadd_wch(WINDOW *win, int y, int x, const cchar_t *wch);
+    int echo_wchar(const cchar_t *wch);
+    int wecho_wchar(WINDOW *win, const cchar_t *wch);
+
+### Description
+
+   addch() adds the chtype ch to the default window (stdscr) at the
+   current cursor position, and advances the cursor. Note that chtypes
+   can convey both text (a single character) and attributes, including a
+   color pair. add_wch() is the wide-character version of this function,
+   taking a pointer to a cchar_t instead of a chtype.
+
+   waddch() is like addch(), but also lets you specify the window. (This
+   is in fact the core output routine.) wadd_wch() is the wide version.
+
+   mvaddch() moves the cursor to the specified (y, x) position, and adds
+   ch to stdscr. mvadd_wch() is the wide version.
+
+   mvwaddch() moves the cursor to the specified position and adds ch to
+   the specified window. mvwadd_wch() is the wide version.
+
+   echochar() adds ch to stdscr at the current cursor position and calls
+   refresh(). echo_wchar() is the wide version.
+
+   wechochar() adds ch to the specified window and calls wrefresh().
+   wecho_wchar() is the wide version.
+
+   addrawch(), waddrawch(), mvaddrawch() and mvwaddrawch() are PDCurses-
+   specific wrappers for addch() etc. that disable the translation of
+   control characters.
+
+   The following applies to all these functions:
+
+   If the cursor moves on to the right margin, an automatic newline is
+   performed. If scrollok is enabled, and a character is added to the
+   bottom right corner of the window, the scrolling region will be
+   scrolled up one line. If scrolling is not allowed, ERR will be
+   returned.
+
+   If ch is a tab, newline, or backspace, the cursor will be moved
+   appropriately within the window. If ch is a newline, the clrtoeol
+   routine is called before the cursor is moved to the beginning of the
+   next line. If newline mapping is off, the cursor will be moved to
+   the next line, but the x coordinate will be unchanged. If ch is a
+   tab the cursor is moved to the next tab position within the window.
+   If ch is another control character, it will be drawn in the ^X
+   notation. Calling the inch() routine after adding a control
+   character returns the representation of the control character, not
+   the control character.
+
+   Video attributes can be combined with a character by ORing them into
+   the parameter. Text, including attributes, can be copied from one
+   place to another by using inch() and addch().
+
+   Note that in PDCurses, for now, a cchar_t and a chtype are the same.
+   The text field is 16 bits wide, and is treated as Unicode (UCS-2)
+   when PDCurses is built with wide-character support (define PDC_WIDE).
+   So, in functions that take a chtype, like addch(), both the wide and
+   narrow versions will handle Unicode. But for portability, you should
+   use the wide functions.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    addch                       Y       Y       Y
+    waddch                      Y       Y       Y
+    mvaddch                     Y       Y       Y
+    mvwaddch                    Y       Y       Y
+    echochar                    Y       Y       Y
+    wechochar                   Y       Y       Y
+    add_wch                     Y       Y       Y
+    wadd_wch                    Y       Y       Y
+    mvadd_wch                   Y       Y       Y
+    mvwadd_wch                  Y       Y       Y
+    echo_wchar                  Y       Y       Y
+    wecho_wchar                 Y       Y       Y
+    addrawch                    -       -       -
+    waddrawch                   -       -       -
+    mvaddrawch                  -       -       -
+    mvwaddrawch                 -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+addchstr
+--------
+
+### Synopsis
+
+    int addchstr(const chtype *ch);
+    int addchnstr(const chtype *ch, int n);
+    int waddchstr(WINDOW *win, const chtype *ch);
+    int waddchnstr(WINDOW *win, const chtype *ch, int n);
+    int mvaddchstr(int y, int x, const chtype *ch);
+    int mvaddchnstr(int y, int x, const chtype *ch, int n);
+    int mvwaddchstr(WINDOW *, int y, int x, const chtype *ch);
+    int mvwaddchnstr(WINDOW *, int y, int x, const chtype *ch, int n);
+
+    int add_wchstr(const cchar_t *wch);
+    int add_wchnstr(const cchar_t *wch, int n);
+    int wadd_wchstr(WINDOW *win, const cchar_t *wch);
+    int wadd_wchnstr(WINDOW *win, const cchar_t *wch, int n);
+    int mvadd_wchstr(int y, int x, const cchar_t *wch);
+    int mvadd_wchnstr(int y, int x, const cchar_t *wch, int n);
+    int mvwadd_wchstr(WINDOW *win, int y, int x, const cchar_t *wch);
+    int mvwadd_wchnstr(WINDOW *win, int y, int x, const cchar_t *wch,
+                       int n);
+
+### Description
+
+   These routines write a chtype or cchar_t string directly into the
+   window structure, starting at the current or specified position. The
+   four routines with n as the last argument copy at most n elements,
+   but no more than will fit on the line. If n == -1 then the whole
+   string is copied, up to the maximum number that will fit on the line.
+
+   The cursor position is not advanced. These routines do not check for
+   newline or other special characters, nor does any line wrapping
+   occur.
+
+### Return Value
+
+   All functions return OK or ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    addchstr                    Y       Y       Y
+    waddchstr                   Y       Y       Y
+    mvaddchstr                  Y       Y       Y
+    mvwaddchstr                 Y       Y       Y
+    addchnstr                   Y       Y       Y
+    waddchnstr                  Y       Y       Y
+    mvaddchnstr                 Y       Y       Y
+    mvwaddchnstr                Y       Y       Y
+    add_wchstr                  Y       Y       Y
+    wadd_wchstr                 Y       Y       Y
+    mvadd_wchstr                Y       Y       Y
+    mvwadd_wchstr               Y       Y       Y
+    add_wchnstr                 Y       Y       Y
+    wadd_wchnstr                Y       Y       Y
+    mvadd_wchnstr               Y       Y       Y
+    mvwadd_wchnstr              Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+addstr
+------
+
+### Synopsis
+
+    int addstr(const char *str);
+    int addnstr(const char *str, int n);
+    int waddstr(WINDOW *win, const char *str);
+    int waddnstr(WINDOW *win, const char *str, int n);
+    int mvaddstr(int y, int x, const char *str);
+    int mvaddnstr(int y, int x, const char *str, int n);
+    int mvwaddstr(WINDOW *win, int y, int x, const char *str);
+    int mvwaddnstr(WINDOW *win, int y, int x, const char *str, int n);
+
+    int addwstr(const wchar_t *wstr);
+    int addnwstr(const wchar_t *wstr, int n);
+    int waddwstr(WINDOW *win, const wchar_t *wstr);
+    int waddnwstr(WINDOW *win, const wchar_t *wstr, int n);
+    int mvaddwstr(int y, int x, const wchar_t *wstr);
+    int mvaddnwstr(int y, int x, const wchar_t *wstr, int n);
+    int mvwaddwstr(WINDOW *win, int y, int x, const wchar_t *wstr);
+    int mvwaddnwstr(WINDOW *win, int y, int x, const wchar_t *wstr, int n);
+
+### Description
+
+   These routines write all the characters of the null-terminated string
+   str or wide-character string wstr to the given window. The
+   functionality is similar to calling waddch() once for each character
+   in the string; except that, when PDCurses is built with wide-
+   character support enabled, the narrow-character functions treat the
+   string as a multibyte string in the current locale, and convert it.
+   The routines with n as the last argument write at most n characters;
+   if n is negative, then the entire string will be added.
+
+### Return Value
+
+   All functions return OK or ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    addstr                      Y       Y       Y
+    waddstr                     Y       Y       Y
+    mvaddstr                    Y       Y       Y
+    mvwaddstr                   Y       Y       Y
+    addnstr                     Y       Y       Y
+    waddnstr                    Y       Y       Y
+    mvaddnstr                   Y       Y       Y
+    mvwaddnstr                  Y       Y       Y
+    addwstr                     Y       Y       Y
+    waddwstr                    Y       Y       Y
+    mvaddwstr                   Y       Y       Y
+    mvwaddwstr                  Y       Y       Y
+    addnwstr                    Y       Y       Y
+    waddnwstr                   Y       Y       Y
+    mvaddnwstr                  Y       Y       Y
+    mvwaddnwstr                 Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+attr
+----
+
+### Synopsis
+
+    int attroff(chtype attrs);
+    int wattroff(WINDOW *win, chtype attrs);
+    int attron(chtype attrs);
+    int wattron(WINDOW *win, chtype attrs);
+    int attrset(chtype attrs);
+    int wattrset(WINDOW *win, chtype attrs);
+    int standend(void);
+    int wstandend(WINDOW *win);
+    int standout(void);
+    int wstandout(WINDOW *win);
+
+    int color_set(short color_pair, void *opts);
+    int wcolor_set(WINDOW *win, short color_pair, void *opts);
+
+    int attr_get(attr_t *attrs, short *color_pair, void *opts);
+    int attr_off(attr_t attrs, void *opts);
+    int attr_on(attr_t attrs, void *opts);
+    int attr_set(attr_t attrs, short color_pair, void *opts);
+    int wattr_get(WINDOW *win, attr_t *attrs, short *color_pair,
+                  void *opts);
+    int wattr_off(WINDOW *win, attr_t attrs, void *opts);
+    int wattr_on(WINDOW *win, attr_t attrs, void *opts);
+    int wattr_set(WINDOW *win, attr_t attrs, short color_pair,
+                  void *opts);
+
+    int chgat(int n, attr_t attr, short color, const void *opts);
+    int mvchgat(int y, int x, int n, attr_t attr, short color,
+                const void *opts);
+    int mvwchgat(WINDOW *win, int y, int x, int n, attr_t attr,
+                 short color, const void *opts);
+    int wchgat(WINDOW *win, int n, attr_t attr, short color,
+               const void *opts);
+
+    chtype getattrs(WINDOW *win);
+
+    int underend(void);
+    int wunderend(WINDOW *win);
+    int underscore(void);
+    int wunderscore(WINDOW *win);
+
+### Description
+
+   These functions manipulate the current attributes and/or colors of
+   the named window. These attributes can be any combination of
+   A_STANDOUT, A_REVERSE, A_BOLD, A_DIM, A_BLINK, A_UNDERLINE. These
+   constants are defined in <curses.h> and can be combined with the
+   bitwise-OR operator (|).
+
+   The current attributes of a window are applied to all chtypes that
+   are written into the window with waddch(). Attributes are a property
+   of the chtype, and move with the character through any scrolling or
+   insert/delete operations.
+
+   wattrset() sets the current attributes of the given window to attrs.
+   attrset() is the stdscr version.
+
+   wattroff() turns off the named attributes without affecting any other
+   attributes; wattron() turns them on.
+
+   wcolor_set() sets the window color to the value of color_pair. opts
+   is unused.
+
+   standout() is the same as attron(A_STANDOUT). standend() is the same
+   as attrset(A_NORMAL); that is, it turns off all attributes.
+
+   The attr_* and wattr_* functions are intended for use with the WA_*
+   attributes. In PDCurses, these are the same as A_*, and there is no
+   difference in bevahior from the chtype-based functions. In all cases,
+   opts is unused.
+
+   wattr_get() retrieves the attributes and color pair for the specified
+   window.
+
+   wchgat() sets the color pair and attributes for the next n cells on
+   the current line of a given window, without changing the existing
+   text, or alterting the window's attributes. An n of -1 extends the
+   change to the edge of the window. The changes take effect
+   immediately. opts is unused.
+
+   wunderscore() turns on the A_UNDERLINE attribute; wunderend() turns
+   it off. underscore() and underend() are the stdscr versions.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    attroff                     Y       Y       Y
+    wattroff                    Y       Y       Y
+    attron                      Y       Y       Y
+    wattron                     Y       Y       Y
+    attrset                     Y       Y       Y
+    wattrset                    Y       Y       Y
+    standend                    Y       Y       Y
+    wstandend                   Y       Y       Y
+    standout                    Y       Y       Y
+    wstandout                   Y       Y       Y
+    color_set                   Y       Y       Y
+    wcolor_set                  Y       Y       Y
+    attr_get                    Y       Y       Y
+    wattr_get                   Y       Y       Y
+    attr_on                     Y       Y       Y
+    wattr_on                    Y       Y       Y
+    attr_off                    Y       Y       Y
+    wattr_off                   Y       Y       Y
+    attr_set                    Y       Y       Y
+    wattr_set                   Y       Y       Y
+    chgat                       Y       Y       Y
+    wchgat                      Y       Y       Y
+    mvchgat                     Y       Y       Y
+    mvwchgat                    Y       Y       Y
+    getattrs                    -       Y       Y
+    underend                    -       -       Y
+    wunderend                   -       -       Y
+    underscore                  -       -       Y
+    wunderscore                 -       -       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+beep
+----
+
+### Synopsis
+
+    int beep(void);
+    int flash(void);
+
+### Description
+
+   beep() sounds the audible bell on the terminal, if possible; if not,
+   it calls flash().
+
+   flash() "flashes" the screen, by inverting the foreground and
+   background of every cell, pausing, and then restoring the original
+   attributes.
+
+### Return Value
+
+   These functions return ERR if called before initscr(), otherwise OK.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    beep                        Y       Y       Y
+    flash                       Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+bkgd
+----
+
+### Synopsis
+
+    int bkgd(chtype ch);
+    void bkgdset(chtype ch);
+    chtype getbkgd(WINDOW *win);
+    int wbkgd(WINDOW *win, chtype ch);
+    void wbkgdset(WINDOW *win, chtype ch);
+
+    int bkgrnd(const cchar_t *wch);
+    void bkgrndset(const cchar_t *wch);
+    int getbkgrnd(cchar_t *wch);
+    int wbkgrnd(WINDOW *win, const cchar_t *wch);
+    void wbkgrndset(WINDOW *win, const cchar_t *wch);
+    int wgetbkgrnd(WINDOW *win, cchar_t *wch);
+
+### Description
+
+   bkgdset() and wbkgdset() manipulate the background of a window. The
+   background is a chtype consisting of any combination of attributes
+   and a character; it is combined with each chtype added or inserted to
+   the window by waddch() or winsch(). Only the attribute part is used
+   to set the background of non-blank characters, while both character
+   and attributes are used for blank positions.
+
+   bkgd() and wbkgd() not only change the background, but apply it
+   immediately to every cell in the window.
+
+   wbkgrnd(), wbkgrndset() and wgetbkgrnd() are the "wide-character"
+   versions of these functions, taking a pointer to a cchar_t instead of
+   a chtype. However, in PDCurses, cchar_t and chtype are the same.
+
+   The attributes that are defined with the attrset()/attron() set of
+   functions take precedence over the background attributes if there is
+   a conflict (e.g., different color pairs).
+
+### Return Value
+
+   bkgd() and wbkgd() return OK, unless the window is NULL, in which
+   case they return ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    bkgd                        Y       Y       Y
+    bkgdset                     Y       Y       Y
+    getbkgd                     Y       Y       Y
+    wbkgd                       Y       Y       Y
+    wbkgdset                    Y       Y       Y
+    bkgrnd                      Y       Y       Y
+    bkgrndset                   Y       Y       Y
+    getbkgrnd                   Y       Y       Y
+    wbkgrnd                     Y       Y       Y
+    wbkgrndset                  Y       Y       Y
+    wgetbkgrnd                  Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+border
+------
+
+### Synopsis
+
+    int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl,
+               chtype tr, chtype bl, chtype br);
+    int wborder(WINDOW *win, chtype ls, chtype rs, chtype ts,
+                chtype bs, chtype tl, chtype tr, chtype bl, chtype br);
+    int box(WINDOW *win, chtype verch, chtype horch);
+    int hline(chtype ch, int n);
+    int vline(chtype ch, int n);
+    int whline(WINDOW *win, chtype ch, int n);
+    int wvline(WINDOW *win, chtype ch, int n);
+    int mvhline(int y, int x, chtype ch, int n);
+    int mvvline(int y, int x, chtype ch, int n);
+    int mvwhline(WINDOW *win, int y, int x, chtype ch, int n);
+    int mvwvline(WINDOW *win, int y, int x, chtype ch, int n);
+
+    int border_set(const cchar_t *ls, const cchar_t *rs,
+                   const cchar_t *ts, const cchar_t *bs,
+                   const cchar_t *tl, const cchar_t *tr,
+                const cchar_t *bl, const cchar_t *br);
+    int wborder_set(WINDOW *win, const cchar_t *ls, const cchar_t *rs,
+                    const cchar_t *ts, const cchar_t *bs,
+                    const cchar_t *tl, const cchar_t *tr,
+                    const cchar_t *bl, const cchar_t *br);
+    int box_set(WINDOW *win, const cchar_t *verch, const cchar_t *horch);
+    int hline_set(const cchar_t *wch, int n);
+    int vline_set(const cchar_t *wch, int n);
+    int whline_set(WINDOW *win, const cchar_t *wch, int n);
+    int wvline_set(WINDOW *win, const cchar_t *wch, int n);
+    int mvhline_set(int y, int x, const cchar_t *wch, int n);
+    int mvvline_set(int y, int x, const cchar_t *wch, int n);
+    int mvwhline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n);
+    int mvwvline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n);
+
+### Description
+
+   border(), wborder(), and box() draw a border around the edge of the
+   window. If any argument is zero, an appropriate default is used:
+
+    ls    left side of border             ACS_VLINE
+    rs    right side of border            ACS_VLINE
+    ts    top side of border              ACS_HLINE
+    bs    bottom side of border           ACS_HLINE
+    tl    top left corner of border       ACS_ULCORNER
+    tr    top right corner of border      ACS_URCORNER
+    bl    bottom left corner of border    ACS_LLCORNER
+    br    bottom right corner of border   ACS_LRCORNER
+
+   hline() and whline() draw a horizontal line, using ch, starting from
+   the current cursor position. The cursor position does not change. The
+   line is at most n characters long, or as many as will fit in the
+   window.
+
+   vline() and wvline() draw a vertical line, using ch, starting from
+   the current cursor position. The cursor position does not change. The
+   line is at most n characters long, or as many as will fit in the
+   window.
+
+   The *_set functions are the "wide-character" versions, taking
+   pointers to cchar_t instead of chtype. Note that in PDCurses, chtype
+   and cchar_t are the same.
+
+### Return Value
+
+   These functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    border                      Y       Y       Y
+    wborder                     Y       Y       Y
+    box                         Y       Y       Y
+    hline                       Y       Y       Y
+    vline                       Y       Y       Y
+    whline                      Y       Y       Y
+    wvline                      Y       Y       Y
+    mvhline                     Y       Y       Y
+    mvvline                     Y       Y       Y
+    mvwhline                    Y       Y       Y
+    mvwvline                    Y       Y       Y
+    border_set                  Y       Y       Y
+    wborder_set                 Y       Y       Y
+    box_set                     Y       Y       Y
+    hline_set                   Y       Y       Y
+    vline_set                   Y       Y       Y
+    whline_set                  Y       Y       Y
+    wvline_set                  Y       Y       Y
+    mvhline_set                 Y       Y       Y
+    mvvline_set                 Y       Y       Y
+    mvwhline_set                Y       Y       Y
+    mvwvline_set                Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+clear
+-----
+
+### Synopsis
+
+    int clear(void);
+    int wclear(WINDOW *win);
+    int erase(void);
+    int werase(WINDOW *win);
+    int clrtobot(void);
+    int wclrtobot(WINDOW *win);
+    int clrtoeol(void);
+    int wclrtoeol(WINDOW *win);
+
+### Description
+
+   erase() and werase() copy blanks (i.e. the background chtype) to
+   every cell of the window.
+
+   clear() and wclear() are similar to erase() and werase(), but they
+   also call clearok() to ensure that the the window is cleared on the
+   next wrefresh().
+
+   clrtobot() and wclrtobot() clear the window from the current cursor
+   position to the end of the window.
+
+   clrtoeol() and wclrtoeol() clear the window from the current cursor
+   position to the end of the current line.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    clear                       Y       Y       Y
+    wclear                      Y       Y       Y
+    erase                       Y       Y       Y
+    werase                      Y       Y       Y
+    clrtobot                    Y       Y       Y
+    wclrtobot                   Y       Y       Y
+    clrtoeol                    Y       Y       Y
+    wclrtoeol                   Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+color
+-----
+
+### Synopsis
+
+    bool has_colors(void);
+    int start_color(void);
+    int init_pair(short pair, short fg, short bg);
+    int pair_content(short pair, short *fg, short *bg);
+    int init_extended_pair(int pair, int fg, int bg);
+    int extended_pair_content(int pair, int *fg, int *bg);
+    bool can_change_color(void);
+    int init_color(short color, short red, short green, short blue);
+    int color_content(short color, short *red, short *green, short *blue);
+    int init_extended_color(int color, int red, int green, int blue);
+    int extended_color_content(int color, int *red, int *green, int *blue);
+
+    int assume_default_colors(int f, int b);
+    int use_default_colors(void);
+
+    int PDC_set_line_color(short color);
+
+### Description
+
+   To use these routines, first, call start_color(). Colors are always
+   used in pairs, referred to as color-pairs. A color-pair is created by
+   init_pair(), and consists of a foreground color and a background
+   color. After initialization, COLOR_PAIR(n) can be used like any other
+   video attribute.
+
+   has_colors() reports whether the terminal supports color.
+
+   start_color() initializes eight basic colors (black, red, green,
+   yellow, blue, magenta, cyan, and white), and two global variables:
+   COLORS and COLOR_PAIRS (respectively defining the maximum number of
+   colors and color-pairs the terminal is capable of displaying).
+
+   init_pair() changes the definition of a color-pair. It takes three
+   arguments: the number of the color-pair to be redefined, and the new
+   values of the foreground and background colors. The pair number must
+   be between 0 and COLOR_PAIRS - 1, inclusive. The foreground and
+   background must be between 0 and COLORS - 1, inclusive. If the color
+   pair was previously initialized, the screen is refreshed, and all
+   occurrences of that color-pair are changed to the new definition.
+
+   pair_content() is used to determine what the colors of a given color-
+   pair consist of.
+
+   init_extended_pair() and extended_pair_content() use ints for the
+   color pair index and the color values.  These allow a larger number
+   of colors and color pairs to be supported,  eliminating the 32767
+   color and color pair limits.
+
+   can_change_color() indicates if the terminal has the capability to
+   change the definition of its colors.
+
+   init_color() is used to redefine a color, if possible. Each of the
+   components -- red, green, and blue -- is specified in a range from 0
+   to 1000, inclusive.
+
+   color_content() reports the current definition of a color in the same
+   format as used by init_color().
+
+   init_extended_color() and extended_color_content() use integers for
+   the color index.  This enables us to have more than 32767 colors.
+
+   assume_default_colors() and use_default_colors() emulate the ncurses
+   extensions of the same names. assume_default_colors(f, b) is
+   essentially the same as init_pair(0, f, b) (which isn't allowed); it
+   redefines the default colors. use_default_colors() allows the use of
+   -1 as a foreground or background color with init_pair(), and calls
+   assume_default_colors(-1, -1); -1 represents the foreground or
+   background color that the terminal had at startup. If the environment
+   variable PDC_ORIGINAL_COLORS is set at the time start_color() is
+   called, that's equivalent to calling use_default_colors().
+
+   PDC_set_line_color() is used to set the color, globally, for the
+   color of the lines drawn for the attributes: A_UNDERLINE, A_LEFT and
+   A_RIGHT. A value of -1 (the default) indicates that the current
+   foreground color should be used.
+
+   NOTE: COLOR_PAIR() and PAIR_NUMBER() are implemented as macros.
+
+### Return Value
+
+   All functions return OK on success and ERR on error, except for
+   has_colors() and can_change_colors(), which return TRUE or FALSE.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    has_colors                  Y       Y       Y
+    start_color                 Y       Y       Y
+    init_pair                   Y       Y       Y
+    pair_content                Y       Y       Y
+    can_change_color            Y       Y       Y
+    init_color                  Y       Y       Y
+    color_content               Y       Y       Y
+    assume_default_colors       -       Y       Y
+    use_default_colors          -       Y       Y
+    PDC_set_line_color          -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+debug
+-----
+
+### Synopsis
+
+    void traceon(void);
+    void traceoff(void);
+    void PDC_debug(const char *, ...);
+
+### Description
+
+   traceon() and traceoff() toggle the recording of debugging
+   information to the file "trace". Although not standard, similar
+   functions are in some other curses implementations.
+
+   PDC_debug() is the function that writes to the file, based on whether
+   traceon() has been called. It's used from the PDC_LOG() macro.
+
+   The environment variable PDC_TRACE_FLUSH controls whether the trace
+   file contents are fflushed after each write. The default is not. Set
+   it to enable this (may affect performance).
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    traceon                     -       -       -
+    traceoff                    -       -       -
+    PDC_debug                   -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+delch
+-----
+
+### Synopsis
+
+    int delch(void);
+    int wdelch(WINDOW *win);
+    int mvdelch(int y, int x);
+    int mvwdelch(WINDOW *win, int y, int x);
+
+### Description
+
+   The character under the cursor in the window is deleted. All
+   characters to the right on the same line are moved to the left one
+   position and the last character on the line is filled with a blank.
+   The cursor position does not change (after moving to y, x if
+   coordinates are specified).
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    delch                       Y       Y       Y
+    wdelch                      Y       Y       Y
+    mvdelch                     Y       Y       Y
+    mvwdelch                    Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+deleteln
+--------
+
+### Synopsis
+
+    int deleteln(void);
+    int wdeleteln(WINDOW *win);
+    int insdelln(int n);
+    int winsdelln(WINDOW *win, int n);
+    int insertln(void);
+    int winsertln(WINDOW *win);
+
+    int mvdeleteln(int y, int x);
+    int mvwdeleteln(WINDOW *win, int y, int x);
+    int mvinsertln(int y, int x);
+    int mvwinsertln(WINDOW *win, int y, int x);
+
+### Description
+
+   With the deleteln() and wdeleteln() functions, the line under the
+   cursor in the window is deleted. All lines below the current line are
+   moved up one line. The bottom line of the window is cleared. The
+   cursor position does not change.
+
+   With the insertln() and winsertn() functions, a blank line is
+   inserted above the current line and the bottom line is lost.
+
+   mvdeleteln(), mvwdeleteln(), mvinsertln() and mvwinsertln() allow
+   moving the cursor and inserting/deleting in one call.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    deleteln                    Y       Y       Y
+    wdeleteln                   Y       Y       Y
+    mvdeleteln                  -       -       -
+    mvwdeleteln                 -       -       -
+    insdelln                    Y       Y       Y
+    winsdelln                   Y       Y       Y
+    insertln                    Y       Y       Y
+    winsertln                   Y       Y       Y
+    mvinsertln                  -       -       -
+    mvwinsertln                 -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+getch
+-----
+
+### Synopsis
+
+    int getch(void);
+    int wgetch(WINDOW *win);
+    int mvgetch(int y, int x);
+    int mvwgetch(WINDOW *win, int y, int x);
+    int ungetch(int ch);
+    int flushinp(void);
+
+    int get_wch(wint_t *wch);
+    int wget_wch(WINDOW *win, wint_t *wch);
+    int mvget_wch(int y, int x, wint_t *wch);
+    int mvwget_wch(WINDOW *win, int y, int x, wint_t *wch);
+    int unget_wch(const wchar_t wch);
+
+    unsigned long PDC_get_key_modifiers(void);
+    int PDC_return_key_modifiers(bool flag);
+
+### Description
+
+   With the getch(), wgetch(), mvgetch(), and mvwgetch() functions, a
+   character is read from the terminal associated with the window. In
+   nodelay mode, if there is no input waiting, the value ERR is
+   returned. In delay mode, the program will hang until the system
+   passes text through to the program. Depending on the setting of
+   cbreak(), this will be after one character or after the first
+   newline. Unless noecho() has been set, the character will also be
+   echoed into the designated window.
+
+   If keypad() is TRUE, and a function key is pressed, the token for
+   that function key will be returned instead of the raw characters.
+   Possible function keys are defined in <curses.h> with integers
+   beginning with 0401, whose names begin with KEY_.
+
+   If nodelay(win, TRUE) has been called on the window and no input is
+   waiting, the value ERR is returned.
+
+   ungetch() places ch back onto the input queue to be returned by the
+   next call to wgetch().
+
+   flushinp() throws away any type-ahead that has been typed by the user
+   and has not yet been read by the program.
+
+   wget_wch() is the wide-character version of wgetch(), available when
+   PDCurses is built with the PDC_WIDE option. It takes a pointer to a
+   wint_t rather than returning the key as an int, and instead returns
+   KEY_CODE_YES if the key is a function key. Otherwise, it returns OK
+   or ERR. It's important to check for KEY_CODE_YES, since regular wide
+   characters can have the same values as function key codes.
+
+   unget_wch() puts a wide character on the input queue.
+
+   PDC_get_key_modifiers() returns the keyboard modifiers (shift,
+   control, alt, numlock) effective at the time of the last getch()
+   call. Use the macros PDC_KEY_MODIFIER_* to determine which
+   modifier(s) were set. PDC_return_key_modifiers() tells getch() to
+   return modifier keys pressed alone as keystrokes (KEY_ALT_L, etc.).
+   These may not work on all platforms.
+
+   NOTE: getch() and ungetch() are implemented as macros, to avoid
+   conflict with many DOS compiler's runtime libraries.
+
+### Return Value
+
+   These functions return ERR or the value of the character, meta
+   character or function key token.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    getch                       Y       Y       Y
+    wgetch                      Y       Y       Y
+    mvgetch                     Y       Y       Y
+    mvwgetch                    Y       Y       Y
+    ungetch                     Y       Y       Y
+    flushinp                    Y       Y       Y
+    get_wch                     Y       Y       Y
+    wget_wch                    Y       Y       Y
+    mvget_wch                   Y       Y       Y
+    mvwget_wch                  Y       Y       Y
+    unget_wch                   Y       Y       Y
+    PDC_get_key_modifiers       -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+getstr
+------
+
+### Synopsis
+
+    int getstr(char *str);
+    int wgetstr(WINDOW *win, char *str);
+    int mvgetstr(int y, int x, char *str);
+    int mvwgetstr(WINDOW *win, int y, int x, char *str);
+    int getnstr(char *str, int n);
+    int wgetnstr(WINDOW *win, char *str, int n);
+    int mvgetnstr(int y, int x, char *str, int n);
+    int mvwgetnstr(WINDOW *win, int y, int x, char *str, int n);
+
+    int get_wstr(wint_t *wstr);
+    int wget_wstr(WINDOW *win, wint_t *wstr);
+    int mvget_wstr(int y, int x, wint_t *wstr);
+    int mvwget_wstr(WINDOW *win, int, int, wint_t *wstr);
+    int getn_wstr(wint_t *wstr, int n);
+    int wgetn_wstr(WINDOW *win, wint_t *wstr, int n);
+    int mvgetn_wstr(int y, int x, wint_t *wstr, int n);
+    int mvwgetn_wstr(WINDOW *win, int y, int x, wint_t *wstr, int n);
+
+### Description
+
+   These routines call wgetch() repeatedly to build a string,
+   interpreting erase and kill characters along the way, until a newline
+   or carriage return is received. When PDCurses is built with wide-
+   character support enabled, the narrow-character functions convert the
+   wgetch()'d values into a multibyte string in the current locale
+   before returning it. The resulting string is placed in the area
+   pointed to by *str. The routines with n as the last argument read at
+   most n characters.
+
+   Note that there's no way to know how long the buffer passed to
+   wgetstr() is, so use wgetnstr() to avoid buffer overflows.
+
+### Return Value
+
+   These functions return ERR on failure or any other value on success.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    getstr                      Y       Y       Y
+    wgetstr                     Y       Y       Y
+    mvgetstr                    Y       Y       Y
+    mvwgetstr                   Y       Y       Y
+    getnstr                     Y       Y       Y
+    wgetnstr                    Y       Y       Y
+    mvgetnstr                   Y       Y       Y
+    mvwgetnstr                  Y       Y       Y
+    get_wstr                    Y       Y       Y
+    wget_wstr                   Y       Y       Y
+    mvget_wstr                  Y       Y       Y
+    mvwget_wstr                 Y       Y       Y
+    getn_wstr                   Y       Y       Y
+    wgetn_wstr                  Y       Y       Y
+    mvgetn_wstr                 Y       Y       Y
+    mvwgetn_wstr                Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+getyx
+-----
+
+### Synopsis
+
+    void getyx(WINDOW *win, int y, int x);
+    void getparyx(WINDOW *win, int y, int x);
+    void getbegyx(WINDOW *win, int y, int x);
+    void getmaxyx(WINDOW *win, int y, int x);
+
+    void getsyx(int y, int x);
+    void setsyx(int y, int x);
+
+    int getbegy(WINDOW *win);
+    int getbegx(WINDOW *win);
+    int getcury(WINDOW *win);
+    int getcurx(WINDOW *win);
+    int getpary(WINDOW *win);
+    int getparx(WINDOW *win);
+    int getmaxy(WINDOW *win);
+    int getmaxx(WINDOW *win);
+
+### Description
+
+   The getyx() macro (defined in curses.h -- the prototypes here are
+   merely illustrative) puts the current cursor position of the
+   specified window into y and x. getbegyx() and getmaxyx() return the
+   starting coordinates and size of the specified window, respectively.
+   getparyx() returns the starting coordinates of the parent's window,
+   if the specified window is a subwindow; otherwise it sets y and x to
+   -1. These are all macros.
+
+   getsyx() gets the coordinates of the virtual screen cursor, and
+   stores them in y and x. If leaveok() is TRUE, it returns -1, -1. If
+   lines have been removed with ripoffline(), then getsyx() includes
+   these lines in its count; so, the returned y and x values should only
+   be used with setsyx().
+
+   setsyx() sets the virtual screen cursor to the y, x coordinates. If
+   either y or x is -1, leaveok() is set TRUE, else it's set FALSE.
+
+   getsyx() and setsyx() are meant to be used by a library routine that
+   manipulates curses windows without altering the position of the
+   cursor. Note that getsyx() is defined only as a macro.
+
+   getbegy(), getbegx(), getcurx(), getcury(), getmaxy(), getmaxx(),
+   getpary(), and getparx() return the appropriate coordinate or size
+   values, or ERR in the case of a NULL window.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    getyx                       Y       Y       Y
+    getparyx                    Y       Y       Y
+    getbegyx                    Y       Y       Y
+    getmaxyx                    Y       Y       Y
+    getsyx                      -       Y       Y
+    setsyx                      -       Y       Y
+    getbegy                     -       Y       Y
+    getbegx                     -       Y       Y
+    getcury                     -       Y       Y
+    getcurx                     -       Y       Y
+    getpary                     -       Y       Y
+    getparx                     -       Y       Y
+    getmaxy                     -       Y       Y
+    getmaxx                     -       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+inch
+----
+
+### Synopsis
+
+    chtype inch(void);
+    chtype winch(WINDOW *win);
+    chtype mvinch(int y, int x);
+    chtype mvwinch(WINDOW *win, int y, int x);
+
+    int in_wch(cchar_t *wcval);
+    int win_wch(WINDOW *win, cchar_t *wcval);
+    int mvin_wch(int y, int x, cchar_t *wcval);
+    int mvwin_wch(WINDOW *win, int y, int x, cchar_t *wcval);
+
+### Description
+
+   The inch() functions retrieve the character and attribute from the
+   current or specified window position, in the form of a chtype. If a
+   NULL window is specified, (chtype)ERR is returned.
+
+   The in_wch() functions are the wide-character versions; instead of
+   returning a chtype, they store a cchar_t at the address specified by
+   wcval, and return OK or ERR. (No value is stored when ERR is
+   returned.) Note that in PDCurses, chtype and cchar_t are the same.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    inch                        Y       Y       Y
+    winch                       Y       Y       Y
+    mvinch                      Y       Y       Y
+    mvwinch                     Y       Y       Y
+    in_wch                      Y       Y       Y
+    win_wch                     Y       Y       Y
+    mvin_wch                    Y       Y       Y
+    mvwin_wch                   Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+inchstr
+-------
+
+### Synopsis
+
+    int inchstr(chtype *ch);
+    int inchnstr(chtype *ch, int n);
+    int winchstr(WINDOW *win, chtype *ch);
+    int winchnstr(WINDOW *win, chtype *ch, int n);
+    int mvinchstr(int y, int x, chtype *ch);
+    int mvinchnstr(int y, int x, chtype *ch, int n);
+    int mvwinchstr(WINDOW *, int y, int x, chtype *ch);
+    int mvwinchnstr(WINDOW *, int y, int x, chtype *ch, int n);
+
+    int in_wchstr(cchar_t *wch);
+    int in_wchnstr(cchar_t *wch, int n);
+    int win_wchstr(WINDOW *win, cchar_t *wch);
+    int win_wchnstr(WINDOW *win, cchar_t *wch, int n);
+    int mvin_wchstr(int y, int x, cchar_t *wch);
+    int mvin_wchnstr(int y, int x, cchar_t *wch, int n);
+    int mvwin_wchstr(WINDOW *win, int y, int x, cchar_t *wch);
+    int mvwin_wchnstr(WINDOW *win, int y, int x, cchar_t *wch, int n);
+
+### Description
+
+   These routines read a chtype or cchar_t string from the window,
+   starting at the current or specified position, and ending at the
+   right margin, or after n elements, whichever is less.
+
+### Return Value
+
+   All functions return the number of elements read, or ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    inchstr                     Y       Y       Y
+    winchstr                    Y       Y       Y
+    mvinchstr                   Y       Y       Y
+    mvwinchstr                  Y       Y       Y
+    inchnstr                    Y       Y       Y
+    winchnstr                   Y       Y       Y
+    mvinchnstr                  Y       Y       Y
+    mvwinchnstr                 Y       Y       Y
+    in_wchstr                   Y       Y       Y
+    win_wchstr                  Y       Y       Y
+    mvin_wchstr                 Y       Y       Y
+    mvwin_wchstr                Y       Y       Y
+    in_wchnstr                  Y       Y       Y
+    win_wchnstr                 Y       Y       Y
+    mvin_wchnstr                Y       Y       Y
+    mvwin_wchnstr               Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+initscr
+-------
+
+### Synopsis
+
+    WINDOW *initscr(void);
+    WINDOW *Xinitscr(int argc, char **argv);
+    int endwin(void);
+    bool isendwin(void);
+    SCREEN *newterm(const char *type, FILE *outfd, FILE *infd);
+    SCREEN *set_term(SCREEN *new);
+    void delscreen(SCREEN *sp);
+
+    int resize_term(int nlines, int ncols);
+    bool is_termresized(void);
+    const char *curses_version(void);
+    void PDC_get_version(PDC_VERSION *ver);
+
+    int set_tabsize(int tabsize);
+
+### Description
+
+   initscr() should be the first curses routine called. It will
+   initialize all curses data structures, and arrange that the first
+   call to refresh() will clear the screen. In case of error, initscr()
+   will write a message to standard error and end the program.
+
+   endwin() should be called before exiting or escaping from curses mode
+   temporarily. It will restore tty modes, move the cursor to the lower
+   left corner of the screen and reset the terminal into the proper
+   non-visual mode. To resume curses after a temporary escape, call
+   refresh() or doupdate().
+
+   isendwin() returns TRUE if endwin() has been called without a
+   subsequent refresh, unless SP is NULL.
+
+   In some implementations of curses, newterm() allows the use of
+   multiple terminals. Here, it's just an alternative interface for
+   initscr(). It always returns SP, or NULL.
+
+   delscreen() frees the memory allocated by newterm() or initscr(),
+   since it's not freed by endwin(). This function is usually not
+   needed. In PDCurses, the parameter must be the value of SP, and
+   delscreen() sets SP to NULL.
+
+   set_term() does nothing meaningful in PDCurses, but is included for
+   compatibility with other curses implementations.
+
+   resize_term() is effectively two functions: When called with nonzero
+   values for nlines and ncols, it attempts to resize the screen to the
+   given size. When called with (0, 0), it merely adjusts the internal
+   structures to match the current size after the screen is resized by
+   the user. On the currently supported platforms, SDL, Windows console,
+   and X11 allow user resizing, while DOS, OS/2, SDL and Windows console
+   allow programmatic resizing. If you want to support user resizing,
+   you should check for getch() returning KEY_RESIZE, and/or call
+   is_termresized() at appropriate times; if either condition occurs,
+   call resize_term(0, 0). Then, with either user or programmatic
+   resizing, you'll have to resize any windows you've created, as
+   appropriate; resize_term() only handles stdscr and curscr.
+
+   is_termresized() returns TRUE if the curses screen has been resized
+   by the user, and a call to resize_term() is needed. Checking for
+   KEY_RESIZE is generally preferable, unless you're not handling the
+   keyboard.
+
+   curses_version() returns a string describing the version of PDCurses.
+
+   PDC_get_version() fills a PDC_VERSION structure provided by the user
+   with more detailed version info (see curses.h).
+
+   set_tabsize() sets the tab interval, stored in TABSIZE.
+
+### Return Value
+
+   All functions return NULL on error, except endwin(), which always
+   returns OK, and resize_term(), which returns either OK or ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    initscr                     Y       Y       Y
+    endwin                      Y       Y       Y
+    isendwin                    Y       Y       Y
+    newterm                     Y       Y       Y
+    set_term                    Y       Y       Y
+    delscreen                   Y       Y       Y
+    resize_term                 -       Y       Y
+    set_tabsize                 -       Y       Y
+    curses_version              -       Y       -
+    is_termresized              -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+inopts
+------
+
+### Synopsis
+
+    int cbreak(void);
+    int nocbreak(void);
+    int echo(void);
+    int noecho(void);
+    int halfdelay(int tenths);
+    int intrflush(WINDOW *win, bool bf);
+    int keypad(WINDOW *win, bool bf);
+    int meta(WINDOW *win, bool bf);
+    int nl(void);
+    int nonl(void);
+    int nodelay(WINDOW *win, bool bf);
+    int notimeout(WINDOW *win, bool bf);
+    int raw(void);
+    int noraw(void);
+    void noqiflush(void);
+    void qiflush(void);
+    void timeout(int delay);
+    void wtimeout(WINDOW *win, int delay);
+    int typeahead(int fildes);
+
+    int crmode(void);
+    int nocrmode(void);
+
+    bool is_keypad(const WINDOW *win);
+
+### Description
+
+   cbreak() and nocbreak() toggle cbreak mode. In cbreak mode,
+   characters typed by the user are made available immediately, and
+   erase/kill character processing is not performed. In nocbreak mode,
+   typed characters are buffered until a newline or carriage return.
+   Interrupt and flow control characters are unaffected by this mode.
+   PDCurses always starts in cbreak mode.
+
+   echo() and noecho() control whether typed characters are echoed by
+   the input routine. Initially, input characters are echoed. Subsequent
+   calls to echo() and noecho() do not flush type-ahead.
+
+   halfdelay() is similar to cbreak(), but allows for a time limit to be
+   specified, in tenths of a second. This causes getch() to block for
+   that period before returning ERR if no key has been received. tenths
+   must be between 1 and 255.
+
+   keypad() controls whether getch() returns function/special keys as
+   single key codes (e.g., the left arrow key as KEY_LEFT). Per X/Open,
+   the default for keypad mode is OFF. You'll probably want it on. With
+   keypad mode off, if a special key is pressed, getch() does nothing or
+   returns ERR.
+
+   nodelay() controls whether wgetch() is a non-blocking call. If the
+   option is enabled, and no input is ready, wgetch() will return ERR.
+   If disabled, wgetch() will hang until input is ready.
+
+   nl() enables the translation of a carriage return into a newline on
+   input. nonl() disables this. Initially, the translation does occur.
+
+   raw() and noraw() toggle raw mode. Raw mode is similar to cbreak
+   mode, in that characters typed are immediately passed through to the
+   user program. The difference is that in raw mode, the INTR, QUIT,
+   SUSP, and STOP characters are passed through without being
+   interpreted, and without generating a signal.
+
+   In PDCurses, the meta() function sets raw mode on or off.
+
+   timeout() and wtimeout() set blocking or non-blocking reads for the
+   specified window. If the delay is negative, a blocking read is used;
+   if zero, then non-blocking reads are done -- if no input is waiting,
+   ERR is returned immediately. If the delay is positive, the read
+   blocks for the delay period; if the period expires, ERR is returned.
+   The delay is given in milliseconds, but this is rounded down to 50ms
+   (1/20th sec) intervals, with a minimum of one interval if a postive
+   delay is given; i.e., 1-99 will wait 50ms, 100-149 will wait 100ms,
+   etc.
+
+   intrflush(), notimeout(), noqiflush(), qiflush() and typeahead() do
+   nothing in PDCurses, but are included for compatibility with other
+   curses implementations.
+
+   crmode() and nocrmode() are archaic equivalents to cbreak() and
+   nocbreak(), respectively.
+
+   is_keypad() reports whether the specified window is in keypad mode.
+
+### Return Value
+
+   All functions except is_keypad() and the void functions return OK on
+   success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    cbreak                      Y       Y       Y
+    nocbreak                    Y       Y       Y
+    echo                        Y       Y       Y
+    noecho                      Y       Y       Y
+    halfdelay                   Y       Y       Y
+    intrflush                   Y       Y       Y
+    keypad                      Y       Y       Y
+    meta                        Y       Y       Y
+    nl                          Y       Y       Y
+    nonl                        Y       Y       Y
+    nodelay                     Y       Y       Y
+    notimeout                   Y       Y       Y
+    raw                         Y       Y       Y
+    noraw                       Y       Y       Y
+    noqiflush                   Y       Y       Y
+    qiflush                     Y       Y       Y
+    timeout                     Y       Y       Y
+    wtimeout                    Y       Y       Y
+    typeahead                   Y       Y       Y
+    crmode                      Y       Y       Y
+    nocrmode                    Y       Y       Y
+    is_keypad                   -       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+insch
+-----
+
+### Synopsis
+
+    int insch(chtype ch);
+    int winsch(WINDOW *win, chtype ch);
+    int mvinsch(int y, int x, chtype ch);
+    int mvwinsch(WINDOW *win, int y, int x, chtype ch);
+
+    int insrawch(chtype ch);
+    int winsrawch(WINDOW *win, chtype ch);
+    int mvinsrawch(int y, int x, chtype ch);
+    int mvwinsrawch(WINDOW *win, int y, int x, chtype ch);
+
+    int ins_wch(const cchar_t *wch);
+    int wins_wch(WINDOW *win, const cchar_t *wch);
+    int mvins_wch(int y, int x, const cchar_t *wch);
+    int mvwins_wch(WINDOW *win, int y, int x, const cchar_t *wch);
+
+### Description
+
+   The insch() functions insert a chtype into the window at the current
+   or specified cursor position. The cursor is NOT advanced. A newline
+   is equivalent to clrtoeol(); tabs are expanded; other control
+   characters are converted as with unctrl().
+
+   The ins_wch() functions are the wide-character equivalents, taking
+   cchar_t pointers rather than chtypes.
+
+   Video attributes can be combined with a character by ORing them into
+   the parameter. Text, including attributes, can be copied from one
+   place to another using inch() and insch().
+
+   insrawch() etc. are PDCurses-specific wrappers for insch() etc. that
+   disable the translation of control characters.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    insch                       Y       Y       Y
+    winsch                      Y       Y       Y
+    mvinsch                     Y       Y       Y
+    mvwinsch                    Y       Y       Y
+    ins_wch                     Y       Y       Y
+    wins_wch                    Y       Y       Y
+    mvins_wch                   Y       Y       Y
+    mvwins_wch                  Y       Y       Y
+    insrawch                    -       -       -
+    winsrawch                   -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+insstr
+------
+
+### Synopsis
+
+    int insstr(const char *str);
+    int insnstr(const char *str, int n);
+    int winsstr(WINDOW *win, const char *str);
+    int winsnstr(WINDOW *win, const char *str, int n);
+    int mvinsstr(int y, int x, const char *str);
+    int mvinsnstr(int y, int x, const char *str, int n);
+    int mvwinsstr(WINDOW *win, int y, int x, const char *str);
+    int mvwinsnstr(WINDOW *win, int y, int x, const char *str, int n);
+
+    int ins_wstr(const wchar_t *wstr);
+    int ins_nwstr(const wchar_t *wstr, int n);
+    int wins_wstr(WINDOW *win, const wchar_t *wstr);
+    int wins_nwstr(WINDOW *win, const wchar_t *wstr, int n);
+    int mvins_wstr(int y, int x, const wchar_t *wstr);
+    int mvins_nwstr(int y, int x, const wchar_t *wstr, int n);
+    int mvwins_wstr(WINDOW *win, int y, int x, const wchar_t *wstr);
+    int mvwins_nwstr(WINDOW *win, int y, int x, const wchar_t *wstr, int n);
+
+### Description
+
+   The insstr() functions insert a character string into a window at the
+   current cursor position, by repeatedly calling winsch(). When
+   PDCurses is built with wide-character support enabled, the narrow-
+   character functions treat the string as a multibyte string in the
+   current locale, and convert it first. All characters to the right of
+   the cursor are moved to the right, with the possibility of the
+   rightmost characters on the line being lost. The cursor position
+   does not change (after moving to y, x, if specified). The routines
+   with n as the last argument insert at most n characters; if n is
+   negative, then the entire string is inserted.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    insstr                      Y       Y       Y
+    winsstr                     Y       Y       Y
+    mvinsstr                    Y       Y       Y
+    mvwinsstr                   Y       Y       Y
+    insnstr                     Y       Y       Y
+    winsnstr                    Y       Y       Y
+    mvinsnstr                   Y       Y       Y
+    mvwinsnstr                  Y       Y       Y
+    ins_wstr                    Y       Y       Y
+    wins_wstr                   Y       Y       Y
+    mvins_wstr                  Y       Y       Y
+    mvwins_wstr                 Y       Y       Y
+    ins_nwstr                   Y       Y       Y
+    wins_nwstr                  Y       Y       Y
+    mvins_nwstr                 Y       Y       Y
+    mvwins_nwstr                Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+instr
+-----
+
+### Synopsis
+
+    int instr(char *str);
+    int innstr(char *str, int n);
+    int winstr(WINDOW *win, char *str);
+    int winnstr(WINDOW *win, char *str, int n);
+    int mvinstr(int y, int x, char *str);
+    int mvinnstr(int y, int x, char *str, int n);
+    int mvwinstr(WINDOW *win, int y, int x, char *str);
+    int mvwinnstr(WINDOW *win, int y, int x, char *str, int n);
+
+    int inwstr(wchar_t *wstr);
+    int innwstr(wchar_t *wstr, int n);
+    int winwstr(WINDOW *win, wchar_t *wstr);
+    int winnwstr(WINDOW *win, wchar_t *wstr, int n);
+    int mvinwstr(int y, int x, wchar_t *wstr);
+    int mvinnwstr(int y, int x, wchar_t *wstr, int n);
+    int mvwinwstr(WINDOW *win, int y, int x, wchar_t *wstr);
+    int mvwinnwstr(WINDOW *win, int y, int x, wchar_t *wstr, int n);
+
+### Description
+
+   These functions take characters (or wide characters) from the current
+   or specified position in the window, and return them as a string in
+   str (or wstr). Attributes are ignored. The functions with n as the
+   last argument return a string at most n characters long.
+
+### Return Value
+
+   Upon successful completion, innstr(), mvinnstr(), mvwinnstr() and
+   winnstr() return the number of characters actually read into the
+   string; instr(), mvinstr(), mvwinstr() and winstr() return OK.
+   Otherwise, all these functions return ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    instr                       Y       Y       Y
+    winstr                      Y       Y       Y
+    mvinstr                     Y       Y       Y
+    mvwinstr                    Y       Y       Y
+    innstr                      Y       Y       Y
+    winnstr                     Y       Y       Y
+    mvinnstr                    Y       Y       Y
+    mvwinnstr                   Y       Y       Y
+    inwstr                      Y       Y       Y
+    winwstr                     Y       Y       Y
+    mvinwstr                    Y       Y       Y
+    mvwinwstr                   Y       Y       Y
+    innwstr                     Y       Y       Y
+    winnwstr                    Y       Y       Y
+    mvinnwstr                   Y       Y       Y
+    mvwinnwstr                  Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+kernel
+------
+
+### Synopsis
+
+    int def_prog_mode(void);
+    int def_shell_mode(void);
+    int reset_prog_mode(void);
+    int reset_shell_mode(void);
+    int resetty(void);
+    int savetty(void);
+    int ripoffline(int line, int (*init)(WINDOW *, int));
+    int curs_set(int visibility);
+    int napms(int ms);
+
+    int draino(int ms);
+    int resetterm(void);
+    int fixterm(void);
+    int saveterm(void);
+
+### Description
+
+   def_prog_mode() and def_shell_mode() save the current terminal modes
+   as the "program" (in curses) or "shell" (not in curses) state for use
+   by the reset_prog_mode() and reset_shell_mode() functions. This is
+   done automatically by initscr().
+
+   reset_prog_mode() and reset_shell_mode() restore the terminal to
+   "program" (in curses) or "shell" (not in curses) state. These are
+   done automatically by endwin() and doupdate() after an endwin(), so
+   they would normally not be called before these functions.
+
+   savetty() and resetty() save and restore the state of the terminal
+   modes. savetty() saves the current state in a buffer, and resetty()
+   restores the state to what it was at the last call to savetty().
+
+   curs_set() alters the appearance of the cursor. A visibility of 0
+   makes it disappear; 1 makes it appear "normal" (usually an underline)
+   and 2 makes it "highly visible" (usually a block).
+
+   ripoffline() reduces the size of stdscr by one line. If the "line"
+   parameter is positive, the line is removed from the top of the
+   screen; if negative, from the bottom. Up to 5 lines can be ripped off
+   stdscr by calling ripoffline() repeatedly. The function argument,
+   init, is called from within initscr() or newterm(), so ripoffline()
+   must be called before either of these functions. The init function
+   receives a pointer to a one-line WINDOW, and the width of the window.
+   Calling ripoffline() with a NULL init function pointer is an error.
+
+   napms() suspends the program for the specified number of
+   milliseconds. draino() is an archaic equivalent. Note that since
+   napms() attempts to give up a time slice and yield control back to
+   the OS, all times are approximate. (In DOS, the delay is actually
+   rounded down to 50ms (1/20th sec) intervals, with a minimum of one
+   interval; i.e., 1-99 will wait 50ms, 100-149 will wait 100ms, etc.)
+   0 returns immediately.
+
+   resetterm(), fixterm() and saveterm() are archaic equivalents for
+   reset_shell_mode(), reset_prog_mode() and def_prog_mode(),
+   respectively.
+
+### Return Value
+
+   All functions return OK on success and ERR on error, except
+   curs_set(), which returns the previous visibility.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    def_prog_mode               Y       Y       Y
+    def_shell_mode              Y       Y       Y
+    reset_prog_mode             Y       Y       Y
+    reset_shell_mode            Y       Y       Y
+    resetty                     Y       Y       Y
+    savetty                     Y       Y       Y
+    ripoffline                  Y       Y       Y
+    curs_set                    Y       Y       Y
+    napms                       Y       Y       Y
+    fixterm                     -       Y       -
+    resetterm                   -       Y       -
+    saveterm                    -       Y       -
+    draino                      -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+keyname
+-------
+
+### Synopsis
+
+    char *keyname(int key);
+
+    char *key_name(wchar_t c);
+
+    bool has_key(int key);
+
+### Description
+
+   keyname() returns a string corresponding to the argument key. key may
+   be any key returned by wgetch().
+
+   key_name() is the wide-character version. It takes a wchar_t
+   parameter, but still returns a char *.
+
+   has_key() returns TRUE for recognized keys, FALSE otherwise. This
+   function is an ncurses extension.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    keyname                     Y       Y       Y
+    key_name                    Y       Y       Y
+    has_key                     -       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+mouse
+-----
+
+### Synopsis
+
+    int mouse_set(mmask_t mbe);
+    int mouse_on(mmask_t mbe);
+    int mouse_off(mmask_t mbe);
+    int request_mouse_pos(void);
+    void wmouse_position(WINDOW *win, int *y, int *x);
+    mmask_t getmouse(void);
+
+    int mouseinterval(int wait);
+    bool wenclose(const WINDOW *win, int y, int x);
+    bool wmouse_trafo(const WINDOW *win, int *y, int *x, bool to_screen);
+    bool mouse_trafo(int *y, int *x, bool to_screen);
+    mmask_t mousemask(mmask_t mask, mmask_t *oldmask);
+    int nc_getmouse(MEVENT *event);
+    int ungetmouse(MEVENT *event);
+    bool has_mouse(void);
+
+### Description
+
+   As of PDCurses 3.0, there are two separate mouse interfaces: the
+   classic interface, which is based on the undocumented Sys V mouse
+   functions; and an ncurses-compatible interface. Both are active at
+   all times, and you can mix and match functions from each, though it's
+   not recommended. The ncurses interface is essentially an emulation
+   layer built on top of the classic interface; it's here to allow
+   easier porting of ncurses apps.
+
+   The classic interface: mouse_set(), mouse_on(), mouse_off(),
+   request_mouse_pos(), wmouse_position(), and getmouse(). An
+   application using this interface would start by calling mouse_set()
+   or mouse_on() with a non-zero value, often ALL_MOUSE_EVENTS. Then it
+   would check for a KEY_MOUSE return from getch(). If found, it would
+   call request_mouse_pos() to get the current mouse status.
+
+   mouse_set(), mouse_on() and mouse_off() are analagous to attrset(),
+   attron() and attroff(). These functions set the mouse button events
+   to trap. The button masks used in these functions are defined in
+   curses.h and can be or'ed together. They are the group of masks
+   starting with BUTTON1_RELEASED.
+
+   request_mouse_pos() requests curses to fill in the Mouse_status
+   structure with the current state of the mouse.
+
+   wmouse_position() determines if the current mouse position is within
+   the window passed as an argument. If the mouse is outside the current
+   window, -1 is returned in the y and x arguments; otherwise the y and
+   x coordinates of the mouse (relative to the top left corner of the
+   window) are returned in y and x.
+
+   getmouse() returns the current status of the trapped mouse buttons as
+   set by mouse_set() or mouse_on().
+
+   The ncurses interface: mouseinterval(), wenclose(), wmouse_trafo(),
+   mouse_trafo(), mousemask(), nc_getmouse(), ungetmouse() and
+   has_mouse(). A typical application using this interface would start
+   by calling mousemask() with a non-zero value, often ALL_MOUSE_EVENTS.
+   Then it would check for a KEY_MOUSE return from getch(). If found, it
+   would call nc_getmouse() to get the current mouse status.
+
+   mouseinterval() sets the timeout for a mouse click. On all current
+   platforms, PDCurses receives mouse button press and release events,
+   but must synthesize click events. It does this by checking whether a
+   release event is queued up after a press event. If it gets a press
+   event, and there are no more events waiting, it will wait for the
+   timeout interval, then check again for a release. A press followed by
+   a release is reported as BUTTON_CLICKED; otherwise it's passed
+   through as BUTTON_PRESSED. The default timeout is 150ms; valid values
+   are 0 (no clicks reported) through 1000ms. In x11, the timeout can
+   also be set via the clickPeriod resource. The return value from
+   mouseinterval() is the old timeout. To check the old value without
+   setting a new one, call it with a parameter of -1. Note that although
+   there's no classic equivalent for this function (apart from the
+   clickPeriod resource), the value set applies in both interfaces.
+
+   wenclose() reports whether the given screen-relative y, x coordinates
+   fall within the given window.
+
+   wmouse_trafo() converts between screen-relative and window-relative
+   coordinates. A to_screen parameter of TRUE means to convert from
+   window to screen; otherwise the reverse. The function returns FALSE
+   if the coordinates aren't within the window, or if any of the
+   parameters are NULL. The coordinates have been converted when the
+   function returns TRUE.
+
+   mouse_trafo() is the stdscr version of wmouse_trafo().
+
+   mousemask() is nearly equivalent to mouse_set(), but instead of
+   OK/ERR, it returns the value of the mask after setting it. (This
+   isn't necessarily the same value passed in, since the mask could be
+   altered on some platforms.) And if the second parameter is a non-null
+   pointer, mousemask() stores the previous mask value there. Also,
+   since the ncurses interface doesn't work with PDCurses' BUTTON_MOVED
+   events, mousemask() filters them out.
+
+   nc_getmouse() returns the current mouse status in an MEVENT struct.
+   This is equivalent to ncurses' getmouse(), renamed to avoid conflict
+   with PDCurses' getmouse(). But if you define PDC_NCMOUSE before
+   including curses.h, it defines getmouse() to nc_getmouse(), along
+   with a few other redefintions needed for compatibility with ncurses
+   code. nc_getmouse() calls request_mouse_pos(), which (not getmouse())
+   is the classic equivalent.
+
+   ungetmouse() is the mouse equivalent of ungetch(). However, PDCurses
+   doesn't maintain a queue of mouse events; only one can be pushed
+   back, and it can overwrite or be overwritten by real mouse events.
+
+   has_mouse() reports whether the mouse is available at all on the
+   current platform.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    mouse_set                   -       -       -
+    mouse_on                    -       -       -
+    mouse_off                   -       -       -
+    request_mouse_pos           -       -       -
+    wmouse_position             -       -       -
+    getmouse                    -       *       -
+    mouseinterval               -       Y       -
+    wenclose                    -       Y       -
+    wmouse_trafo                -       Y       -
+    mouse_trafo                 -       Y       -
+    mousemask                   -       Y       -
+    nc_getmouse                 -       *       -
+    ungetmouse                  -       Y       -
+    has_mouse                   -       Y       -
+
+    * See above, under Description
+
+
+
+--------------------------------------------------------------------------
+
+
+move
+----
+
+### Synopsis
+
+    int move(int y, int x);
+    int mvcur(int oldrow, int oldcol, int newrow, int newcol);
+    int wmove(WINDOW *win, int y, int x);
+
+### Description
+
+   move() and wmove() move the cursor associated with the window to the
+   given location. This does not move the physical cursor of the
+   terminal until refresh() is called. The position specified is
+   relative to the upper left corner of the window, which is (0,0).
+
+   mvcur() moves the physical cursor without updating any window cursor
+   positions.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    move                        Y       Y       Y
+    mvcur                       Y       Y       Y
+    wmove                       Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+outopts
+-------
+
+### Synopsis
+
+    int clearok(WINDOW *win, bool bf);
+    int idlok(WINDOW *win, bool bf);
+    void idcok(WINDOW *win, bool bf);
+    void immedok(WINDOW *win, bool bf);
+    int leaveok(WINDOW *win, bool bf);
+    int setscrreg(int top, int bot);
+    int wsetscrreg(WINDOW *win, int top, int bot);
+    int scrollok(WINDOW *win, bool bf);
+
+    int raw_output(bool bf);
+
+    bool is_leaveok(const WINDOW *win);
+
+### Description
+
+   With clearok(), if bf is TRUE, the next call to wrefresh() with this
+   window will clear the screen completely and redraw the entire screen.
+
+   immedok(), called with a second argument of TRUE, causes an automatic
+   wrefresh() every time a change is made to the specified window.
+
+   Normally, the hardware cursor is left at the location of the window
+   being refreshed. leaveok() allows the cursor to be left wherever the
+   update happens to leave it. It's useful for applications where the
+   cursor is not used, since it reduces the need for cursor motions. If
+   possible, the cursor is made invisible when this option is enabled.
+
+   wsetscrreg() sets a scrolling region in a window; "top" and "bot" are
+   the line numbers for the top and bottom margins. If this option and
+   scrollok() are enabled, any attempt to move off the bottom margin
+   will cause all lines in the scrolling region to scroll up one line.
+   setscrreg() is the stdscr version.
+
+   idlok() and idcok() do nothing in PDCurses, but are provided for
+   compatibility with other curses implementations.
+
+   raw_output() enables the output of raw characters using the standard
+   *add* and *ins* curses functions (that is, it disables translation of
+   control characters).
+
+   is_leaveok() reports whether the specified window is in leaveok mode.
+
+### Return Value
+
+   All functions except is_leaveok() return OK on success and ERR on
+   error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    clearok                     Y       Y       Y
+    idlok                       Y       Y       Y
+    idcok                       Y       Y       Y
+    immedok                     Y       Y       Y
+    leaveok                     Y       Y       Y
+    setscrreg                   Y       Y       Y
+    wsetscrreg                  Y       Y       Y
+    scrollok                    Y       Y       Y
+    is_leaveok                  -       Y       Y
+    raw_output                  -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+overlay
+-------
+
+### Synopsis
+
+    int overlay(const WINDOW *src_w, WINDOW *dst_w)
+    int overwrite(const WINDOW *src_w, WINDOW *dst_w)
+    int copywin(const WINDOW *src_w, WINDOW *dst_w, int src_tr,
+                int src_tc, int dst_tr, int dst_tc, int dst_br,
+                int dst_bc, int _overlay)
+
+### Description
+
+   overlay() and overwrite() copy all the text from src_w into dst_w.
+   The windows need not be the same size. Those characters in the source
+   window that intersect with the destination window are copied, so that
+   the characters appear in the same physical position on the screen.
+   The difference between the two functions is that overlay() is non-
+   destructive (blanks are not copied) while overwrite() is destructive
+   (blanks are copied).
+
+   copywin() is similar, but doesn't require that the two windows
+   overlap. The arguments src_tc and src_tr specify the top left corner
+   of the region to be copied. dst_tc, dst_tr, dst_br, and dst_bc
+   specify the region within the destination window to copy to. The
+   argument "overlay", if TRUE, indicates that the copy is done non-
+   destructively (as in overlay()); blanks in the source window are not
+   copied to the destination window. When overlay is FALSE, blanks are
+   copied.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    overlay                     Y       Y       Y
+    overwrite                   Y       Y       Y
+    copywin                     Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+pad
+---
+
+### Synopsis
+
+    WINDOW *newpad(int nlines, int ncols);
+    WINDOW *subpad(WINDOW *orig, int nlines, int ncols,
+                   int begy, int begx);
+    int prefresh(WINDOW *win, int py, int px, int sy1, int sx1,
+                 int sy2, int sx2);
+    int pnoutrefresh(WINDOW *w, int py, int px, int sy1, int sx1,
+                     int sy2, int sx2);
+    int pechochar(WINDOW *pad, chtype ch);
+    int pecho_wchar(WINDOW *pad, const cchar_t *wch);
+
+    bool is_pad(const WINDOW *pad);
+
+### Description
+
+   A pad is a special kind of window, which is not restricted by the
+   screen size, and is not necessarily associated with a particular part
+   of the screen. You can use a pad when you need a large window, and
+   only a part of the window will be on the screen at one time. Pads are
+   not refreshed automatically (e.g., from scrolling or echoing of
+   input). You can't call wrefresh() with a pad as an argument; use
+   prefresh() or pnoutrefresh() instead. Note that these routines
+   require additional parameters to specify the part of the pad to be
+   displayed, and the location to use on the screen.
+
+   newpad() creates a new pad data structure.
+
+   subpad() creates a new sub-pad within a pad, at position (begy,
+   begx), with dimensions of nlines lines and ncols columns. This
+   position is relative to the pad, and not to the screen as with
+   subwin. Changes to either the parent pad or sub-pad will affect both.
+   When using sub-pads, you may need to call touchwin() before calling
+   prefresh().
+
+   pnoutrefresh() copies the specified pad to the virtual screen.
+
+   prefresh() calls pnoutrefresh(), followed by doupdate().
+
+   These routines are analogous to wnoutrefresh() and wrefresh(). (py,
+   px) specifies the upper left corner of the part of the pad to be
+   displayed; (sy1, sx1) and (sy2, sx2) describe the screen rectangle
+   that will contain the selected part of the pad.
+
+   pechochar() is functionally equivalent to addch() followed by a call
+   to prefresh(), with the last-used coordinates and dimensions.
+   pecho_wchar() is the wide-character version.
+
+   is_pad() reports whether the specified window is a pad.
+
+### Return Value
+
+   All functions except is_pad() return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    newpad                      Y       Y       Y
+    subpad                      Y       Y       Y
+    prefresh                    Y       Y       Y
+    pnoutrefresh                Y       Y       Y
+    pechochar                   Y       Y       Y
+    pecho_wchar                 Y       Y       Y
+    is_pad                      -       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+panel
+-----
+
+### Synopsis
+
+    int bottom_panel(PANEL *pan);
+    int del_panel(PANEL *pan);
+    int hide_panel(PANEL *pan);
+    int move_panel(PANEL *pan, int starty, int startx);
+    PANEL *new_panel(WINDOW *win);
+    PANEL *panel_above(const PANEL *pan);
+    PANEL *panel_below(const PANEL *pan);
+    int panel_hidden(const PANEL *pan);
+    const void *panel_userptr(const PANEL *pan);
+    WINDOW *panel_window(const PANEL *pan);
+    int replace_panel(PANEL *pan, WINDOW *win);
+    int set_panel_userptr(PANEL *pan, const void *uptr);
+    int show_panel(PANEL *pan);
+    int top_panel(PANEL *pan);
+    void update_panels(void);
+
+### Description
+
+   For historic reasons, and for compatibility with other versions of
+   curses, the panel functions are prototyped in a separate header,
+   panel.h. In many implementations, they're also in a separate library,
+   but PDCurses incorporates them.
+
+   The panel functions provide a way to have depth relationships between
+   curses windows. Panels can overlap without making visible the
+   overlapped portions of underlying windows. The initial curses window,
+   stdscr, lies beneath all panels. The set of currently visible panels
+   is the 'deck' of panels.
+
+   You can create panels, fetch and set their associated windows,
+   shuffle panels in the deck, and manipulate them in other ways.
+
+   bottom_panel() places pan at the bottom of the deck. The size,
+   location and contents of the panel are unchanged.
+
+   del_panel() deletes pan, but not its associated winwow.
+
+   hide_panel() removes a panel from the deck and thus hides it from
+   view.
+
+   move_panel() moves the curses window associated with pan, so that its
+   upper lefthand corner is at the supplied coordinates. (Don't use
+   mvwin() on the window.)
+
+   new_panel() creates a new panel associated with win and returns the
+   panel pointer. The new panel is placed at the top of the deck.
+
+   panel_above() returns a pointer to the panel in the deck above pan,
+   or NULL if pan is the top panel. If the value of pan passed is NULL,
+   this function returns a pointer to the bottom panel in the deck.
+
+   panel_below() returns a pointer to the panel in the deck below pan,
+   or NULL if pan is the bottom panel. If the value of pan passed is
+   NULL, this function returns a pointer to the top panel in the deck.
+
+   panel_hidden() returns OK if pan is hidden and ERR if it is not.
+
+   panel_userptr() - Each panel has a user pointer available for
+   maintaining relevant information. This function returns a pointer to
+   that information previously set up by set_panel_userptr().
+
+   panel_window() returns a pointer to the curses window associated with
+   the panel.
+
+   replace_panel() replaces the current window of pan with win.
+
+   set_panel_userptr() - Each panel has a user pointer available for
+   maintaining relevant information. This function sets the value of
+   that information.
+
+   show_panel() makes a previously hidden panel visible and places it
+   back in the deck on top.
+
+   top_panel() places pan on the top of the deck. The size, location and
+   contents of the panel are unchanged.
+
+   update_panels() refreshes the virtual screen to reflect the depth
+   relationships between the panels in the deck. The user must use
+   doupdate() to refresh the physical screen.
+
+### Return Value
+
+   Each routine that returns a pointer to an object returns NULL if an
+   error occurs. Each panel routine that returns an integer, returns OK
+   if it executes successfully and ERR if it does not.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    bottom_panel                -       Y       Y
+    del_panel                   -       Y       Y
+    hide_panel                  -       Y       Y
+    move_panel                  -       Y       Y
+    new_panel                   -       Y       Y
+    panel_above                 -       Y       Y
+    panel_below                 -       Y       Y
+    panel_hidden                -       Y       Y
+    panel_userptr               -       Y       Y
+    panel_window                -       Y       Y
+    replace_panel               -       Y       Y
+    set_panel_userptr           -       Y       Y
+    show_panel                  -       Y       Y
+    top_panel                   -       Y       Y
+    update_panels               -       Y       Y
+
+  Credits:
+    Original Author - Warren Tucker <wht@n4hgf.mt-park.ga.us>
+
+
+
+--------------------------------------------------------------------------
+
+
+printw
+------
+
+### Synopsis
+
+    int printw(const char *fmt, ...);
+    int wprintw(WINDOW *win, const char *fmt, ...);
+    int mvprintw(int y, int x, const char *fmt, ...);
+    int mvwprintw(WINDOW *win, int y, int x, const char *fmt,...);
+    int vwprintw(WINDOW *win, const char *fmt, va_list varglist);
+    int vw_printw(WINDOW *win, const char *fmt, va_list varglist);
+
+### Description
+
+   The printw() functions add a formatted string to the window at the
+   current or specified cursor position. The format strings are the same
+   as used in the standard C library's printf(). (printw() can be used
+   as a drop-in replacement for printf().)
+
+   The duplication between vwprintw() and vw_printw() is for historic
+   reasons. In PDCurses, they're the same.
+
+### Return Value
+
+   All functions return the number of characters printed, or ERR on
+   error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    printw                      Y       Y       Y
+    wprintw                     Y       Y       Y
+    mvprintw                    Y       Y       Y
+    mvwprintw                   Y       Y       Y
+    vwprintw                    Y       Y       Y
+    vw_printw                   Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+refresh
+-------
+
+### Synopsis
+
+    int refresh(void);
+    int wrefresh(WINDOW *win);
+    int wnoutrefresh(WINDOW *win);
+    int doupdate(void);
+    int redrawwin(WINDOW *win);
+    int wredrawln(WINDOW *win, int beg_line, int num_lines);
+
+### Description
+
+   wrefresh() copies the named window to the physical terminal screen,
+   taking into account what is already there in order to optimize cursor
+   movement. refresh() does the same, using stdscr. These routines must
+   be called to get any output on the terminal, as other routines only
+   manipulate data structures. Unless leaveok() has been enabled, the
+   physical cursor of the terminal is left at the location of the
+   window's cursor.
+
+   wnoutrefresh() and doupdate() allow multiple updates with more
+   efficiency than wrefresh() alone. wrefresh() works by first calling
+   wnoutrefresh(), which copies the named window to the virtual screen.
+   It then calls doupdate(), which compares the virtual screen to the
+   physical screen and does the actual update. A series of calls to
+   wrefresh() will result in alternating calls to wnoutrefresh() and
+   doupdate(), causing several bursts of output to the screen. By first
+   calling wnoutrefresh() for each window, it is then possible to call
+   doupdate() only once.
+
+   In PDCurses, redrawwin() is equivalent to touchwin(), and wredrawln()
+   is the same as touchline(). In some other curses implementations,
+   there's a subtle distinction, but it has no meaning in PDCurses.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    refresh                     Y       Y       Y
+    wrefresh                    Y       Y       Y
+    wnoutrefresh                Y       Y       Y
+    doupdate                    Y       Y       Y
+    redrawwin                   Y       Y       Y
+    wredrawln                   Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+scanw
+-----
+
+### Synopsis
+
+    int scanw(const char *fmt, ...);
+    int wscanw(WINDOW *win, const char *fmt, ...);
+    int mvscanw(int y, int x, const char *fmt, ...);
+    int mvwscanw(WINDOW *win, int y, int x, const char *fmt, ...);
+    int vwscanw(WINDOW *win, const char *fmt, va_list varglist);
+    int vw_scanw(WINDOW *win, const char *fmt, va_list varglist);
+
+### Description
+
+   These routines correspond to the standard C library's scanf() family.
+   Each gets a string from the window via wgetnstr(), and uses the
+   resulting line as input for the scan.
+
+   The duplication between vwscanw() and vw_scanw() is for historic
+   reasons. In PDCurses, they're the same.
+
+### Return Value
+
+   On successful completion, these functions return the number of items
+   successfully matched. Otherwise they return ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    scanw                       Y       Y       Y
+    wscanw                      Y       Y       Y
+    mvscanw                     Y       Y       Y
+    mvwscanw                    Y       Y       Y
+    vwscanw                     Y       Y       Y
+    vw_scanw                    Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+scr_dump
+--------
+
+### Synopsis
+
+    int putwin(WINDOW *win, FILE *filep);
+    WINDOW *getwin(FILE *filep);
+    int scr_dump(const char *filename);
+    int scr_init(const char *filename);
+    int scr_restore(const char *filename);
+    int scr_set(const char *filename);
+
+### Description
+
+   getwin() reads window-related data previously stored in a file by
+   putwin(). It then creates and initialises a new window using that
+   data.
+
+   putwin() writes all data associated with a window into a file, using
+   an unspecified format. This information can be retrieved later using
+   getwin().
+
+   scr_dump() writes the current contents of the virtual screen to the
+   file named by filename in an unspecified format.
+
+   scr_restore() function sets the virtual screen to the contents of the
+   file named by filename, which must have been written using
+   scr_dump(). The next refresh operation restores the screen to the way
+   it looked in the dump file.
+
+   In PDCurses, scr_init() does nothing, and scr_set() is a synonym for
+   scr_restore(). Also, scr_dump() and scr_restore() save and load from
+   curscr. This differs from some other implementations, where
+   scr_init() works with curscr, and scr_restore() works with newscr;
+   but the effect should be the same. (PDCurses has no newscr.)
+
+### Return Value
+
+   On successful completion, getwin() returns a pointer to the window it
+   created. Otherwise, it returns a null pointer. Other functions return
+   OK or ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    putwin                      Y       Y       Y
+    getwin                      Y       Y       Y
+    scr_dump                    Y       Y       -
+    scr_init                    Y       Y       -
+    scr_restore                 Y       Y       -
+    scr_set                     Y       Y       -
+
+
+
+--------------------------------------------------------------------------
+
+
+scroll
+------
+
+### Synopsis
+
+    int scroll(WINDOW *win);
+    int scrl(int n);
+    int wscrl(WINDOW *win, int n);
+
+### Description
+
+   scroll() causes the window to scroll up one line. This involves
+   moving the lines in the window data strcture.
+
+   With a positive n, scrl() and wscrl() scroll the window up n lines
+   (line i + n becomes i); otherwise they scroll the window down n
+   lines.
+
+   For these functions to work, scrolling must be enabled via
+   scrollok(). Note also that scrolling is not allowed if the supplied
+   window is a pad.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    scroll                      Y       Y       Y
+    scrl                        Y       Y       Y
+    wscrl                       Y       Y       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+slk
+---
+
+### Synopsis
+
+    int slk_init(int fmt);
+    int slk_set(int labnum, const char *label, int justify);
+    int slk_refresh(void);
+    int slk_noutrefresh(void);
+    char *slk_label(int labnum);
+    int slk_clear(void);
+    int slk_restore(void);
+    int slk_touch(void);
+    int slk_attron(const chtype attrs);
+    int slk_attr_on(const attr_t attrs, void *opts);
+    int slk_attrset(const chtype attrs);
+    int slk_attr_set(const attr_t attrs, short color_pair, void *opts);
+    int slk_attroff(const chtype attrs);
+    int slk_attr_off(const attr_t attrs, void *opts);
+    int slk_color(short color_pair);
+
+    int slk_wset(int labnum, const wchar_t *label, int justify);
+
+    int PDC_mouse_in_slk(int y, int x);
+    void PDC_slk_free(void);
+    void PDC_slk_initialize(void);
+
+    wchar_t *slk_wlabel(int labnum)
+
+### Description
+
+   These functions manipulate a window that contain Soft Label Keys
+   (SLK). To use the SLK functions, a call to slk_init() must be made
+   BEFORE initscr() or newterm(). slk_init() removes 1 or 2 lines from
+   the useable screen, depending on the format selected.
+
+   The line(s) removed from the screen are used as a separate window, in
+   which SLKs are displayed.
+
+   slk_init() requires a single parameter which describes the format of
+   the SLKs as follows:
+
+   0       3-2-3 format
+   1       4-4 format
+   2       4-4-4 format (ncurses extension)
+   3       4-4-4 format with index line (ncurses extension)
+   2 lines used
+   55      5-5 format (pdcurses format)
+
+   In PDCurses,  one can alternatively set fmt as a series of hex
+   digits specifying the format.  For example,  0x414 would result
+   in 4-1-4 format; 0x21b3 would result in 2-1-11-3 format;  and
+   so on.  Also,  negating fmt results in the index line being added.
+
+   Also,  in PDCurses,  one can call slk_init() at any time
+   _after_ initscr(),  to reset the label format.  If you do this,
+   you'll need to reset the label text and call slk_refresh().  However,
+   you can't toggle the index line or turn SLK on or off after initscr()
+   has been called.  Doing so would add/remove a line or two from the
+   useable screen,  which would be difficult to handle correctly.
+
+   slk_refresh(), slk_noutrefresh() and slk_touch() are analogous to
+   refresh(), noutrefresh() and touch().
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    slk_init                    Y       Y       Y
+    slk_set                     Y       Y       Y
+    slk_refresh                 Y       Y       Y
+    slk_noutrefresh             Y       Y       Y
+    slk_label                   Y       Y       Y
+    slk_clear                   Y       Y       Y
+    slk_restore                 Y       Y       Y
+    slk_touch                   Y       Y       Y
+    slk_attron                  Y       Y       Y
+    slk_attrset                 Y       Y       Y
+    slk_attroff                 Y       Y       Y
+    slk_attr_on                 Y       Y       Y
+    slk_attr_set                Y       Y       Y
+    slk_attr_off                Y       Y       Y
+    slk_wset                    Y       Y       Y
+    PDC_mouse_in_slk            -       -       -
+    PDC_slk_free                -       -       -
+    PDC_slk_initialize          -       -       -
+    slk_wlabel                  -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+termattr
+--------
+
+### Synopsis
+
+    int baudrate(void);
+    char erasechar(void);
+    bool has_ic(void);
+    bool has_il(void);
+    char killchar(void);
+    char *longname(void);
+    chtype termattrs(void);
+    attr_t term_attrs(void);
+    char *termname(void);
+
+    int erasewchar(wchar_t *ch);
+    int killwchar(wchar_t *ch);
+
+    char wordchar(void);
+
+### Description
+
+   baudrate() is supposed to return the output speed of the terminal. In
+   PDCurses, it simply returns INT_MAX.
+
+   has_ic and has_il() return TRUE. These functions have meaning in some
+   other implementations of curses.
+
+   erasechar() and killchar() return ^H and ^U, respectively -- the
+   ERASE and KILL characters. In other curses implementations, these may
+   vary by terminal type. erasewchar() and killwchar() are the wide-
+   character versions; they take a pointer to a location in which to
+   store the character, and return OK or ERR.
+
+   longname() returns a pointer to a static area containing a verbose
+   description of the current terminal. The maximum length of the string
+   is 128 characters. It is defined only after the call to initscr() or
+   newterm().
+
+   termname() returns a pointer to a static area containing a short
+   description of the current terminal (14 characters).
+
+   termattrs() returns a logical OR of all video attributes supported by
+   the terminal.
+
+   wordchar() is a PDCurses extension of the concept behind the
+   functions erasechar() and killchar(), returning the "delete word"
+   character, ^W.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    baudrate                    Y       Y       Y
+    erasechar                   Y       Y       Y
+    has_ic                      Y       Y       Y
+    has_il                      Y       Y       Y
+    killchar                    Y       Y       Y
+    longname                    Y       Y       Y
+    termattrs                   Y       Y       Y
+    termname                    Y       Y       Y
+    erasewchar                  Y       Y       Y
+    killwchar                   Y       Y       Y
+    term_attrs                  Y       Y       Y
+    wordchar                    -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+touch
+-----
+
+### Synopsis
+
+    int touchwin(WINDOW *win);
+    int touchline(WINDOW *win, int start, int count);
+    int untouchwin(WINDOW *win);
+    int wtouchln(WINDOW *win, int y, int n, int changed);
+    bool is_linetouched(WINDOW *win, int line);
+    bool is_wintouched(WINDOW *win);
+
+    int touchoverlap(const WINDOW *win1, WINDOW *win2);
+
+### Description
+
+   touchwin() and touchline() throw away all information about which
+   parts of the window have been touched, pretending that the entire
+   window has been drawn on. This is sometimes necessary when using
+   overlapping windows, since a change to one window will affect the
+   other window, but the records of which lines have been changed in the
+   other window will not reflect the change.
+
+   untouchwin() marks all lines in the window as unchanged since the
+   last call to wrefresh().
+
+   wtouchln() makes n lines in the window, starting at line y, look as
+   if they have (changed == 1) or have not (changed == 0) been changed
+   since the last call to wrefresh().
+
+   is_linetouched() returns TRUE if the specified line in the specified
+   window has been changed since the last call to wrefresh().
+
+   is_wintouched() returns TRUE if the specified window has been changed
+   since the last call to wrefresh().
+
+   touchoverlap(win1, win2) marks the portion of win2 which overlaps
+   with win1 as modified.
+
+### Return Value
+
+   All functions return OK on success and ERR on error except
+   is_wintouched() and is_linetouched().
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    touchwin                    Y       Y       Y
+    touchline                   Y       Y       Y
+    untouchwin                  Y       Y       Y
+    wtouchln                    Y       Y       Y
+    is_linetouched              Y       Y       Y
+    is_wintouched               Y       Y       Y
+    touchoverlap                -       -       Y
+
+
+
+--------------------------------------------------------------------------
+
+
+util
+----
+
+### Synopsis
+
+    char *unctrl(chtype c);
+    void filter(void);
+    void use_env(bool x);
+    int delay_output(int ms);
+
+    int getcchar(const cchar_t *wcval, wchar_t *wch, attr_t *attrs,
+                 short *color_pair, void *opts);
+    int setcchar(cchar_t *wcval, const wchar_t *wch, const attr_t attrs,
+                 short color_pair, const void *opts);
+    wchar_t *wunctrl(cchar_t *wc);
+
+    int PDC_mbtowc(wchar_t *pwc, const char *s, size_t n);
+    size_t PDC_mbstowcs(wchar_t *dest, const char *src, size_t n);
+    size_t PDC_wcstombs(char *dest, const wchar_t *src, size_t n);
+
+### Description
+
+   unctrl() expands the text portion of the chtype c into a printable
+   string. Control characters are changed to the "^X" notation; others
+   are passed through. wunctrl() is the wide-character version of the
+   function.
+
+   filter() and use_env() are no-ops in PDCurses.
+
+   delay_output() inserts an ms millisecond pause in output.
+
+   getcchar() works in two modes: When wch is not NULL, it reads the
+   cchar_t pointed to by wcval and stores the attributes in attrs, the
+   color pair in color_pair, and the text in the wide-character string
+   wch. When wch is NULL, getcchar() merely returns the number of wide
+   characters in wcval. In either mode, the opts argument is unused.
+
+   setcchar constructs a cchar_t at wcval from the wide-character text
+   at wch, the attributes in attr and the color pair in color_pair. The
+   opts argument is unused.
+
+   Currently, the length returned by getcchar() is always 1 or 0.
+   Similarly, setcchar() will only take the first wide character from
+   wch, and ignore any others that it "should" take (i.e., combining
+   characters). Nor will it correctly handle any character outside the
+   basic multilingual plane (UCS-2).
+
+### Return Value
+
+   wunctrl() returns NULL on failure. delay_output() always returns OK.
+
+   getcchar() returns the number of wide characters wcval points to when
+   wch is NULL; when it's not, getcchar() returns OK or ERR.
+
+   setcchar() returns OK or ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    unctrl                      Y       Y       Y
+    filter                      Y       Y       Y
+    use_env                     Y       Y       Y
+    delay_output                Y       Y       Y
+    getcchar                    Y       Y       Y
+    setcchar                    Y       Y       Y
+    wunctrl                     Y       Y       Y
+    PDC_mbtowc                  -       -       -
+    PDC_mbstowcs                -       -       -
+    PDC_wcstombs                -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+window
+------
+
+### Synopsis
+
+    WINDOW *newwin(int nlines, int ncols, int begy, int begx);
+    WINDOW *derwin(WINDOW* orig, int nlines, int ncols,
+                   int begy, int begx);
+    WINDOW *subwin(WINDOW* orig, int nlines, int ncols,
+                   int begy, int begx);
+    WINDOW *dupwin(WINDOW *win);
+    int delwin(WINDOW *win);
+    int mvwin(WINDOW *win, int y, int x);
+    int mvderwin(WINDOW *win, int pary, int parx);
+    int syncok(WINDOW *win, bool bf);
+    void wsyncup(WINDOW *win);
+    void wcursyncup(WINDOW *win);
+    void wsyncdown(WINDOW *win);
+
+    WINDOW *resize_window(WINDOW *win, int nlines, int ncols);
+    int wresize(WINDOW *win, int nlines, int ncols);
+    WINDOW *PDC_makelines(WINDOW *win);
+    WINDOW *PDC_makenew(int nlines, int ncols, int begy, int begx);
+    void PDC_sync(WINDOW *win);
+
+### Description
+
+   newwin() creates a new window with the given number of lines, nlines
+   and columns, ncols. The upper left corner of the window is at line
+   begy, column begx. If nlines is zero, it defaults to LINES - begy;
+   ncols to COLS - begx. Create a new full-screen window by calling
+   newwin(0, 0, 0, 0).
+
+   delwin() deletes the named window, freeing all associated memory. In
+   the case of overlapping windows, subwindows should be deleted before
+   the main window.
+
+   mvwin() moves the window so that the upper left-hand corner is at
+   position (y,x). If the move would cause the window to be off the
+   screen, it is an error and the window is not moved. Moving subwindows
+   is allowed.
+
+   subwin() creates a new subwindow within a window. The dimensions of
+   the subwindow are nlines lines and ncols columns. The subwindow is at
+   position (begy, begx) on the screen. This position is relative to the
+   screen, and not to the window orig. Changes made to either window
+   will affect both. When using this routine, you will often need to
+   call touchwin() before calling wrefresh().
+
+   derwin() is the same as subwin(), except that begy and begx are
+   relative to the origin of the window orig rather than the screen.
+   There is no difference between subwindows and derived windows.
+
+   mvderwin() moves a derived window (or subwindow) inside its parent
+   window. The screen-relative parameters of the window are not changed.
+   This routine is used to display different parts of the parent window
+   at the same physical position on the screen.
+
+   dupwin() creates an exact duplicate of the window win.
+
+   wsyncup() causes a touchwin() of all of the window's parents.
+
+   If wsyncok() is called with a second argument of TRUE, this causes a
+   wsyncup() to be called every time the window is changed.
+
+   wcursyncup() causes the current cursor position of all of a window's
+   ancestors to reflect the current cursor position of the current
+   window.
+
+   wsyncdown() causes a touchwin() of the current window if any of its
+   parent's windows have been touched.
+
+   resize_window() allows the user to resize an existing window. It
+   returns the pointer to the new window, or NULL on failure.
+
+   wresize() is an ncurses-compatible wrapper for resize_window(). Note
+   that, unlike ncurses, it will NOT process any subwindows of the
+   window. (However, you still can call it _on_ subwindows.) It returns
+   OK or ERR.
+
+   PDC_makenew() allocates all data for a new WINDOW * except the actual
+   lines themselves. If it's unable to allocate memory for the window
+   structure, it will free all allocated memory and return a NULL
+   pointer.
+
+   PDC_makelines() allocates the memory for the lines.
+
+   PDC_sync() handles wrefresh() and wsyncup() calls when a window is
+   changed.
+
+### Return Value
+
+   newwin(), subwin(), derwin() and dupwin() return a pointer to the new
+   window, or NULL on failure. delwin(), mvwin(), mvderwin() and
+   syncok() return OK or ERR. wsyncup(), wcursyncup() and wsyncdown()
+   return nothing.
+
+### Errors
+
+   It is an error to call resize_window() before calling initscr().
+   Also, an error will be generated if we fail to create a newly sized
+   replacement window for curscr, or stdscr. This could happen when
+   increasing the window size. NOTE: If this happens, the previously
+   successfully allocated windows are left alone; i.e., the resize is
+   NOT cancelled for those windows.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    newwin                      Y       Y       Y
+    delwin                      Y       Y       Y
+    mvwin                       Y       Y       Y
+    subwin                      Y       Y       Y
+    derwin                      Y       Y       Y
+    mvderwin                    Y       Y       Y
+    dupwin                      Y       Y       Y
+    wsyncup                     Y       Y       Y
+    syncok                      Y       Y       Y
+    wcursyncup                  Y       Y       Y
+    wsyncdown                   Y       Y       Y
+    wresize                     -       Y       Y
+    resize_window               -       -       -
+    PDC_makelines               -       -       -
+    PDC_makenew                 -       -       -
+    PDC_sync                    -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+clipboard
+---------
+
+### Synopsis
+
+    int PDC_getclipboard(char **contents, long *length);
+    int PDC_setclipboard(const char *contents, long length);
+    int PDC_freeclipboard(char *contents);
+    int PDC_clearclipboard(void);
+
+### Description
+
+   PDC_getclipboard() gets the textual contents of the system's
+   clipboard. This function returns the contents of the clipboard in the
+   contents argument. It is the responsibility of the caller to free the
+   memory returned, via PDC_freeclipboard(). The length of the clipboard
+   contents is returned in the length argument.
+
+   PDC_setclipboard copies the supplied text into the system's
+   clipboard, emptying the clipboard prior to the copy.
+
+   PDC_clearclipboard() clears the internal clipboard.
+
+### Return Values
+
+   indicator of success/failure of call.
+   PDC_CLIP_SUCCESS        the call was successful
+   PDC_CLIP_MEMORY_ERROR   unable to allocate sufficient memory for
+                           the clipboard contents
+   PDC_CLIP_EMPTY          the clipboard contains no text
+   PDC_CLIP_ACCESS_ERROR   no clipboard support
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    PDC_getclipboard            -       -       -
+    PDC_setclipboard            -       -       -
+    PDC_freeclipboard           -       -       -
+    PDC_clearclipboard          -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+Function keys
+-------------
+
+### Synopsis
+
+   int PDC_set_function_key( const unsigned function, const int new_key);
+
+### Description
+
+   Allows one to set a 'shut down' key,  and reassign hotkeys used for
+   pasting from the clipboard and enlarging and decreasing the font size,
+   and for using the font selection dialog (on platforms where these
+   things are possible and implemented).  For example, calling
+
+   PDC_set_function_key( FUNCTION_KEY_SHUT_DOWN, ALT_Q);
+
+   would reset PDCurses such that,  if the user clicks on the 'close' box,
+   Alt-Q would be added to the key queue.  This would give the app the
+   opportunity to shut things down gracefully,  perhaps asking "are you
+   sure",  and/or "save changes or discard or cancel",  rather than just
+   having the window close (the default behavior).
+
+   Similarly,  one can set FUNCTION_KEY_ABORT to a key which,  when pressed,
+   will cause the program to abort gracelessly (no key returned to the
+   application).  One would normally use this to enable/disable Ctrl-C or
+   Ctrl-Break.
+
+### Return Value
+
+   Returns key code previously set for that function,  or -1 if the
+   function does not actually exist.
+
+### Portability
+
+   PDCurses-only function.
+
+
+
+--------------------------------------------------------------------------
+
+
+Resize limits
+-------------
+
+### Synopsis
+
+    void PDC_set_resize_limits( const int new_min_lines,
+                                const int new_max_lines,
+                                const int new_min_cols,
+                                const int new_max_cols);
+
+### Description
+
+   For platforms supporting resizable windows (SDLx, WinGUI, X11).  Some
+   programs may be unprepared for a resize event;  for these,  calling
+   this function with the max and min limits equal ensures that no
+   user resizing can be done.  Other programs may require at least a
+   certain number,  and/or no more than a certain number,  of columns
+   and/or lines.
+
+### Portability
+
+   PDCurses-only function.
+
+
+
+--------------------------------------------------------------------------
+
+
+pdcsetsc
+--------
+
+### Synopsis
+
+    int PDC_set_blink(bool blinkon);
+    int PDC_set_bold(bool boldon);
+    void PDC_set_title(const char *title);
+
+### Description
+
+   PDC_set_blink() toggles whether the A_BLINK attribute sets an actual
+   blink mode (TRUE), or sets the background color to high intensity
+   (FALSE). The default is platform-dependent (FALSE in most cases). It
+   returns OK if it could set the state to match the given parameter,
+   ERR otherwise.
+
+   PDC_set_bold() toggles whether the A_BOLD attribute selects an actual
+   bold font (TRUE), or sets the foreground color to high intensity
+   (FALSE). It returns OK if it could set the state to match the given
+   parameter, ERR otherwise.
+
+   PDC_set_title() sets the title of the window in which the curses
+   program is running. This function may not do anything on some
+   platforms.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    PDC_set_blink               -       -       -
+    PDC_set_title               -       -       -
+
+
+
+--------------------------------------------------------------------------
+
+
+sb
+--
+
+### Synopsis
+
+    int sb_init(void)
+    int sb_set_horz(int total, int viewport, int cur)
+    int sb_set_vert(int total, int viewport, int cur)
+    int sb_get_horz(int *total, int *viewport, int *cur)
+    int sb_get_vert(int *total, int *viewport, int *cur)
+    int sb_refresh(void);
+
+### Description
+
+   These functions manipulate the scrollbar.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    sb_init                     -       -       -
+    sb_set_horz                 -       -       -
+    sb_set_vert                 -       -       -
+    sb_get_horz                 -       -       -
+    sb_get_vert                 -       -       -
+    sb_refresh                  -       -       -
+
+
+
+--------------------------------------------------------------------------
+
diff --git a/lib/PDCursesMod/docs/README.md b/lib/PDCursesMod/docs/README.md
new file mode 100644
index 00000000000..3a96ff6d9ca
--- /dev/null
+++ b/lib/PDCursesMod/docs/README.md
@@ -0,0 +1,45 @@
+PDCurses Documentation
+======================
+
+The main documentation for PDCurses is here:
+
+- [User's Guide] - Basic overview
+- [Implementor's Guide] - What you need to know to port PDCurses
+- [Manual] - Each function, etc.
+- [History]
+
+Also consult the README for each specific platform you'll be using:
+
+- [DOS]
+- [OS/2]
+- [SDL 1.x]
+- [SDL 2.x]
+- [Windows]
+- [X11]
+
+This directory also contains the files, CNAME and index.html, that
+create pdcurses.org, via GitHub.
+
+
+Building
+--------
+
+- To rebuild MANUAL.md from the "man page" sections of the source code,
+  type "./mkman.sh". Needs a Unix-like shell and a Python interpreter.
+
+
+Distribution Status
+-------------------
+
+The files in this directory are released to the public domain.
+
+[User's Guide]: USERS.md
+[Implementor's Guide]: IMPLEMNT.md
+[Manual]: MANUAL.md
+[History]: HISTORY.md
+[DOS]: ../dos/README.md
+[OS/2]: ../os2/README.md
+[SDL 1.x]: ../sdl1/README.md
+[SDL 2.x]: ../sdl2/README.md
+[Windows]: ../wincon/README.md
+[X11]: ../x11/README.md
diff --git a/lib/PDCursesMod/docs/USERS.md b/lib/PDCursesMod/docs/USERS.md
new file mode 100644
index 00000000000..1778fbe7546
--- /dev/null
+++ b/lib/PDCursesMod/docs/USERS.md
@@ -0,0 +1,359 @@
+PDCurses User's Guide
+=====================
+
+Curses Overview
+---------------
+
+The X/Open Curses Interface Definition describes a set of C-Language
+functions that provide screen-handling and updating, which are
+collectively known as the curses library.
+
+The curses library permits manipulation of data structures called
+windows which may be thought of as two-dimensional arrays of
+characters representing all or part of a terminal's screen.  The
+windows are manipulated using a procedural interface described
+[elsewhere].  The curses package maintains a record of what characters
+are on the screen.  At the most basic level, manipulation is done with
+the routines move() and addch() which are used to "move" the curses
+around and add characters to the default window, stdscr, which
+represents the whole screen.
+
+An application may use these routines to add data to the window in any
+convenient order.  Once all data have been added, the routine
+refresh() is called.  The package then determines what changes have
+been made which affect the screen.  The screen contents are then
+changed to reflect those characters now in the window, using a
+sequence of operations optimized for the type of terminal in use.
+
+At a higher level routines combining the actions of move() and addch()
+are defined, as are routines to add whole strings and to perform
+format conversions in the manner of printf().
+
+Interfaces are also defined to erase the entire window and to specify
+the attributes of individual characters in the window.  Attributes
+such as inverse video, underline and blink can be used on a
+per-character basis.
+
+New windows can be created by allowing the application to build
+several images of the screen and display the appropriate one very
+quickly.  New windows are created using the routine newwin().  For
+each routine that manipulates the default window, stdscr, there is a
+corresponding routine prefixed with w to manipulate the contents of a
+specified window; for example, move() and wmove().  In fact, move(...)
+is functionally equivalent to wmove( stdscr, ...).  This is similar to
+the interface offered by printf(...) and fprintf(stdout, ...).
+
+Windows do not have to correspond to the entire screen.  It is
+possible to create smaller windows, and also to indicate that the
+window is only partially visible on the screen.  Furthermore, large
+windows or pads, which are bigger than the actual screen size, may be
+created.
+
+Interfaces are also defined to allow input character manipulation and
+to disable and enable many input attributes: character echo, single
+character input with or without signal processing (cbreak or raw
+modes), carriage returns mapping to newlines, screen scrolling, etc.
+
+
+Data Types and the \<curses.h\> Header
+--------------------------------------
+
+The data types supported by curses are described in this section.
+
+As the library supports a procedural interface to the data types, actual
+structure contents are not described.  All curses data are manipulated
+using the routines provided.
+
+
+### The \<curses.h\> Header
+
+The \<curses.h\> header defines various constants and declares the data
+types that are available to the application.
+
+
+### Data Types
+
+The following data types are declared:
+
+    WINDOW *  pointer to screen representation
+    SCREEN *  pointer to terminal descriptor
+    bool      boolean data type
+    chtype    representation of a character in a window
+    cchar_t   the wide-character equivalent of chtype
+    attr_t    for WA_-style attributes
+
+The actual WINDOW and SCREEN objects used to store information are
+created by the corresponding routines and a pointer to them is provided.
+All manipulation is through that pointer.
+
+
+### Variables
+
+The following variables are defined:
+
+    LINES         number of lines on terminal screen
+    COLS          number of columns on terminal screen
+    stdscr        pointer to the default screen window
+    curscr        pointer to the current screen image
+    SP            pointer to the current SCREEN struct
+    Mouse_status  status of the mouse
+    COLORS        number of colors available
+    COLOR_PAIRS   number of color pairs available
+    TABSIZE       size of one TAB block
+    acs_map[]     alternate character set map
+    ttytype[]     terminal name/description
+
+
+### Constants
+
+The following constants are defined:
+
+#### General
+
+    FALSE         boolean false value
+    TRUE          boolean true value
+    NULL          zero pointer value
+    ERR           value returned on error condition
+    OK            value returned on successful completion
+
+#### Video Attributes
+
+Normally, attributes are a property of the character.
+
+For chtype:
+
+    A_ALTCHARSET  use the alternate character set
+    A_BLINK       bright background or blinking
+    A_BOLD        bright foreground or bold
+    A_DIM         half bright -- no effect in PDCurses
+    A_INVIS       invisible -- no effect in PDCurses
+    A_ITALIC      italic
+    A_LEFT        line along the left edge
+    A_PROTECT     protected -- no effect in PDCurses
+    A_REVERSE     reverse video
+    A_RIGHT       line along the right edge
+    A_STANDOUT    terminal's best highlighting mode
+    A_UNDERLINE   underline
+
+    A_ATTRIBUTES  bit-mask to extract attributes
+    A_CHARTEXT    bit-mask to extract a character
+    A_COLOR       bit-mask to extract a color-pair
+
+Not all attributes will work on all terminals. A_ITALIC is not standard,
+but is shared with ncurses.
+
+For attr_t:
+
+    WA_ALTCHARSET same as A_ALTCHARSET
+    WA_BLINK      same as A_BLINK
+    WA_BOLD       same as A_BOLD
+    WA_DIM        same as A_DIM
+    WA_INVIS      same as A_INVIS
+    WA_ITALIC     same as A_ITALIC
+    WA_LEFT       same as A_LEFT
+    WA_PROTECT    same as A_PROTECT
+    WA_REVERSE    same as A_REVERSE
+    WA_RIGHT      same as A_RIGHT
+    WA_STANDOUT   same as A_STANDOUT
+    WA_UNDERLINE  same as A_UNDERLINE
+
+The following are also defined, for compatibility, but currently have no
+effect in PDCurses: A_HORIZONTAL, A_LOW, A_TOP, A_VERTICAL and their
+WA_* equivalents.
+
+### The Alternate Character Set
+
+For use in chtypes and with related functions. These are a portable way
+to represent graphics characters on different terminals.
+
+VT100-compatible symbols -- box characters:
+
+    ACS_ULCORNER  upper left box corner
+    ACS_LLCORNER  lower left box corner
+    ACS_URCORNER  upper right box corner
+    ACS_LRCORNER  lower right box corner
+    ACS_RTEE      right "T"
+    ACS_LTEE      left "T"
+    ACS_BTEE      bottom "T"
+    ACS_TTEE      top "T"
+    ACS_HLINE     horizontal line
+    ACS_VLINE     vertical line
+    ACS_PLUS      plus sign, cross, or four-corner piece
+
+VT100-compatible symbols -- other:
+
+    ACS_S1        scan line 1
+    ACS_S9        scan line 9
+    ACS_DIAMOND   diamond
+    ACS_CKBOARD   checkerboard -- 50% grey
+    ACS_DEGREE    degree symbol
+    ACS_PLMINUS   plus/minus sign
+    ACS_BULLET    bullet
+
+Teletype 5410v1 symbols -- these are defined in SysV curses, but are not
+well-supported by most terminals. Stick to VT100 characters for optimum
+portability:
+
+    ACS_LARROW    left arrow
+    ACS_RARROW    right arrow
+    ACS_DARROW    down arrow
+    ACS_UARROW    up arrow
+    ACS_BOARD     checkerboard -- lighter (less dense) than
+                  ACS_CKBOARD
+    ACS_LANTERN   lantern symbol
+    ACS_BLOCK     solid block
+
+That goes double for these -- undocumented SysV symbols. Don't use them:
+
+    ACS_S3        scan line 3
+    ACS_S7        scan line 7
+    ACS_LEQUAL    less than or equal
+    ACS_GEQUAL    greater than or equal
+    ACS_PI        pi
+    ACS_NEQUAL    not equal
+    ACS_STERLING  pounds sterling symbol
+
+Box character aliases:
+
+    ACS_BSSB      same as ACS_ULCORNER
+    ACS_SSBB      same as ACS_LLCORNER
+    ACS_BBSS      same as ACS_URCORNER
+    ACS_SBBS      same as ACS_LRCORNER
+    ACS_SBSS      same as ACS_RTEE
+    ACS_SSSB      same as ACS_LTEE
+    ACS_SSBS      same as ACS_BTEE
+    ACS_BSSS      same as ACS_TTEE
+    ACS_BSBS      same as ACS_HLINE
+    ACS_SBSB      same as ACS_VLINE
+    ACS_SSSS      same as ACS_PLUS
+
+For cchar_t and wide-character functions, WACS_ equivalents are also
+defined.
+
+### Colors
+
+For use with init_pair(), color_set(), etc.:
+
+    COLOR_BLACK
+    COLOR_BLUE
+    COLOR_GREEN
+    COLOR_CYAN
+    COLOR_RED
+    COLOR_MAGENTA
+    COLOR_YELLOW
+    COLOR_WHITE
+
+Use these instead of numeric values. The definition of the colors
+depends on the implementation of curses.
+
+
+### Input Values
+
+The following constants might be returned by getch() if keypad() has
+been enabled.  Note that not all of these may be supported on a
+particular terminal:
+
+    KEY_BREAK     break key
+    KEY_DOWN      the four arrow keys
+    KEY_UP
+    KEY_LEFT
+    KEY_RIGHT
+    KEY_HOME      home key (upward+left arrow)
+    KEY_BACKSPACE backspace
+    KEY_F0        function keys; space for 64 keys is reserved
+    KEY_F(n)      (KEY_F0+(n))
+    KEY_DL        delete line
+    KEY_IL        insert line
+    KEY_DC        delete character
+    KEY_IC        insert character
+    KEY_EIC       exit insert character mode
+    KEY_CLEAR     clear screen
+    KEY_EOS       clear to end of screen
+    KEY_EOL       clear to end of line
+    KEY_SF        scroll 1 line forwards
+    KEY_SR        scroll 1 line backwards (reverse)
+    KEY_NPAGE     next page
+    KEY_PPAGE     previous page
+    KEY_STAB      set tab
+    KEY_CTAB      clear tab
+    KEY_CATAB     clear all tabs
+    KEY_ENTER     enter or send
+    KEY_SRESET    soft (partial) reset
+    KEY_RESET     reset or hard reset
+    KEY_PRINT     print or copy
+    KEY_LL        home down or bottom (lower left)
+    KEY_A1        upper left of virtual keypad
+    KEY_A3        upper right of virtual keypad
+    KEY_B2        center of virtual keypad
+    KEY_C1        lower left of virtual keypad
+    KEY_C3        lower right of virtual keypad
+
+    KEY_BTAB      Back tab key
+    KEY_BEG       Beginning key
+    KEY_CANCEL    Cancel key
+    KEY_CLOSE     Close key
+    KEY_COMMAND   Cmd (command) key
+    KEY_COPY      Copy key
+    KEY_CREATE    Create key
+    KEY_END       End key
+    KEY_EXIT      Exit key
+    KEY_FIND      Find key
+    KEY_HELP      Help key
+    KEY_MARK      Mark key
+    KEY_MESSAGE   Message key
+    KEY_MOVE      Move key
+    KEY_NEXT      Next object key
+    KEY_OPEN      Open key
+    KEY_OPTIONS   Options key
+    KEY_PREVIOUS  Previous object key
+    KEY_REDO      Redo key
+    KEY_REFERENCE Reference key
+    KEY_REFRESH   Refresh key
+    KEY_REPLACE   Replace key
+    KEY_RESTART   Restart key
+    KEY_RESUME    Resume key
+    KEY_SAVE      Save key
+    KEY_SBEG      Shifted beginning key
+    KEY_SCANCEL   Shifted cancel key
+    KEY_SCOMMAND  Shifted command key
+    KEY_SCOPY     Shifted copy key
+    KEY_SCREATE   Shifted create key
+    KEY_SDC       Shifted delete char key
+    KEY_SDL       Shifted delete line key
+    KEY_SELECT    Select key
+    KEY_SEND      Shifted end key
+    KEY_SEOL      Shifted clear line key
+    KEY_SEXIT     Shifted exit key
+    KEY_SFIND     Shifted find key
+    KEY_SHELP     Shifted help key
+    KEY_SHOME     Shifted home key
+    KEY_SIC       Shifted input key
+    KEY_SLEFT     Shifted left arrow key
+    KEY_SMESSAGE  Shifted message key
+    KEY_SMOVE     Shifted move key
+    KEY_SNEXT     Shifted next key
+    KEY_SOPTIONS  Shifted options key
+    KEY_SPREVIOUS Shifted prev key
+    KEY_SPRINT    Shifted print key
+    KEY_SREDO     Shifted redo key
+    KEY_SREPLACE  Shifted replace key
+    KEY_SRIGHT    Shifted right arrow
+    KEY_SRSUME    Shifted resume key
+    KEY_SSAVE     Shifted save key
+    KEY_SSUSPEND  Shifted suspend key
+    KEY_SUNDO     Shifted undo key
+    KEY_SUSPEND   Suspend key
+    KEY_UNDO      Undo key
+
+The virtual keypad is arranged like this:
+
+    A1     up     A3
+    left   B2  right
+    C1    down    C3
+
+This list is incomplete -- see curses.h for the full list, and use the
+testcurs demo to see what values are actually returned. The above are
+just the keys required by X/Open. In particular, PDCurses defines many
+CTL_ and ALT_ combinations; these are not portable.
+
+[elsewhere]: MANUAL.md
diff --git a/lib/PDCursesMod/docs/index.html b/lib/PDCursesMod/docs/index.html
new file mode 100644
index 00000000000..1552fd2385d
--- /dev/null
+++ b/lib/PDCursesMod/docs/index.html
@@ -0,0 +1,112 @@
+<!DOCTYPE html>
+
+<html lang="en">
+
+<head>
+<meta charset="utf-8">
+<meta name="keys" content="curses, text, user, interface, public,
+domain, free">
+<link rel="icon"
+href="data:image/x-icon;base64,AAABAAEAEBAQAAAAAAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCAAAAa54AAGoAAABq0wAAiAAAAP//AAD7HwAA+t8AAPrfAAD7XwAA+Z8AAPrfAAD7XwAA+18AAPjfAAD//wAA"
+type="image/x-icon">
+<style>
+
+body { color: black; background: white; font-family: Helvetica, sans-serif }
+html, body, div#navbar { height: 100%; margin: 0; padding: 0 }
+
+a { text-decoration: none }
+
+a:link { color: blue; background: white }
+a:visited { color: navy; background: white }
+a:hover { color: red; background: #ffc; text-decoration: underline }
+a[name]:hover { color: black; background: #ccf }
+
+img { border: 0 }
+
+div#navbar { color: black; background: #ccf }
+div#navbar { width: 8em; position: fixed; overflow: auto; top: 0; left: 0 }
+div#navbar ul { margin: 0; padding: 0 }
+div#navbar li { display: block; margin: .3em; padding: 0 }
+div#navbar li a { display: block; font-size: small; margin: 0; padding: .15em }
+
+div#maincontent { margin-left: 8em; padding: .5em }
+div#maincontent ul { list-style: none }
+div#maincontent ul li { margin: .3em; padding: .15em }
+div#maincontent ul li a { font-weight: bold }
+
+h2 { border-bottom: 2px solid #ccf; font-size: large }
+
+div#toplogo { text-align: center; margin-top: 1em; margin-bottom: 1em }
+
+address { border-top: 1px dotted; padding-top: 3px }
+
+hr { display: none }
+
+table, th, td { border: 1px dotted }
+td, th { text-align: left; padding-left: .15em }
+th { font-weight: bold; padding-right: .15em }
+td { padding-left: .5em }
+
+</style>
+<title>PDCurses</title>
+</head>
+
+<body>
+
+<div id="maincontent">
+
+<h1>PDCurses</h1>
+
+Stable: <a href="https://github.com/wmcbrine/PDCurses/releases/tag/3.9">v3.9</a><br>
+Beta: <a href="https://github.com/wmcbrine/PDCurses">See git repository</a>
+
+<p><strong>PDCurses</strong> is a public domain curses library for DOS,
+OS/2, Windows console, X11 and SDL, implementing most of the functions
+available in X/Open and System V R4 curses. It supports many compilers
+for these platforms. The X11 port lets you recompile existing text-mode
+curses programs to produce native X11 applications.</p>
+
+<p>PDCurses is distributed mainly as source code, but some pre-compiled
+libraries may be available. See the <a
+href="https://sourceforge.net/projects/pdcurses/files/">
+downloads page</a> for a list.</p>
+
+<p>There's a low-traffic mailing list for announcements and discussion.
+To subscribe, email the <a href="mailto:majordomo@lightlink.com">list
+server</a>, with the first line of the body of the message containing:</p>
+
+<p>subscribe pdcurses-l</p>
+
+<p>or you can read <a
+href="https://www.mail-archive.com/pdcurses-l@lightlink.com/">the mailing
+list archive.</a></p>
+
+<hr>
+
+<address>
+Page by Mark Hessling and <a
+href="https://wmcbrine.com/">William McBrine.</a>
+Last updated: Sep 4 2019
+</address>
+
+</div>
+
+<hr>
+
+<div id="navbar">
+
+<div id="toplogo"><img
+src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAQMAAACQp+OdAAAABlBMVEX///8AAABVwtN+AAAAAXRSTlMAQObYZgAAAL1JREFUeNpjYKAU8P9nPgBlNMMYh9EZzI+hDEYiGHDF7DDt/MehDPl+KMNeHsqos4cy/tRDGT/+Qxkff0MZjz9DGcdhJvfDTYa5WR7mCzkiGHDF/P/RGewwBjOUQRgwH+GqsONnP8DAlsJ1JlmyJ4GBx4S77eCGGwYMHCLcTA0LAgQYOFi4GOCMAwoRDGBGgoIPhGFnDwwhEINZgSEBzGBcwGCApEsEyuAxk2IAm8yWbMQAtov54CMGsO1kAQCEsFSCjn+sOQAAAABJRU5ErkJggg=="
+width="64" height="64" alt="PDCurses"></div>
+
+<ul>
+<li><a href="https://github.com/wmcbrine/PDCurses/blob/master/docs/README.md">Docs</a></li>
+<li><a href="https://github.com/wmcbrine/PDCurses">GitHub Page</a></li>
+<li><a href="https://sourceforge.net/projects/pdcurses">SourceForge Page</a></li>
+<li><a href="https://pubs.opengroup.org/onlinepubs/007908799/cursesix.html">X/Open Curses</a></li>
+</ul>
+
+</div>
+
+</body>
+</html>
diff --git a/lib/PDCursesMod/docs/manext.awk b/lib/PDCursesMod/docs/manext.awk
new file mode 100755
index 00000000000..f607565ff4b
--- /dev/null
+++ b/lib/PDCursesMod/docs/manext.awk
@@ -0,0 +1,15 @@
+#!/usr/bin/awk -f
+BEGIN {
+  inman=0;
+  bar="\n\n--------------------------------------------------------------------------\n";
+}
+{
+  if (inman) {
+    if ($0 ~ /^\*\*man-end/) {
+      inman=0;
+      print bar;
+    } else
+      print;
+  } else if ($0 ~ /^\/\*man-start\*/)
+    inman=1;
+}
diff --git a/lib/PDCursesMod/docs/mkman.sh b/lib/PDCursesMod/docs/mkman.sh
new file mode 100755
index 00000000000..a5cb0fcdccb
--- /dev/null
+++ b/lib/PDCursesMod/docs/mkman.sh
@@ -0,0 +1,7 @@
+echo Definitions and Variables \(curses.h\) > MANUAL.md
+echo ==================================== >> MANUAL.md
+./manext.awk ../curses.h >> MANUAL.md
+echo Functions >> MANUAL.md
+echo ========= >> MANUAL.md
+./manext.awk ../pdcurses/*.c >> MANUAL.md
+./manext.awk ../x11/*.c >> MANUAL.md
diff --git a/lib/PDCursesMod/panel.h b/lib/PDCursesMod/panel.h
new file mode 100644
index 00000000000..57ff06d4148
--- /dev/null
+++ b/lib/PDCursesMod/panel.h
@@ -0,0 +1,58 @@
+/* Public Domain Curses */
+
+/*----------------------------------------------------------------------*
+ *                         Panels for PDCurses                          *
+ *----------------------------------------------------------------------*/
+
+#ifndef __PDCURSES_PANEL_H__
+#define __PDCURSES_PANEL_H__ 1
+
+#include <curses.h>
+
+#if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
+extern "C"
+{
+#endif
+
+typedef struct panelobs
+{
+    struct panelobs *above;
+    struct panel *pan;
+} PANELOBS;
+
+typedef struct panel
+{
+    WINDOW *win;
+    int wstarty;
+    int wendy;
+    int wstartx;
+    int wendx;
+    struct panel *below;
+    struct panel *above;
+    const void *user;
+    struct panelobs *obscure;
+} PANEL;
+
+PDCEX int     bottom_panel(PANEL *pan);
+PDCEX int     del_panel(PANEL *pan);
+PDCEX int     hide_panel(PANEL *pan);
+PDCEX int     move_panel(PANEL *pan, int starty, int startx);
+PDCEX PANEL  *new_panel(WINDOW *win);
+PDCEX PANEL  *panel_above(const PANEL *pan);
+PDCEX PANEL  *panel_below(const PANEL *pan);
+PDCEX PANEL  *ground_panel(SCREEN *sp);
+PDCEX PANEL  *ceiling_panel(SCREEN *sp);
+PDCEX int     panel_hidden(const PANEL *pan);
+PDCEX const void *panel_userptr(const PANEL *pan);
+PDCEX WINDOW *panel_window(const PANEL *pan);
+PDCEX int     replace_panel(PANEL *pan, WINDOW *win);
+PDCEX int     set_panel_userptr(PANEL *pan, const void *uptr);
+PDCEX int     show_panel(PANEL *pan);
+PDCEX int     top_panel(PANEL *pan);
+PDCEX void    update_panels(void);
+
+#if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
+}
+#endif
+
+#endif /* __PDCURSES_PANEL_H__ */
diff --git a/lib/PDCursesMod/pdcurses/README.md b/lib/PDCursesMod/pdcurses/README.md
new file mode 100644
index 00000000000..bef1c4c469a
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/README.md
@@ -0,0 +1,25 @@
+PDCurses Portable Core
+======================
+
+This directory contains core PDCurses source code files common to all 
+platforms.
+
+
+Building
+--------
+
+These modules are built by the platform-specific makefiles, in the 
+platform directories.
+
+
+Distribution Status
+-------------------
+
+The files in this directory are released to the Public Domain.
+
+
+Acknowledgements
+----------------
+
+The panel library was originally provided by
+Warren Tucker <wht@n4hgf.mt-park.ga.us>
diff --git a/lib/PDCursesMod/pdcurses/addch.c b/lib/PDCursesMod/pdcurses/addch.c
new file mode 100644
index 00000000000..75011ace198
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/addch.c
@@ -0,0 +1,697 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+addch
+-----
+
+### Synopsis
+
+    int addch(const chtype ch);
+    int waddch(WINDOW *win, const chtype ch);
+    int mvaddch(int y, int x, const chtype ch);
+    int mvwaddch(WINDOW *win, int y, int x, const chtype ch);
+    int echochar(const chtype ch);
+    int wechochar(WINDOW *win, const chtype ch);
+
+    int addrawch(chtype ch);
+    int waddrawch(WINDOW *win, chtype ch);
+    int mvaddrawch(int y, int x, chtype ch);
+    int mvwaddrawch(WINDOW *win, int y, int x, chtype ch);
+
+    int add_wch(const cchar_t *wch);
+    int wadd_wch(WINDOW *win, const cchar_t *wch);
+    int mvadd_wch(int y, int x, const cchar_t *wch);
+    int mvwadd_wch(WINDOW *win, int y, int x, const cchar_t *wch);
+    int echo_wchar(const cchar_t *wch);
+    int wecho_wchar(WINDOW *win, const cchar_t *wch);
+
+### Description
+
+   addch() adds the chtype ch to the default window (stdscr) at the
+   current cursor position, and advances the cursor. Note that chtypes
+   can convey both text (a single character) and attributes, including a
+   color pair. add_wch() is the wide-character version of this function,
+   taking a pointer to a cchar_t instead of a chtype.
+
+   waddch() is like addch(), but also lets you specify the window. (This
+   is in fact the core output routine.) wadd_wch() is the wide version.
+
+   mvaddch() moves the cursor to the specified (y, x) position, and adds
+   ch to stdscr. mvadd_wch() is the wide version.
+
+   mvwaddch() moves the cursor to the specified position and adds ch to
+   the specified window. mvwadd_wch() is the wide version.
+
+   echochar() adds ch to stdscr at the current cursor position and calls
+   refresh(). echo_wchar() is the wide version.
+
+   wechochar() adds ch to the specified window and calls wrefresh().
+   wecho_wchar() is the wide version.
+
+   addrawch(), waddrawch(), mvaddrawch() and mvwaddrawch() are PDCurses-
+   specific wrappers for addch() etc. that disable the translation of
+   control characters.
+
+   The following applies to all these functions:
+
+   If the cursor moves on to the right margin, an automatic newline is
+   performed. If scrollok is enabled, and a character is added to the
+   bottom right corner of the window, the scrolling region will be
+   scrolled up one line. If scrolling is not allowed, ERR will be
+   returned.
+
+   If ch is a tab, newline, or backspace, the cursor will be moved
+   appropriately within the window. If ch is a newline, the clrtoeol
+   routine is called before the cursor is moved to the beginning of the
+   next line. If newline mapping is off, the cursor will be moved to
+   the next line, but the x coordinate will be unchanged. If ch is a
+   tab the cursor is moved to the next tab position within the window.
+   If ch is another control character, it will be drawn in the ^X
+   notation. Calling the inch() routine after adding a control
+   character returns the representation of the control character, not
+   the control character.
+
+   Video attributes can be combined with a character by ORing them into
+   the parameter. Text, including attributes, can be copied from one
+   place to another by using inch() and addch().
+
+   Note that in PDCurses, for now, a cchar_t and a chtype are the same.
+   The text field is 16 bits wide, and is treated as Unicode (UCS-2)
+   when PDCurses is built with wide-character support (define PDC_WIDE).
+   So, in functions that take a chtype, like addch(), both the wide and
+   narrow versions will handle Unicode. But for portability, you should
+   use the wide functions.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    addch                       Y       Y       Y
+    waddch                      Y       Y       Y
+    mvaddch                     Y       Y       Y
+    mvwaddch                    Y       Y       Y
+    echochar                    Y       Y       Y
+    wechochar                   Y       Y       Y
+    add_wch                     Y       Y       Y
+    wadd_wch                    Y       Y       Y
+    mvadd_wch                   Y       Y       Y
+    mvwadd_wch                  Y       Y       Y
+    echo_wchar                  Y       Y       Y
+    wecho_wchar                 Y       Y       Y
+    addrawch                    -       -       -
+    waddrawch                   -       -       -
+    mvaddrawch                  -       -       -
+    mvwaddrawch                 -       -       -
+
+**man-end****************************************************************/
+
+/* As will be described below,  the method used here for combining
+   characters requires going beyond the usual 17*2^16 limit for Unicode.
+   That can only happen with 64-bit chtype / cchar_t,  and it's only
+   worth doing if we're going past 8-byte characters in the first place.
+   So if PDC_WIDE is defined _and_ we're using 64-bit chtypes,  we're
+   using the combining character scheme.  See curses.h. */
+
+#ifdef USING_COMBINING_CHARACTER_SCHEME
+#include <stdlib.h>
+/*
+ * A greatly stripped-down version of Markus Kuhn's excellent
+ * wcwidth implementation.  For his latest version and many
+ * comments,  see http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
+ * For PDCurses,  only mk_wcwidth is used,  modified to take an
+ * int argument instead of wchar_t,  because in MS-land, wchar_t
+ * is 16 bits;  getting the full Unicode range requires 21 bits.
+ * Also modified format/indenting to conform to PDCurses norms.
+ * NOTE that this version is current only to Unicode 5.0!  Updates
+ * could use https://unicode.org/Public/UNIDATA/EastAsianWidth.txt .
+ */
+
+struct interval
+{
+    int32_t first, last;
+};
+
+/* auxiliary function for binary search in interval table */
+
+static int bisearch( const int32_t ucs, const struct interval *table, int max)
+{
+    int min = 0;
+    int mid;
+
+    if (ucs < table[0].first || ucs > table[max].last)
+        return 0;
+    while (max >= min)
+    {
+        mid = (min + max) / 2;
+        if (ucs > table[mid].last)
+            min = mid + 1;
+        else if (ucs < table[mid].first)
+            max = mid - 1;
+        else
+           return 1;
+    }
+  return 0;
+}
+
+/* The following two functions define the column width of an ISO 10646
+ * character as follows:
+ *
+ *    - The null character (U+0000) has a column width of 0.
+ *
+ *    - Other C0/C1 control characters and DEL will lead to a return
+ *      value of -1.
+ *
+ *    - Non-spacing and enclosing combining characters (general
+ *      category code Mn or Me in the Unicode database) have a
+ *      column width of 0.
+ *
+ *    - SOFT HYPHEN (U+00AD) has a column width of 1.
+ *
+ *    - Other format characters (general category code Cf in the Unicode
+ *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
+ *
+ *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
+ *      have a column width of 0.
+ *
+ *    - Spacing characters in the East Asian Wide (W) or East Asian
+ *      Full-width (F) category as defined in Unicode Technical
+ *      Report #11 have a column width of 2.
+ *
+ *    - All remaining characters (including all printable
+ *      ISO 8859-1 and WGL4 characters, Unicode control characters,
+ *      etc.) have a column width of 1.
+ *
+ * This implementation assumes that wchar_t characters are encoded
+ * in ISO 10646.
+ */
+
+static int mk_wcwidth( const int32_t ucs)
+{
+  /* sorted list of non-overlapping intervals of non-spacing characters */
+  /* generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c" */
+    static const struct interval combining[] =
+    {
+         { 0x0300, 0x036F }, { 0x0483, 0x0486 }, { 0x0488, 0x0489 },
+         { 0x0591, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },
+         { 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 }, { 0x0600, 0x0603 },
+         { 0x0610, 0x0615 }, { 0x064B, 0x065E }, { 0x0670, 0x0670 },
+         { 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
+         { 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },
+         { 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0901, 0x0902 },
+         { 0x093C, 0x093C }, { 0x0941, 0x0948 }, { 0x094D, 0x094D },
+         { 0x0951, 0x0954 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },
+         { 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD },
+         { 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 }, { 0x0A3C, 0x0A3C },
+         { 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D },
+         { 0x0A70, 0x0A71 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },
+         { 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },
+         { 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },
+         { 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 }, { 0x0B4D, 0x0B4D },
+         { 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },
+         { 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 }, { 0x0C46, 0x0C48 },
+         { 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0CBC, 0x0CBC },
+         { 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },
+         { 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D },
+         { 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },
+         { 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },
+         { 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },
+         { 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },
+         { 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },
+         { 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 },
+         { 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },
+         { 0x1032, 0x1032 }, { 0x1036, 0x1037 }, { 0x1039, 0x1039 },
+         { 0x1058, 0x1059 }, { 0x1160, 0x11FF }, { 0x135F, 0x135F },
+         { 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },
+         { 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },
+         { 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },
+         { 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },
+         { 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },
+         { 0x1A17, 0x1A18 }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },
+         { 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C }, { 0x1B42, 0x1B42 },
+         { 0x1B6B, 0x1B73 }, { 0x1DC0, 0x1DCA }, { 0x1DFE, 0x1DFF },
+         { 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x2060, 0x2063 },
+         { 0x206A, 0x206F }, { 0x20D0, 0x20EF }, { 0x302A, 0x302F },
+         { 0x3099, 0x309A }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },
+         { 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F },
+         { 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB },
+         { 0x10A01, 0x10A03 }, { 0x10A05, 0x10A06 }, { 0x10A0C, 0x10A0F },
+         { 0x10A38, 0x10A3A }, { 0x10A3F, 0x10A3F }, { 0x1D167, 0x1D169 },
+         { 0x1D173, 0x1D182 }, { 0x1D185, 0x1D18B }, { 0x1D1AA, 0x1D1AD },
+         { 0x1D242, 0x1D244 }, { 0xE0001, 0xE0001 }, { 0xE0020, 0xE007F },
+         { 0xE0100, 0xE01EF }
+    };
+
+  /* test for 8-bit control characters */
+    if (ucs == 0)
+       return 0;
+    if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
+       return -1;
+
+    if( ucs < combining[0].first)   /* everything else up to 0x300 is a */
+       return( 1);                  /* plain old single-width character */
+  /* binary search in table of non-spacing characters */
+    if (bisearch(ucs, combining,
+          sizeof(combining) / sizeof(struct interval) - 1))
+       return 0;
+
+  /* if we arrive here, ucs is not a combining or C0/C1 control character */
+
+    return 1 +
+        (ucs >= 0x1100 &&
+       (ucs <= 0x115f ||                    /* Hangul Jamo init. consonants */
+       ucs == 0x2329 || ucs == 0x232a ||
+      (ucs >= 0x2e80 && ucs <= 0xa4cf &&
+       ucs != 0x303f) ||                  /* CJK ... Yi */
+      (ucs >= 0xac00 && ucs <= 0xd7a3) || /* Hangul Syllables */
+      (ucs >= 0xf900 && ucs <= 0xfaff) || /* CJK Compatibility Ideographs */
+      (ucs >= 0xfe10 && ucs <= 0xfe19) || /* Vertical forms */
+      (ucs >= 0xfe30 && ucs <= 0xfe6f) || /* CJK Compatibility Forms */
+      (ucs >= 0xff00 && ucs <= 0xff60) || /* Fullwidth Forms */
+      (ucs >= 0xffe0 && ucs <= 0xffe6) ||
+      (ucs >= 0x20000 && ucs <= 0x2fffd) ||
+      (ucs >= 0x30000 && ucs <= 0x3fffd)));
+}
+
+/* The handling of "fullwidth" characters (those consuming two "normal"
+columns) and combining characters (characters that can add accents to a
+preceding character) in PDCurses is,  of necessity,  complex.
+
+Unicode is defined to have 17 planes of 2^16 characters each,  so that
+the maximum Unicode code point is U+10FFFF.  When addch() is given a
+fullwidth character,  it handles that character "normally",  and then
+stores the non-Unicode character DUMMY_CHAR_NEXT_TO_FULLWIDTH
+(U+110000) next to it,  just as a placeholder.  (That part is actually
+rather simple.)
+
+PDCurses handles combining characters by creating entirely new "Unicode"
+(let's call them "post-Unicode") characters,  at code point U+110001
+(COMBINED_CHAR_START) and beyond. The 'combos' table keeps track of
+these newly-created characters,  essentially saying:  "This post-Unicode
+character consists of the following 'root' character,  plus an
+added combining character."  The 'root' character in question may itself
+be a post-Unicode character;  this allows us to add more than one
+combining character.
+
+For example,  if one calls wchar() with,  in succession, 'r' (U+72),
+a circumflex (U+0302),  and an acute accent below (U+317),  the call
+with the circumflex would cause 'combo' to be allocated,  with
+combo[0].root = 'r' and combo[0].added = 0x302.  Code point U+110001
+would correspond to this character ('r' plus circumflex).  The call
+with the acute accent below would create code point U+110002,
+combo[1].root = 0x110001 and combo[1].added = 0x317.  Thus,  a character
+with multiple combining characters simply resolves itself as a series
+of "post-Unicode" characters.  When the display function in pdcdisp.c
+is asked to show character 0x110001 or 0x110002,  it can use
+PDC_expand_combined_characters() to convert that code point to the
+actual series of characters.
+
+'ncurses' handles combined characters in a very different manner:  a
+'cchar' is defined as an array of five characters,  so that you can
+add up to four combining characters in any given cell.  I had to reject
+that solution because backward compatibility within PDCurses would be
+broken.  Quite aside from that,  this is a simpler solution,  and allows
+for any number of combining characters (though four ought to be enough
+for anybody).      */
+
+#define MAX_UNICODE                  0x10ffff
+#define DUMMY_CHAR_NEXT_TO_FULLWIDTH (MAX_UNICODE + 1)
+#define COMBINED_CHAR_START          (MAX_UNICODE + 2)
+
+                                /* "non-standard" 64-bit chtypes     */
+static int n_combos = 0, n_combos_allocated = 0;
+static struct combined_char
+{
+    int32_t root, added;
+} *combos = NULL;
+
+static int find_combined_char_idx( const cchar_t root, const cchar_t added)
+{
+    int i;
+
+    for( i = 0; i < n_combos; i++)
+        if( (int32_t)root == combos[i].root && (int32_t)added == combos[i].added)
+            return( i);
+                            /* Didn't find this pair among existing combos; */
+                            /* create a new one */
+    if( i == n_combos_allocated)
+    {
+        n_combos_allocated += 30 + n_combos_allocated / 2;
+        combos = realloc( combos, n_combos_allocated * sizeof( struct combined_char));
+    }
+    combos[i].root = (int32_t)root;
+    combos[i].added = (int32_t)added;
+    n_combos++;
+    return( i);
+}
+
+int PDC_expand_combined_characters( const cchar_t c, cchar_t *added)
+{
+    if( !c)    /* flag to free up memory */
+    {
+        n_combos = n_combos_allocated = 0;
+        if( combos)
+            free( combos);
+        combos = NULL;
+        return( 0);
+    }
+    assert( (int)c >= COMBINED_CHAR_START && (int)c < COMBINED_CHAR_START + n_combos);
+    *added = combos[c - COMBINED_CHAR_START].added;
+    return( combos[c - COMBINED_CHAR_START].root);
+}
+
+#endif      /* #ifdef USING_COMBINING_CHARACTER_SCHEME  */
+
+int waddch( WINDOW *win, const chtype ch)
+{
+    int x, y;
+#ifdef USING_COMBINING_CHARACTER_SCHEME
+    int text_width;
+#endif
+    chtype text, attr;
+    bool xlat;
+
+    PDC_LOG(("waddch() - called: win=%p ch=%x (text=%c attr=0x%x)\n",
+             win, ch, ch & A_CHARTEXT, ch & A_ATTRIBUTES));
+
+    assert( SP);
+    assert( win);
+    if (!win || !SP)
+        return ERR;
+
+    x = win->_curx;
+    y = win->_cury;
+
+    if (y > win->_maxy || x > win->_maxx || y < 0 || x < 0)
+        return ERR;
+
+    xlat = !SP->raw_out && !(ch & A_ALTCHARSET);
+    text = ch & A_CHARTEXT;
+    attr = ch & A_ATTRIBUTES;
+#ifdef USING_COMBINING_CHARACTER_SCHEME
+    text_width = mk_wcwidth( (int)text);
+
+    if( !text_width && text && (x || y))
+    {          /* it's a combining char;  combine w/prev char */
+        if( x)
+            x--;
+        else
+        {
+            y--;
+            x = win->_maxx - 1;
+        }
+        text = COMBINED_CHAR_START
+                     + find_combined_char_idx( win->_y[y][x], text);
+    }
+#endif
+
+    if (xlat && (text < ' ' || text == 0x7f))
+    {
+        int x2;
+
+        switch ((int)text)
+        {
+        case '\t':
+            for (x2 = ((x / TABSIZE) + 1) * TABSIZE; x < x2; x++)
+            {
+                if (waddch(win, attr | ' ') == ERR)
+                    return ERR;
+
+                /* if tab to next line, exit the loop */
+
+                if (!win->_curx)
+                    break;
+            }
+            return OK;
+
+        case '\n':
+            /* if lf -> crlf */
+
+            if (!SP->raw_out)
+                x = 0;
+
+               /* Had this commented out.  I think it matters in */
+               /* wide,  non-UTF8 mode on some platforms. */
+            wclrtoeol(win);
+
+            if (++y > win->_bmarg)
+            {
+                y--;
+
+                if (wscrl(win, 1) == ERR)
+                    return ERR;
+            }
+
+            break;
+
+        case '\b':
+            /* don't back over left margin */
+
+            if (--x < 0)
+        case '\r':
+                x = 0;
+
+            break;
+
+        case 0x7f:
+            if (waddch(win, attr | '^') == ERR)
+                return ERR;
+
+            return waddch(win, attr | '?');
+
+        default:
+            /* handle control chars */
+
+            if (waddch(win, attr | '^') == ERR)
+                return ERR;
+
+            return waddch(win, ch + '@');
+        }
+    }
+    else
+    {
+        /* If the incoming character doesn't have its own attribute,
+           then use the current attributes for the window. If it has
+           attributes but not a color component, OR the attributes to
+           the current attributes for the window. If it has a color
+           component, use the attributes solely from the incoming
+           character. */
+
+        if (!(attr & A_COLOR))
+            attr |= win->_attrs;
+
+        /* wrs (4/10/93): Apply the same sort of logic for the window
+           background, in that it only takes precedence if other color
+           attributes are not there and that the background character
+           will only print if the printing character is blank. */
+
+        if (!(attr & A_COLOR))
+            attr |= win->_bkgd & A_ATTRIBUTES;
+        else
+            attr |= win->_bkgd & (A_ATTRIBUTES ^ A_COLOR);
+
+        if (text == ' ')
+            text = win->_bkgd & A_CHARTEXT;
+
+        /* Add the attribute back into the character. */
+
+        text |= attr;
+
+        /* Only change _firstch/_lastch if the character to be added is
+           different from the character/attribute that is already in
+           that position in the window. */
+
+        if (win->_y[y][x] != text)
+        {
+            if (win->_firstch[y] == _NO_CHANGE)
+                win->_firstch[y] = win->_lastch[y] = x;
+            else
+                if (x < win->_firstch[y])
+                    win->_firstch[y] = x;
+                else
+                    if (x > win->_lastch[y])
+                        win->_lastch[y] = x;
+
+            win->_y[y][x] = text;
+        }
+
+        if (++x >= win->_maxx)
+        {
+            /* wrap around test */
+
+            x = 0;
+
+            if (++y > win->_bmarg)
+            {
+                y--;
+
+                if (wscrl(win, 1) == ERR)
+                {
+                    PDC_sync(win);
+                    return ERR;
+                }
+            }
+        }
+    }
+
+    win->_curx = x;
+    win->_cury = y;
+
+#ifdef USING_COMBINING_CHARACTER_SCHEME
+         /* If the character was fullwidth (should occupy two cells),  we */
+         /* add a "dummy" character next to it : */
+    if( text_width == 2 && x)
+        waddch( win, DUMMY_CHAR_NEXT_TO_FULLWIDTH);
+#endif
+
+    if (win->_immed)
+        wrefresh(win);
+    if (win->_sync)
+        wsyncup(win);
+
+    return OK;
+}
+
+int addch(const chtype ch)
+{
+    PDC_LOG(("addch() - called: ch=%x\n", ch));
+
+    return waddch(stdscr, ch);
+}
+
+int mvaddch(int y, int x, const chtype ch)
+{
+    PDC_LOG(("mvaddch() - called: y=%d x=%d ch=%x\n", y, x, ch));
+
+    if (move(y,x) == ERR)
+        return ERR;
+
+    return waddch(stdscr, ch);
+}
+
+int mvwaddch(WINDOW *win, int y, int x, const chtype ch)
+{
+    PDC_LOG(("mvwaddch() - called: win=%p y=%d x=%d ch=%d\n", win, y, x, ch));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return waddch(win, ch);
+}
+
+int echochar(const chtype ch)
+{
+    PDC_LOG(("echochar() - called: ch=%x\n", ch));
+
+    return wechochar(stdscr, ch);
+}
+
+int wechochar(WINDOW *win, const chtype ch)
+{
+    PDC_LOG(("wechochar() - called: win=%p ch=%x\n", win, ch));
+
+    if (waddch(win, ch) == ERR)
+        return ERR;
+
+    return wrefresh(win);
+}
+
+int waddrawch(WINDOW *win, chtype ch)
+{
+    PDC_LOG(("waddrawch() - called: win=%p ch=%x (text=%c attr=0x%x)\n",
+             win, ch, ch & A_CHARTEXT, ch & A_ATTRIBUTES));
+
+    if ((ch & A_CHARTEXT) < ' ' || (ch & A_CHARTEXT) == 0x7f)
+        ch |= A_ALTCHARSET;
+
+    return waddch(win, ch);
+}
+
+int addrawch(chtype ch)
+{
+    PDC_LOG(("addrawch() - called: ch=%x\n", ch));
+
+    return waddrawch(stdscr, ch);
+}
+
+int mvaddrawch(int y, int x, chtype ch)
+{
+    PDC_LOG(("mvaddrawch() - called: y=%d x=%d ch=%d\n", y, x, ch));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return waddrawch(stdscr, ch);
+}
+
+int mvwaddrawch(WINDOW *win, int y, int x, chtype ch)
+{
+    PDC_LOG(("mvwaddrawch() - called: win=%p y=%d x=%d ch=%d\n",
+             win, y, x, ch));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return waddrawch(win, ch);
+}
+
+#ifdef PDC_WIDE
+int wadd_wch(WINDOW *win, const cchar_t *wch)
+{
+    PDC_LOG(("wadd_wch() - called: win=%p wch=%x\n", win, *wch));
+
+    assert( wch);
+    return wch ? waddch(win, *wch) : ERR;
+}
+
+int add_wch(const cchar_t *wch)
+{
+    PDC_LOG(("add_wch() - called: wch=%x\n", *wch));
+
+    return wadd_wch(stdscr, wch);
+}
+
+int mvadd_wch(int y, int x, const cchar_t *wch)
+{
+    PDC_LOG(("mvaddch() - called: y=%d x=%d wch=%x\n", y, x, *wch));
+
+    if (move(y,x) == ERR)
+        return ERR;
+
+    return wadd_wch(stdscr, wch);
+}
+
+int mvwadd_wch(WINDOW *win, int y, int x, const cchar_t *wch)
+{
+    PDC_LOG(("mvwaddch() - called: win=%p y=%d x=%d wch=%d\n",
+             win, y, x, *wch));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wadd_wch(win, wch);
+}
+
+int echo_wchar(const cchar_t *wch)
+{
+    PDC_LOG(("echo_wchar() - called: wch=%x\n", *wch));
+
+    return wecho_wchar(stdscr, wch);
+}
+
+int wecho_wchar(WINDOW *win, const cchar_t *wch)
+{
+    PDC_LOG(("wecho_wchar() - called: win=%p wch=%x\n", win, *wch));
+
+    assert( wch);
+    if (!wch || (wadd_wch(win, wch) == ERR))
+        return ERR;
+
+    return wrefresh(win);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/addchstr.c b/lib/PDCursesMod/pdcurses/addchstr.c
new file mode 100644
index 00000000000..9f2f7642138
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/addchstr.c
@@ -0,0 +1,247 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+addchstr
+--------
+
+### Synopsis
+
+    int addchstr(const chtype *ch);
+    int addchnstr(const chtype *ch, int n);
+    int waddchstr(WINDOW *win, const chtype *ch);
+    int waddchnstr(WINDOW *win, const chtype *ch, int n);
+    int mvaddchstr(int y, int x, const chtype *ch);
+    int mvaddchnstr(int y, int x, const chtype *ch, int n);
+    int mvwaddchstr(WINDOW *, int y, int x, const chtype *ch);
+    int mvwaddchnstr(WINDOW *, int y, int x, const chtype *ch, int n);
+
+    int add_wchstr(const cchar_t *wch);
+    int add_wchnstr(const cchar_t *wch, int n);
+    int wadd_wchstr(WINDOW *win, const cchar_t *wch);
+    int wadd_wchnstr(WINDOW *win, const cchar_t *wch, int n);
+    int mvadd_wchstr(int y, int x, const cchar_t *wch);
+    int mvadd_wchnstr(int y, int x, const cchar_t *wch, int n);
+    int mvwadd_wchstr(WINDOW *win, int y, int x, const cchar_t *wch);
+    int mvwadd_wchnstr(WINDOW *win, int y, int x, const cchar_t *wch,
+                       int n);
+
+### Description
+
+   These routines write a chtype or cchar_t string directly into the
+   window structure, starting at the current or specified position. The
+   four routines with n as the last argument copy at most n elements,
+   but no more than will fit on the line. If n == -1 then the whole
+   string is copied, up to the maximum number that will fit on the line.
+
+   The cursor position is not advanced. These routines do not check for
+   newline or other special characters, nor does any line wrapping
+   occur.
+
+### Return Value
+
+   All functions return OK or ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    addchstr                    Y       Y       Y
+    waddchstr                   Y       Y       Y
+    mvaddchstr                  Y       Y       Y
+    mvwaddchstr                 Y       Y       Y
+    addchnstr                   Y       Y       Y
+    waddchnstr                  Y       Y       Y
+    mvaddchnstr                 Y       Y       Y
+    mvwaddchnstr                Y       Y       Y
+    add_wchstr                  Y       Y       Y
+    wadd_wchstr                 Y       Y       Y
+    mvadd_wchstr                Y       Y       Y
+    mvwadd_wchstr               Y       Y       Y
+    add_wchnstr                 Y       Y       Y
+    wadd_wchnstr                Y       Y       Y
+    mvadd_wchnstr               Y       Y       Y
+    mvwadd_wchnstr              Y       Y       Y
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+int waddchnstr(WINDOW *win, const chtype *ch, int n)
+{
+    int y, x, maxx, minx;
+    chtype *ptr;
+
+    PDC_LOG(("waddchnstr() - called: win=%p n=%d\n", win, n));
+
+    assert( win);
+    assert( ch);
+    if (!win || !ch || !n || n < -1)
+        return ERR;
+
+    x = win->_curx;
+    y = win->_cury;
+    ptr = &(win->_y[y][x]);
+
+    if (n == -1 || n > win->_maxx - x)
+        n = win->_maxx - x;
+
+    minx = win->_firstch[y];
+    maxx = win->_lastch[y];
+
+    for (; n && *ch; n--, x++, ptr++, ch++)
+    {
+        if (*ptr != *ch)
+        {
+            if (x < minx || minx == _NO_CHANGE)
+                minx = x;
+
+            if (x > maxx)
+                maxx = x;
+
+            PDC_LOG(("y %d x %d minx %d maxx %d *ptr %x *ch"
+                     " %x firstch: %d lastch: %d\n",
+                     y, x, minx, maxx, *ptr, *ch,
+                     win->_firstch[y], win->_lastch[y]));
+
+            *ptr = *ch;
+        }
+    }
+
+    win->_firstch[y] = minx;
+    win->_lastch[y] = maxx;
+
+    return OK;
+}
+
+int addchstr(const chtype *ch)
+{
+    PDC_LOG(("addchstr() - called\n"));
+
+    return waddchnstr(stdscr, ch, -1);
+}
+
+int addchnstr(const chtype *ch, int n)
+{
+    PDC_LOG(("addchnstr() - called\n"));
+
+    return waddchnstr(stdscr, ch, n);
+}
+
+int waddchstr(WINDOW *win, const chtype *ch)
+{
+    PDC_LOG(("waddchstr() - called: win=%p\n", win));
+
+    return waddchnstr(win, ch, -1);
+}
+
+int mvaddchstr(int y, int x, const chtype *ch)
+{
+    PDC_LOG(("mvaddchstr() - called: y %d x %d\n", y, x));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return waddchnstr(stdscr, ch, -1);
+}
+
+int mvaddchnstr(int y, int x, const chtype *ch, int n)
+{
+    PDC_LOG(("mvaddchnstr() - called: y %d x %d n %d\n", y, x, n));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return waddchnstr(stdscr, ch, n);
+}
+
+int mvwaddchstr(WINDOW *win, int y, int x, const chtype *ch)
+{
+    PDC_LOG(("mvwaddchstr() - called:\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return waddchnstr(win, ch, -1);
+}
+
+int mvwaddchnstr(WINDOW *win, int y, int x, const chtype *ch, int n)
+{
+    PDC_LOG(("mvwaddchnstr() - called: y %d x %d n %d \n", y, x, n));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return waddchnstr(win, ch, n);
+}
+
+#ifdef PDC_WIDE
+int wadd_wchnstr(WINDOW *win, const cchar_t *wch, int n)
+{
+    PDC_LOG(("wadd_wchnstr() - called: win=%p n=%d\n", win, n));
+
+    return waddchnstr(win, wch, n);
+}
+
+int add_wchstr(const cchar_t *wch)
+{
+    PDC_LOG(("add_wchstr() - called\n"));
+
+    return wadd_wchnstr(stdscr, wch, -1);
+}
+
+int add_wchnstr(const cchar_t *wch, int n)
+{
+    PDC_LOG(("add_wchnstr() - called\n"));
+
+    return wadd_wchnstr(stdscr, wch, n);
+}
+
+int wadd_wchstr(WINDOW *win, const cchar_t *wch)
+{
+    PDC_LOG(("wadd_wchstr() - called: win=%p\n", win));
+
+    return wadd_wchnstr(win, wch, -1);
+}
+
+int mvadd_wchstr(int y, int x, const cchar_t *wch)
+{
+    PDC_LOG(("mvadd_wchstr() - called: y %d x %d\n", y, x));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wadd_wchnstr(stdscr, wch, -1);
+}
+
+int mvadd_wchnstr(int y, int x, const cchar_t *wch, int n)
+{
+    PDC_LOG(("mvadd_wchnstr() - called: y %d x %d n %d\n", y, x, n));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wadd_wchnstr(stdscr, wch, n);
+}
+
+int mvwadd_wchstr(WINDOW *win, int y, int x, const cchar_t *wch)
+{
+    PDC_LOG(("mvwadd_wchstr() - called:\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wadd_wchnstr(win, wch, -1);
+}
+
+int mvwadd_wchnstr(WINDOW *win, int y, int x, const cchar_t *wch, int n)
+{
+    PDC_LOG(("mvwadd_wchnstr() - called: y %d x %d n %d \n", y, x, n));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wadd_wchnstr(win, wch, n);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/addstr.c b/lib/PDCursesMod/pdcurses/addstr.c
new file mode 100644
index 00000000000..86151c7055a
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/addstr.c
@@ -0,0 +1,245 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+addstr
+------
+
+### Synopsis
+
+    int addstr(const char *str);
+    int addnstr(const char *str, int n);
+    int waddstr(WINDOW *win, const char *str);
+    int waddnstr(WINDOW *win, const char *str, int n);
+    int mvaddstr(int y, int x, const char *str);
+    int mvaddnstr(int y, int x, const char *str, int n);
+    int mvwaddstr(WINDOW *win, int y, int x, const char *str);
+    int mvwaddnstr(WINDOW *win, int y, int x, const char *str, int n);
+
+    int addwstr(const wchar_t *wstr);
+    int addnwstr(const wchar_t *wstr, int n);
+    int waddwstr(WINDOW *win, const wchar_t *wstr);
+    int waddnwstr(WINDOW *win, const wchar_t *wstr, int n);
+    int mvaddwstr(int y, int x, const wchar_t *wstr);
+    int mvaddnwstr(int y, int x, const wchar_t *wstr, int n);
+    int mvwaddwstr(WINDOW *win, int y, int x, const wchar_t *wstr);
+    int mvwaddnwstr(WINDOW *win, int y, int x, const wchar_t *wstr, int n);
+
+### Description
+
+   These routines write all the characters of the null-terminated string
+   str or wide-character string wstr to the given window. The
+   functionality is similar to calling waddch() once for each character
+   in the string; except that, when PDCurses is built with wide-
+   character support enabled, the narrow-character functions treat the
+   string as a multibyte string in the current locale, and convert it.
+   The routines with n as the last argument write at most n characters;
+   if n is negative, then the entire string will be added.
+
+### Return Value
+
+   All functions return OK or ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    addstr                      Y       Y       Y
+    waddstr                     Y       Y       Y
+    mvaddstr                    Y       Y       Y
+    mvwaddstr                   Y       Y       Y
+    addnstr                     Y       Y       Y
+    waddnstr                    Y       Y       Y
+    mvaddnstr                   Y       Y       Y
+    mvwaddnstr                  Y       Y       Y
+    addwstr                     Y       Y       Y
+    waddwstr                    Y       Y       Y
+    mvaddwstr                   Y       Y       Y
+    mvwaddwstr                  Y       Y       Y
+    addnwstr                    Y       Y       Y
+    waddnwstr                   Y       Y       Y
+    mvaddnwstr                  Y       Y       Y
+    mvwaddnwstr                 Y       Y       Y
+
+**man-end****************************************************************/
+
+int waddnstr(WINDOW *win, const char *str, int n)
+{
+    int i = 0;
+
+    PDC_LOG(("waddnstr() - called: string=\"%s\" n %d \n", str, n));
+
+    assert( win);
+    assert( str);
+    if (!win || !str)
+        return ERR;
+
+    while( (i < n || n < 0) && str[i])
+    {
+#ifdef PDC_WIDE
+        wchar_t wch;
+        int retval = PDC_mbtowc(&wch, str + i, n >= 0 ? n - i : 6);
+
+        if (retval <= 0)
+            return OK;
+
+        i += retval;
+#else
+        chtype wch = (unsigned char)(str[i++]);
+#endif
+        if (waddch(win, wch) == ERR)
+            return ERR;
+    }
+
+    return OK;
+}
+
+int addstr(const char *str)
+{
+    PDC_LOG(("addstr() - called: string=\"%s\"\n", str));
+
+    return waddnstr(stdscr, str, -1);
+}
+
+int addnstr(const char *str, int n)
+{
+    PDC_LOG(("addnstr() - called: string=\"%s\" n %d \n", str, n));
+
+    return waddnstr(stdscr, str, n);
+}
+
+int waddstr(WINDOW *win, const char *str)
+{
+    PDC_LOG(("waddstr() - called: string=\"%s\"\n", str));
+
+    return waddnstr(win, str, -1);
+}
+
+int mvaddstr(int y, int x, const char *str)
+{
+    PDC_LOG(("mvaddstr() - called: y %d x %d string=\"%s\"\n", y, x, str));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return waddnstr(stdscr, str, -1);
+}
+
+int mvaddnstr(int y, int x, const char *str, int n)
+{
+    PDC_LOG(("mvaddnstr() - called: y %d x %d string=\"%s\" n %d \n",
+             y, x, str, n));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return waddnstr(stdscr, str, n);
+}
+
+int mvwaddstr(WINDOW *win, int y, int x, const char *str)
+{
+    PDC_LOG(("mvwaddstr() - called: string=\"%s\"\n", str));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return waddnstr(win, str, -1);
+}
+
+int mvwaddnstr(WINDOW *win, int y, int x, const char *str, int n)
+{
+    PDC_LOG(("mvwaddnstr() - called: y %d x %d string=\"%s\" n %d \n",
+             y, x, str, n));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return waddnstr(win, str, n);
+}
+
+#ifdef PDC_WIDE
+int waddnwstr(WINDOW *win, const wchar_t *wstr, int n)
+{
+    int i = 0;
+
+    PDC_LOG(("waddnwstr() - called\n"));
+
+    assert( win);
+    assert( wstr);
+    if (!win || !wstr)
+        return ERR;
+
+    while (wstr[i] && (i < n || n < 0))
+    while( (i < n || n < 0) && wstr[i])
+    {
+        chtype wch = wstr[i++];
+
+        if (waddch(win, wch) == ERR)
+            return ERR;
+    }
+
+    return OK;
+}
+
+int addwstr(const wchar_t *wstr)
+{
+    PDC_LOG(("addwstr() - called\n"));
+
+    return waddnwstr(stdscr, wstr, -1);
+}
+
+int addnwstr(const wchar_t *wstr, int n)
+{
+    PDC_LOG(("addnwstr() - called\n"));
+
+    return waddnwstr(stdscr, wstr, n);
+}
+
+int waddwstr(WINDOW *win, const wchar_t *wstr)
+{
+    PDC_LOG(("waddwstr() - called\n"));
+
+    return waddnwstr(win, wstr, -1);
+}
+
+int mvaddwstr(int y, int x, const wchar_t *wstr)
+{
+    PDC_LOG(("mvaddstr() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return waddnwstr(stdscr, wstr, -1);
+}
+
+int mvaddnwstr(int y, int x, const wchar_t *wstr, int n)
+{
+    PDC_LOG(("mvaddnstr() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return waddnwstr(stdscr, wstr, n);
+}
+
+int mvwaddwstr(WINDOW *win, int y, int x, const wchar_t *wstr)
+{
+    PDC_LOG(("mvwaddstr() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return waddnwstr(win, wstr, -1);
+}
+
+int mvwaddnwstr(WINDOW *win, int y, int x, const wchar_t *wstr, int n)
+{
+    PDC_LOG(("mvwaddnstr() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return waddnwstr(win, wstr, n);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/attr.c b/lib/PDCursesMod/pdcurses/attr.c
new file mode 100644
index 00000000000..b09e40d7b44
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/attr.c
@@ -0,0 +1,426 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+attr
+----
+
+### Synopsis
+
+    int attroff(chtype attrs);
+    int wattroff(WINDOW *win, chtype attrs);
+    int attron(chtype attrs);
+    int wattron(WINDOW *win, chtype attrs);
+    int attrset(chtype attrs);
+    int wattrset(WINDOW *win, chtype attrs);
+    int standend(void);
+    int wstandend(WINDOW *win);
+    int standout(void);
+    int wstandout(WINDOW *win);
+
+    int color_set(short color_pair, void *opts);
+    int wcolor_set(WINDOW *win, short color_pair, void *opts);
+
+    int attr_get(attr_t *attrs, short *color_pair, void *opts);
+    int attr_off(attr_t attrs, void *opts);
+    int attr_on(attr_t attrs, void *opts);
+    int attr_set(attr_t attrs, short color_pair, void *opts);
+    int wattr_get(WINDOW *win, attr_t *attrs, short *color_pair,
+                  void *opts);
+    int wattr_off(WINDOW *win, attr_t attrs, void *opts);
+    int wattr_on(WINDOW *win, attr_t attrs, void *opts);
+    int wattr_set(WINDOW *win, attr_t attrs, short color_pair,
+                  void *opts);
+
+    int chgat(int n, attr_t attr, short color, const void *opts);
+    int mvchgat(int y, int x, int n, attr_t attr, short color,
+                const void *opts);
+    int mvwchgat(WINDOW *win, int y, int x, int n, attr_t attr,
+                 short color, const void *opts);
+    int wchgat(WINDOW *win, int n, attr_t attr, short color,
+               const void *opts);
+
+    chtype getattrs(WINDOW *win);
+
+    int underend(void);
+    int wunderend(WINDOW *win);
+    int underscore(void);
+    int wunderscore(WINDOW *win);
+
+### Description
+
+   These functions manipulate the current attributes and/or colors of
+   the named window. These attributes can be any combination of
+   A_STANDOUT, A_REVERSE, A_BOLD, A_DIM, A_BLINK, A_UNDERLINE. These
+   constants are defined in <curses.h> and can be combined with the
+   bitwise-OR operator (|).
+
+   The current attributes of a window are applied to all chtypes that
+   are written into the window with waddch(). Attributes are a property
+   of the chtype, and move with the character through any scrolling or
+   insert/delete operations.
+
+   wattrset() sets the current attributes of the given window to attrs.
+   attrset() is the stdscr version.
+
+   wattroff() turns off the named attributes without affecting any other
+   attributes; wattron() turns them on.
+
+   wcolor_set() sets the window color to the value of color_pair. opts
+   is unused.
+
+   standout() is the same as attron(A_STANDOUT). standend() is the same
+   as attrset(A_NORMAL); that is, it turns off all attributes.
+
+   The attr_* and wattr_* functions are intended for use with the WA_*
+   attributes. In PDCurses, these are the same as A_*, and there is no
+   difference in bevahior from the chtype-based functions. In all cases,
+   opts is unused.
+
+   wattr_get() retrieves the attributes and color pair for the specified
+   window.
+
+   wchgat() sets the color pair and attributes for the next n cells on
+   the current line of a given window, without changing the existing
+   text, or alterting the window's attributes. An n of -1 extends the
+   change to the edge of the window. The changes take effect
+   immediately. opts is unused.
+
+   wunderscore() turns on the A_UNDERLINE attribute; wunderend() turns
+   it off. underscore() and underend() are the stdscr versions.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    attroff                     Y       Y       Y
+    wattroff                    Y       Y       Y
+    attron                      Y       Y       Y
+    wattron                     Y       Y       Y
+    attrset                     Y       Y       Y
+    wattrset                    Y       Y       Y
+    standend                    Y       Y       Y
+    wstandend                   Y       Y       Y
+    standout                    Y       Y       Y
+    wstandout                   Y       Y       Y
+    color_set                   Y       Y       Y
+    wcolor_set                  Y       Y       Y
+    attr_get                    Y       Y       Y
+    wattr_get                   Y       Y       Y
+    attr_on                     Y       Y       Y
+    wattr_on                    Y       Y       Y
+    attr_off                    Y       Y       Y
+    wattr_off                   Y       Y       Y
+    attr_set                    Y       Y       Y
+    wattr_set                   Y       Y       Y
+    chgat                       Y       Y       Y
+    wchgat                      Y       Y       Y
+    mvchgat                     Y       Y       Y
+    mvwchgat                    Y       Y       Y
+    getattrs                    -       Y       Y
+    underend                    -       -       Y
+    wunderend                   -       -       Y
+    underscore                  -       -       Y
+    wunderscore                 -       -       Y
+
+**man-end****************************************************************/
+
+int wattroff(WINDOW *win, chtype attrs)
+{
+    PDC_LOG(("wattroff() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_attrs &= (~attrs & A_ATTRIBUTES);
+
+    return OK;
+}
+
+int attroff(chtype attrs)
+{
+    PDC_LOG(("attroff() - called\n"));
+
+    return wattroff(stdscr, attrs);
+}
+
+int wattron(WINDOW *win, chtype attrs)
+{
+    chtype newcolr, oldcolr, newattr, oldattr;
+
+    PDC_LOG(("wattron() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    if ((win->_attrs & A_COLOR) && (attrs & A_COLOR))
+    {
+        oldcolr = win->_attrs & A_COLOR;
+        oldattr = win->_attrs ^ oldcolr;
+        newcolr = attrs & A_COLOR;
+        newattr = (attrs & A_ATTRIBUTES) ^ newcolr;
+        newattr |= oldattr;
+        win->_attrs = newattr | newcolr;
+    }
+    else
+        win->_attrs |= (attrs & A_ATTRIBUTES);
+
+    return OK;
+}
+
+int attron(chtype attrs)
+{
+    PDC_LOG(("attron() - called\n"));
+
+    return wattron(stdscr, attrs);
+}
+
+int wattrset(WINDOW *win, chtype attrs)
+{
+    PDC_LOG(("wattrset() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_attrs = attrs & A_ATTRIBUTES;
+
+    return OK;
+}
+
+int attrset(chtype attrs)
+{
+    PDC_LOG(("attrset() - called\n"));
+
+    return wattrset(stdscr, attrs);
+}
+
+int standend(void)
+{
+    PDC_LOG(("standend() - called\n"));
+
+    return wattrset(stdscr, A_NORMAL);
+}
+
+int standout(void)
+{
+    PDC_LOG(("standout() - called\n"));
+
+    return wattrset(stdscr, A_STANDOUT);
+}
+
+int wstandend(WINDOW *win)
+{
+    PDC_LOG(("wstandend() - called\n"));
+
+    return wattrset(win, A_NORMAL);
+}
+
+int wstandout(WINDOW *win)
+{
+    PDC_LOG(("wstandout() - called\n"));
+
+    return wattrset(win, A_STANDOUT);
+}
+
+chtype getattrs(WINDOW *win)
+{
+    assert( win);
+    return win ? win->_attrs : 0;
+}
+
+int wcolor_set(WINDOW *win, short color_pair, void *opts)
+{
+    PDC_LOG(("wcolor_set() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_attrs = (win->_attrs & ~A_COLOR) | COLOR_PAIR(color_pair);
+
+    return OK;
+}
+
+int color_set(short color_pair, void *opts)
+{
+    PDC_LOG(("color_set() - called\n"));
+
+    return wcolor_set(stdscr, color_pair, opts);
+}
+
+int wattr_get(WINDOW *win, attr_t *attrs, short *color_pair, void *opts)
+{
+    PDC_LOG(("wattr_get() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    assert( win);
+    if (!win)
+        return ERR;
+
+    if (attrs)
+        *attrs = win->_attrs & (A_ATTRIBUTES & ~A_COLOR);
+
+    if (color_pair)
+        *color_pair = (short)PAIR_NUMBER(win->_attrs);
+
+    return OK;
+}
+
+int attr_get(attr_t *attrs, short *color_pair, void *opts)
+{
+    PDC_LOG(("attr_get() - called\n"));
+
+    return wattr_get(stdscr, attrs, color_pair, opts);
+}
+
+int wattr_off(WINDOW *win, attr_t attrs, void *opts)
+{
+    PDC_LOG(("wattr_off() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    return wattroff(win, attrs);
+}
+
+int attr_off(attr_t attrs, void *opts)
+{
+    PDC_LOG(("attr_off() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    return wattroff(stdscr, attrs);
+}
+
+int wattr_on(WINDOW *win, attr_t attrs, void *opts)
+{
+    PDC_LOG(("wattr_off() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    return wattron(win, attrs);
+}
+
+int attr_on(attr_t attrs, void *opts)
+{
+    PDC_LOG(("attr_on() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    return wattron(stdscr, attrs);
+}
+
+int wattr_set(WINDOW *win, attr_t attrs, short color_pair, void *opts)
+{
+    PDC_LOG(("wattr_set() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_attrs = (attrs & (A_ATTRIBUTES & ~A_COLOR)) | COLOR_PAIR(color_pair);
+
+    return OK;
+}
+
+int attr_set(attr_t attrs, short color_pair, void *opts)
+{
+    PDC_LOG(("attr_get() - called\n"));
+
+    return wattr_set(stdscr, attrs, color_pair, opts);
+}
+
+int wchgat(WINDOW *win, int n, attr_t attr, short color, const void *opts)
+{
+    chtype *dest, newattr;
+    int startpos, endpos;
+
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    PDC_LOG(("wchgat() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    newattr = (attr & A_ATTRIBUTES) | COLOR_PAIR(color);
+
+    startpos = win->_curx;
+    endpos = ((n < 0) ? win->_maxx : min(startpos + n, win->_maxx)) - 1;
+    dest = win->_y[win->_cury];
+
+    for (n = startpos; n <= endpos; n++)
+        dest[n] = (dest[n] & A_CHARTEXT) | newattr;
+
+    n = win->_cury;
+
+    if (startpos < win->_firstch[n] || win->_firstch[n] == _NO_CHANGE)
+        win->_firstch[n] = startpos;
+
+    if (endpos > win->_lastch[n])
+        win->_lastch[n] = endpos;
+
+    PDC_sync(win);
+
+    return OK;
+}
+
+int chgat(int n, attr_t attr, short color, const void *opts)
+{
+    PDC_LOG(("chgat() - called\n"));
+
+    return wchgat(stdscr, n, attr, color, opts);
+}
+
+int mvchgat(int y, int x, int n, attr_t attr, short color, const void *opts)
+{
+    PDC_LOG(("mvchgat() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wchgat(stdscr, n, attr, color, opts);
+}
+
+int mvwchgat(WINDOW *win, int y, int x, int n, attr_t attr, short color,
+             const void *opts)
+{
+    PDC_LOG(("mvwchgat() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wchgat(win, n, attr, color, opts);
+}
+
+int underend(void)
+{
+    PDC_LOG(("underend() - called\n"));
+
+    return wattroff(stdscr, A_UNDERLINE);
+}
+
+int wunderend(WINDOW *win)
+{
+    PDC_LOG(("wunderend() - called\n"));
+
+    return wattroff(win, A_UNDERLINE);
+}
+
+int underscore(void)
+{
+    PDC_LOG(("underscore() - called\n"));
+
+    return wattron(stdscr, A_UNDERLINE);
+}
+
+int wunderscore(WINDOW *win)
+{
+    PDC_LOG(("wunderscore() - called\n"));
+
+    return wattron(win, A_UNDERLINE);
+}
diff --git a/lib/PDCursesMod/pdcurses/beep.c b/lib/PDCursesMod/pdcurses/beep.c
new file mode 100644
index 00000000000..21b138adc58
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/beep.c
@@ -0,0 +1,77 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+beep
+----
+
+### Synopsis
+
+    int beep(void);
+    int flash(void);
+
+### Description
+
+   beep() sounds the audible bell on the terminal, if possible; if not,
+   it calls flash().
+
+   flash() "flashes" the screen, by inverting the foreground and
+   background of every cell, pausing, and then restoring the original
+   attributes.
+
+### Return Value
+
+   These functions return ERR if called before initscr(), otherwise OK.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    beep                        Y       Y       Y
+    flash                       Y       Y       Y
+
+**man-end****************************************************************/
+
+int beep(void)
+{
+    PDC_LOG(("beep() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    if (SP->audible)
+        PDC_beep();
+    else
+        flash();
+
+    return OK;
+}
+
+int flash(void)
+{
+    int z, y, x;
+
+    PDC_LOG(("flash() - called\n"));
+
+    assert( curscr);
+    if (!curscr)
+        return ERR;
+
+    /* Reverse each cell; wait; restore the screen */
+
+    for (z = 0; z < 2; z++)
+    {
+        for (y = 0; y < LINES; y++)
+            for (x = 0; x < COLS; x++)
+                curscr->_y[y][x] ^= A_REVERSE;
+
+        wrefresh(curscr);
+
+        if (!z)
+            napms(50);
+    }
+
+    return OK;
+}
diff --git a/lib/PDCursesMod/pdcurses/bkgd.c b/lib/PDCursesMod/pdcurses/bkgd.c
new file mode 100644
index 00000000000..0806dce68b0
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/bkgd.c
@@ -0,0 +1,232 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+bkgd
+----
+
+### Synopsis
+
+    int bkgd(chtype ch);
+    void bkgdset(chtype ch);
+    chtype getbkgd(WINDOW *win);
+    int wbkgd(WINDOW *win, chtype ch);
+    void wbkgdset(WINDOW *win, chtype ch);
+
+    int bkgrnd(const cchar_t *wch);
+    void bkgrndset(const cchar_t *wch);
+    int getbkgrnd(cchar_t *wch);
+    int wbkgrnd(WINDOW *win, const cchar_t *wch);
+    void wbkgrndset(WINDOW *win, const cchar_t *wch);
+    int wgetbkgrnd(WINDOW *win, cchar_t *wch);
+
+### Description
+
+   bkgdset() and wbkgdset() manipulate the background of a window. The
+   background is a chtype consisting of any combination of attributes
+   and a character; it is combined with each chtype added or inserted to
+   the window by waddch() or winsch(). Only the attribute part is used
+   to set the background of non-blank characters, while both character
+   and attributes are used for blank positions.
+
+   bkgd() and wbkgd() not only change the background, but apply it
+   immediately to every cell in the window.
+
+   wbkgrnd(), wbkgrndset() and wgetbkgrnd() are the "wide-character"
+   versions of these functions, taking a pointer to a cchar_t instead of
+   a chtype. However, in PDCurses, cchar_t and chtype are the same.
+
+   The attributes that are defined with the attrset()/attron() set of
+   functions take precedence over the background attributes if there is
+   a conflict (e.g., different color pairs).
+
+### Return Value
+
+   bkgd() and wbkgd() return OK, unless the window is NULL, in which
+   case they return ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    bkgd                        Y       Y       Y
+    bkgdset                     Y       Y       Y
+    getbkgd                     Y       Y       Y
+    wbkgd                       Y       Y       Y
+    wbkgdset                    Y       Y       Y
+    bkgrnd                      Y       Y       Y
+    bkgrndset                   Y       Y       Y
+    getbkgrnd                   Y       Y       Y
+    wbkgrnd                     Y       Y       Y
+    wbkgrndset                  Y       Y       Y
+    wgetbkgrnd                  Y       Y       Y
+
+**man-end****************************************************************/
+
+int wbkgd(WINDOW *win, chtype ch)
+{
+    int x, y;
+    chtype oldcolr, oldch, newcolr, newch, colr, attr;
+    chtype oldattr = 0, newattr = 0;
+    chtype *winptr;
+
+    PDC_LOG(("wbkgd() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    if (win->_bkgd == ch)
+        return OK;
+
+    oldcolr = win->_bkgd & A_COLOR;
+    if (oldcolr)
+        oldattr = (win->_bkgd & A_ATTRIBUTES) ^ oldcolr;
+
+    oldch = win->_bkgd & A_CHARTEXT;
+
+    wbkgdset(win, ch);
+
+    newcolr = win->_bkgd & A_COLOR;
+    if (newcolr)
+        newattr = (win->_bkgd & A_ATTRIBUTES) ^ newcolr;
+
+    newch = win->_bkgd & A_CHARTEXT;
+
+    /* what follows is what seems to occur in the System V
+       implementation of this routine */
+
+    for (y = 0; y < win->_maxy; y++)
+    {
+        for (x = 0; x < win->_maxx; x++)
+        {
+            winptr = win->_y[y] + x;
+
+            ch = *winptr;
+
+            /* determine the colors and attributes of the character read
+               from the window */
+
+            colr = ch & A_COLOR;
+            attr = ch & (A_ATTRIBUTES ^ A_COLOR);
+
+            /* if the color is the same as the old background color,
+               then make it the new background color, otherwise leave it */
+
+            if (colr == oldcolr)
+                colr = newcolr;
+
+            /* remove any attributes (non color) from the character that
+               were part of the old background, then combine the
+               remaining ones with the new background */
+
+            attr ^= oldattr;
+            attr |= newattr;
+
+            /* change character if it is there because it was the old
+               background character */
+
+            ch &= A_CHARTEXT;
+            if (ch == oldch)
+                ch = newch;
+
+            ch |= (attr | colr);
+
+            *winptr = ch;
+
+        }
+    }
+
+    touchwin(win);
+    PDC_sync(win);
+    return OK;
+}
+
+int bkgd(chtype ch)
+{
+    PDC_LOG(("bkgd() - called\n"));
+
+    return wbkgd(stdscr, ch);
+}
+
+void wbkgdset(WINDOW *win, chtype ch)
+{
+    PDC_LOG(("wbkgdset() - called\n"));
+
+    if (win)
+    {
+        if (!(ch & A_CHARTEXT))
+            ch |= ' ';
+
+        win->_bkgd = ch;
+    }
+}
+
+void bkgdset(chtype ch)
+{
+    PDC_LOG(("bkgdset() - called\n"));
+
+    wbkgdset(stdscr, ch);
+}
+
+chtype getbkgd(WINDOW *win)
+{
+    PDC_LOG(("getbkgd() - called\n"));
+
+    assert( win);
+    return win ? win->_bkgd : (chtype)ERR;
+}
+
+#ifdef PDC_WIDE
+int wbkgrnd(WINDOW *win, const cchar_t *wch)
+{
+    PDC_LOG(("wbkgrnd() - called\n"));
+
+    assert( wch);
+    return wch ? wbkgd(win, *wch) : ERR;
+}
+
+int bkgrnd(const cchar_t *wch)
+{
+    PDC_LOG(("bkgrnd() - called\n"));
+
+    return wbkgrnd(stdscr, wch);
+}
+
+void wbkgrndset(WINDOW *win, const cchar_t *wch)
+{
+    PDC_LOG(("wbkgdset() - called\n"));
+
+    if (wch)
+        wbkgdset(win, *wch);
+}
+
+void bkgrndset(const cchar_t *wch)
+{
+    PDC_LOG(("bkgrndset() - called\n"));
+
+    wbkgrndset(stdscr, wch);
+}
+
+int wgetbkgrnd(WINDOW *win, cchar_t *wch)
+{
+    PDC_LOG(("wgetbkgrnd() - called\n"));
+
+    assert( win);
+    assert( wch);
+    if (!win || !wch)
+        return ERR;
+
+    *wch = win->_bkgd;
+
+    return OK;
+}
+
+int getbkgrnd(cchar_t *wch)
+{
+    PDC_LOG(("getbkgrnd() - called\n"));
+
+    return wgetbkgrnd(stdscr, wch);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/border.c b/lib/PDCursesMod/pdcurses/border.c
new file mode 100644
index 00000000000..b234b7831c4
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/border.c
@@ -0,0 +1,420 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+border
+------
+
+### Synopsis
+
+    int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl,
+               chtype tr, chtype bl, chtype br);
+    int wborder(WINDOW *win, chtype ls, chtype rs, chtype ts,
+                chtype bs, chtype tl, chtype tr, chtype bl, chtype br);
+    int box(WINDOW *win, chtype verch, chtype horch);
+    int hline(chtype ch, int n);
+    int vline(chtype ch, int n);
+    int whline(WINDOW *win, chtype ch, int n);
+    int wvline(WINDOW *win, chtype ch, int n);
+    int mvhline(int y, int x, chtype ch, int n);
+    int mvvline(int y, int x, chtype ch, int n);
+    int mvwhline(WINDOW *win, int y, int x, chtype ch, int n);
+    int mvwvline(WINDOW *win, int y, int x, chtype ch, int n);
+
+    int border_set(const cchar_t *ls, const cchar_t *rs,
+                   const cchar_t *ts, const cchar_t *bs,
+                   const cchar_t *tl, const cchar_t *tr,
+                const cchar_t *bl, const cchar_t *br);
+    int wborder_set(WINDOW *win, const cchar_t *ls, const cchar_t *rs,
+                    const cchar_t *ts, const cchar_t *bs,
+                    const cchar_t *tl, const cchar_t *tr,
+                    const cchar_t *bl, const cchar_t *br);
+    int box_set(WINDOW *win, const cchar_t *verch, const cchar_t *horch);
+    int hline_set(const cchar_t *wch, int n);
+    int vline_set(const cchar_t *wch, int n);
+    int whline_set(WINDOW *win, const cchar_t *wch, int n);
+    int wvline_set(WINDOW *win, const cchar_t *wch, int n);
+    int mvhline_set(int y, int x, const cchar_t *wch, int n);
+    int mvvline_set(int y, int x, const cchar_t *wch, int n);
+    int mvwhline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n);
+    int mvwvline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n);
+
+### Description
+
+   border(), wborder(), and box() draw a border around the edge of the
+   window. If any argument is zero, an appropriate default is used:
+
+    ls    left side of border             ACS_VLINE
+    rs    right side of border            ACS_VLINE
+    ts    top side of border              ACS_HLINE
+    bs    bottom side of border           ACS_HLINE
+    tl    top left corner of border       ACS_ULCORNER
+    tr    top right corner of border      ACS_URCORNER
+    bl    bottom left corner of border    ACS_LLCORNER
+    br    bottom right corner of border   ACS_LRCORNER
+
+   hline() and whline() draw a horizontal line, using ch, starting from
+   the current cursor position. The cursor position does not change. The
+   line is at most n characters long, or as many as will fit in the
+   window.
+
+   vline() and wvline() draw a vertical line, using ch, starting from
+   the current cursor position. The cursor position does not change. The
+   line is at most n characters long, or as many as will fit in the
+   window.
+
+   The *_set functions are the "wide-character" versions, taking
+   pointers to cchar_t instead of chtype. Note that in PDCurses, chtype
+   and cchar_t are the same.
+
+### Return Value
+
+   These functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    border                      Y       Y       Y
+    wborder                     Y       Y       Y
+    box                         Y       Y       Y
+    hline                       Y       Y       Y
+    vline                       Y       Y       Y
+    whline                      Y       Y       Y
+    wvline                      Y       Y       Y
+    mvhline                     Y       Y       Y
+    mvvline                     Y       Y       Y
+    mvwhline                    Y       Y       Y
+    mvwvline                    Y       Y       Y
+    border_set                  Y       Y       Y
+    wborder_set                 Y       Y       Y
+    box_set                     Y       Y       Y
+    hline_set                   Y       Y       Y
+    vline_set                   Y       Y       Y
+    whline_set                  Y       Y       Y
+    wvline_set                  Y       Y       Y
+    mvhline_set                 Y       Y       Y
+    mvvline_set                 Y       Y       Y
+    mvwhline_set                Y       Y       Y
+    mvwvline_set                Y       Y       Y
+
+**man-end****************************************************************/
+
+/* _attr_passthru() -- Takes a single chtype 'ch' and checks if the
+   current attribute of window 'win', as set by wattrset(), and/or the
+   current background of win, as set by wbkgd(), should by combined with
+   it. Attributes set explicitly in ch take precedence. */
+
+static chtype _attr_passthru(WINDOW *win, chtype ch)
+{
+    chtype attr;
+
+    /* If the incoming character doesn't have its own attribute, then
+       use the current attributes for the window. If the incoming
+       character has attributes, but not a color component, OR the
+       attributes to the current attributes for the window. If the
+       incoming character has a color component, use only the attributes
+       from the incoming character. */
+
+    attr = ch & A_ATTRIBUTES;
+    if (!(attr & A_COLOR))
+        attr |= win->_attrs;
+
+    /* wrs (4/10/93) -- Apply the same sort of logic for the window
+       background, in that it only takes precedence if other color
+       attributes are not there. */
+
+    if (!(attr & A_COLOR))
+        attr |= win->_bkgd & A_ATTRIBUTES;
+    else
+        attr |= win->_bkgd & (A_ATTRIBUTES ^ A_COLOR);
+
+    ch = (ch & A_CHARTEXT) | attr;
+
+    return ch;
+}
+
+int wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, chtype bs,
+            chtype tl, chtype tr, chtype bl, chtype br)
+{
+    int i, ymax, xmax;
+
+    PDC_LOG(("wborder() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    ymax = win->_maxy - 1;
+    xmax = win->_maxx - 1;
+
+    ls = _attr_passthru(win, ls ? ls : ACS_VLINE);
+    rs = _attr_passthru(win, rs ? rs : ACS_VLINE);
+    ts = _attr_passthru(win, ts ? ts : ACS_HLINE);
+    bs = _attr_passthru(win, bs ? bs : ACS_HLINE);
+    tl = _attr_passthru(win, tl ? tl : ACS_ULCORNER);
+    tr = _attr_passthru(win, tr ? tr : ACS_URCORNER);
+    bl = _attr_passthru(win, bl ? bl : ACS_LLCORNER);
+    br = _attr_passthru(win, br ? br : ACS_LRCORNER);
+
+    for (i = 1; i < xmax; i++)
+    {
+        win->_y[0][i] = ts;
+        win->_y[ymax][i] = bs;
+    }
+
+    for (i = 1; i < ymax; i++)
+    {
+        win->_y[i][0] = ls;
+        win->_y[i][xmax] = rs;
+    }
+
+    win->_y[0][0] = tl;
+    win->_y[0][xmax] = tr;
+    win->_y[ymax][0] = bl;
+    win->_y[ymax][xmax] = br;
+
+    for (i = 0; i <= ymax; i++)
+    {
+        win->_firstch[i] = 0;
+        win->_lastch[i] = xmax;
+    }
+
+    PDC_sync(win);
+
+    return OK;
+}
+
+int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl,
+           chtype tr, chtype bl, chtype br)
+{
+    PDC_LOG(("border() - called\n"));
+
+    return wborder(stdscr, ls, rs, ts, bs, tl, tr, bl, br);
+}
+
+int box(WINDOW *win, chtype verch, chtype horch)
+{
+    PDC_LOG(("box() - called\n"));
+
+    return wborder(win, verch, verch, horch, horch, 0, 0, 0, 0);
+}
+
+int whline(WINDOW *win, chtype ch, int n)
+{
+    chtype *dest;
+    int startpos, endpos;
+
+    PDC_LOG(("whline() - called\n"));
+
+    assert( win);
+    if (!win || n < 1)
+        return ERR;
+
+    startpos = win->_curx;
+    endpos = min(startpos + n, win->_maxx) - 1;
+    dest = win->_y[win->_cury];
+    ch = _attr_passthru(win, ch ? ch : ACS_HLINE);
+
+    for (n = startpos; n <= endpos; n++)
+        dest[n] = ch;
+
+    n = win->_cury;
+
+    if (startpos < win->_firstch[n] || win->_firstch[n] == _NO_CHANGE)
+        win->_firstch[n] = startpos;
+
+    if (endpos > win->_lastch[n])
+        win->_lastch[n] = endpos;
+
+    PDC_sync(win);
+
+    return OK;
+}
+
+int hline(chtype ch, int n)
+{
+    PDC_LOG(("hline() - called\n"));
+
+    return whline(stdscr, ch, n);
+}
+
+int mvhline(int y, int x, chtype ch, int n)
+{
+    PDC_LOG(("mvhline() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return whline(stdscr, ch, n);
+}
+
+int mvwhline(WINDOW *win, int y, int x, chtype ch, int n)
+{
+    PDC_LOG(("mvwhline() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return whline(win, ch, n);
+}
+
+int wvline(WINDOW *win, chtype ch, int n)
+{
+    int endpos, x;
+
+    PDC_LOG(("wvline() - called\n"));
+
+    assert( win);
+    if (!win || n < 1)
+        return ERR;
+
+    endpos = min(win->_cury + n, win->_maxy);
+    x = win->_curx;
+
+    ch = _attr_passthru(win, ch ? ch : ACS_VLINE);
+
+    for (n = win->_cury; n < endpos; n++)
+    {
+        win->_y[n][x] = ch;
+
+        if (x < win->_firstch[n] || win->_firstch[n] == _NO_CHANGE)
+            win->_firstch[n] = x;
+
+        if (x > win->_lastch[n])
+            win->_lastch[n] = x;
+    }
+
+    PDC_sync(win);
+
+    return OK;
+}
+
+int vline(chtype ch, int n)
+{
+    PDC_LOG(("vline() - called\n"));
+
+    return wvline(stdscr, ch, n);
+}
+
+int mvvline(int y, int x, chtype ch, int n)
+{
+    PDC_LOG(("mvvline() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wvline(stdscr, ch, n);
+}
+
+int mvwvline(WINDOW *win, int y, int x, chtype ch, int n)
+{
+    PDC_LOG(("mvwvline() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wvline(win, ch, n);
+}
+
+#ifdef PDC_WIDE
+int wborder_set(WINDOW *win, const cchar_t *ls, const cchar_t *rs,
+                const cchar_t *ts, const cchar_t *bs, const cchar_t *tl,
+                const cchar_t *tr, const cchar_t *bl, const cchar_t *br)
+{
+    PDC_LOG(("wborder_set() - called\n"));
+
+    return wborder(win, ls ? *ls : 0, rs ? *rs : 0, ts ? *ts : 0,
+                        bs ? *bs : 0, tl ? *tl : 0, tr ? *tr : 0,
+                        bl ? *bl : 0, br ? *br : 0);
+}
+
+int border_set(const cchar_t *ls, const cchar_t *rs, const cchar_t *ts,
+               const cchar_t *bs, const cchar_t *tl, const cchar_t *tr,
+               const cchar_t *bl, const cchar_t *br)
+{
+    PDC_LOG(("border_set() - called\n"));
+
+    return wborder_set(stdscr, ls, rs, ts, bs, tl, tr, bl, br);
+}
+
+int box_set(WINDOW *win, const cchar_t *verch, const cchar_t *horch)
+{
+    PDC_LOG(("box_set() - called\n"));
+
+    return wborder_set(win, verch, verch, horch, horch,
+                       (const cchar_t *)NULL, (const cchar_t *)NULL,
+                       (const cchar_t *)NULL, (const cchar_t *)NULL);
+}
+
+int whline_set(WINDOW *win, const cchar_t *wch, int n)
+{
+    PDC_LOG(("whline_set() - called\n"));
+
+    assert( wch);
+    return wch ? whline(win, *wch, n) : ERR;
+}
+
+int hline_set(const cchar_t *wch, int n)
+{
+    PDC_LOG(("hline_set() - called\n"));
+
+    return whline_set(stdscr, wch, n);
+}
+
+int mvhline_set(int y, int x, const cchar_t *wch, int n)
+{
+    PDC_LOG(("mvhline_set() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return whline_set(stdscr, wch, n);
+}
+
+int mvwhline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n)
+{
+    PDC_LOG(("mvwhline_set() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return whline_set(win, wch, n);
+}
+
+int wvline_set(WINDOW *win, const cchar_t *wch, int n)
+{
+    PDC_LOG(("wvline_set() - called\n"));
+
+    assert( wch);
+    return wch ? wvline(win, *wch, n) : ERR;
+}
+
+int vline_set(const cchar_t *wch, int n)
+{
+    PDC_LOG(("vline_set() - called\n"));
+
+    return wvline_set(stdscr, wch, n);
+}
+
+int mvvline_set(int y, int x, const cchar_t *wch, int n)
+{
+    PDC_LOG(("mvvline_set() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wvline_set(stdscr, wch, n);
+}
+
+int mvwvline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n)
+{
+    PDC_LOG(("mvwvline_set() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wvline_set(win, wch, n);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/clear.c b/lib/PDCursesMod/pdcurses/clear.c
new file mode 100644
index 00000000000..9b6ccae783c
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/clear.c
@@ -0,0 +1,163 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+clear
+-----
+
+### Synopsis
+
+    int clear(void);
+    int wclear(WINDOW *win);
+    int erase(void);
+    int werase(WINDOW *win);
+    int clrtobot(void);
+    int wclrtobot(WINDOW *win);
+    int clrtoeol(void);
+    int wclrtoeol(WINDOW *win);
+
+### Description
+
+   erase() and werase() copy blanks (i.e. the background chtype) to
+   every cell of the window.
+
+   clear() and wclear() are similar to erase() and werase(), but they
+   also call clearok() to ensure that the the window is cleared on the
+   next wrefresh().
+
+   clrtobot() and wclrtobot() clear the window from the current cursor
+   position to the end of the window.
+
+   clrtoeol() and wclrtoeol() clear the window from the current cursor
+   position to the end of the current line.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    clear                       Y       Y       Y
+    wclear                      Y       Y       Y
+    erase                       Y       Y       Y
+    werase                      Y       Y       Y
+    clrtobot                    Y       Y       Y
+    wclrtobot                   Y       Y       Y
+    clrtoeol                    Y       Y       Y
+    wclrtoeol                   Y       Y       Y
+
+**man-end****************************************************************/
+
+int wclrtoeol(WINDOW *win)
+{
+    int x, y, minx;
+    chtype blank, *ptr;
+
+    PDC_LOG(("wclrtoeol() - called: Row: %d Col: %d\n",
+             win->_cury, win->_curx));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    y = win->_cury;
+    x = win->_curx;
+
+    /* wrs (4/10/93) account for window background */
+
+    blank = win->_bkgd;
+
+    for (minx = x, ptr = &win->_y[y][x]; minx < win->_maxx; minx++, ptr++)
+        *ptr = blank;
+
+    if (x < win->_firstch[y] || win->_firstch[y] == _NO_CHANGE)
+        win->_firstch[y] = x;
+
+    win->_lastch[y] = win->_maxx - 1;
+
+    PDC_sync(win);
+    return OK;
+}
+
+int clrtoeol(void)
+{
+    PDC_LOG(("clrtoeol() - called\n"));
+
+    return wclrtoeol(stdscr);
+}
+
+int wclrtobot(WINDOW *win)
+{
+    int savey, savex;
+
+    PDC_LOG(("wclrtobot() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    savey = win->_cury;
+    savex = win->_curx;
+
+    /* should this involve scrolling region somehow ? */
+
+    if (win->_cury + 1 < win->_maxy)
+    {
+        win->_curx = 0;
+        win->_cury++;
+        for (; win->_maxy > win->_cury; win->_cury++)
+            wclrtoeol(win);
+        win->_cury = savey;
+        win->_curx = savex;
+    }
+    wclrtoeol(win);
+
+    PDC_sync(win);
+    return OK;
+}
+
+int clrtobot(void)
+{
+    PDC_LOG(("clrtobot() - called\n"));
+
+    return wclrtobot(stdscr);
+}
+
+int werase(WINDOW *win)
+{
+    PDC_LOG(("werase() - called\n"));
+
+    if (wmove(win, 0, 0) == ERR)
+        return ERR;
+
+    return wclrtobot(win);
+}
+
+int erase(void)
+{
+    PDC_LOG(("erase() - called\n"));
+
+    return werase(stdscr);
+}
+
+int wclear(WINDOW *win)
+{
+    PDC_LOG(("wclear() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_clear = TRUE;
+    return werase(win);
+}
+
+int clear(void)
+{
+    PDC_LOG(("clear() - called\n"));
+
+    return wclear(stdscr);
+}
diff --git a/lib/PDCursesMod/pdcurses/color.c b/lib/PDCursesMod/pdcurses/color.c
new file mode 100644
index 00000000000..bd15e70e1fe
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/color.c
@@ -0,0 +1,392 @@
+/* PDCurses */
+
+#include <curspriv.h>
+
+/*man-start**************************************************************
+
+color
+-----
+
+### Synopsis
+
+    bool has_colors(void);
+    int start_color(void);
+    int init_pair(short pair, short fg, short bg);
+    int pair_content(short pair, short *fg, short *bg);
+    int init_extended_pair(int pair, int fg, int bg);
+    int extended_pair_content(int pair, int *fg, int *bg);
+    bool can_change_color(void);
+    int init_color(short color, short red, short green, short blue);
+    int color_content(short color, short *red, short *green, short *blue);
+    int init_extended_color(int color, int red, int green, int blue);
+    int extended_color_content(int color, int *red, int *green, int *blue);
+
+    int assume_default_colors(int f, int b);
+    int use_default_colors(void);
+
+    int PDC_set_line_color(short color);
+
+### Description
+
+   To use these routines, first, call start_color(). Colors are always
+   used in pairs, referred to as color-pairs. A color-pair is created by
+   init_pair(), and consists of a foreground color and a background
+   color. After initialization, COLOR_PAIR(n) can be used like any other
+   video attribute.
+
+   has_colors() reports whether the terminal supports color.
+
+   start_color() initializes eight basic colors (black, red, green,
+   yellow, blue, magenta, cyan, and white), and two global variables:
+   COLORS and COLOR_PAIRS (respectively defining the maximum number of
+   colors and color-pairs the terminal is capable of displaying).
+
+   init_pair() changes the definition of a color-pair. It takes three
+   arguments: the number of the color-pair to be redefined, and the new
+   values of the foreground and background colors. The pair number must
+   be between 0 and COLOR_PAIRS - 1, inclusive. The foreground and
+   background must be between 0 and COLORS - 1, inclusive. If the color
+   pair was previously initialized, the screen is refreshed, and all
+   occurrences of that color-pair are changed to the new definition.
+
+   pair_content() is used to determine what the colors of a given color-
+   pair consist of.
+
+   init_extended_pair() and extended_pair_content() use ints for the
+   color pair index and the color values.  These allow a larger number
+   of colors and color pairs to be supported,  eliminating the 32767
+   color and color pair limits.
+
+   can_change_color() indicates if the terminal has the capability to
+   change the definition of its colors.
+
+   init_color() is used to redefine a color, if possible. Each of the
+   components -- red, green, and blue -- is specified in a range from 0
+   to 1000, inclusive.
+
+   color_content() reports the current definition of a color in the same
+   format as used by init_color().
+
+   init_extended_color() and extended_color_content() use integers for
+   the color index.  This enables us to have more than 32767 colors.
+
+   assume_default_colors() and use_default_colors() emulate the ncurses
+   extensions of the same names. assume_default_colors(f, b) is
+   essentially the same as init_pair(0, f, b) (which isn't allowed); it
+   redefines the default colors. use_default_colors() allows the use of
+   -1 as a foreground or background color with init_pair(), and calls
+   assume_default_colors(-1, -1); -1 represents the foreground or
+   background color that the terminal had at startup. If the environment
+   variable PDC_ORIGINAL_COLORS is set at the time start_color() is
+   called, that's equivalent to calling use_default_colors().
+
+   PDC_set_line_color() is used to set the color, globally, for the
+   color of the lines drawn for the attributes: A_UNDERLINE, A_LEFT and
+   A_RIGHT. A value of -1 (the default) indicates that the current
+   foreground color should be used.
+
+   NOTE: COLOR_PAIR() and PAIR_NUMBER() are implemented as macros.
+
+### Return Value
+
+   All functions return OK on success and ERR on error, except for
+   has_colors() and can_change_colors(), which return TRUE or FALSE.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    has_colors                  Y       Y       Y
+    start_color                 Y       Y       Y
+    init_pair                   Y       Y       Y
+    pair_content                Y       Y       Y
+    can_change_color            Y       Y       Y
+    init_color                  Y       Y       Y
+    color_content               Y       Y       Y
+    assume_default_colors       -       Y       Y
+    use_default_colors          -       Y       Y
+    PDC_set_line_color          -       -       -
+
+**man-end****************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <assert.h>
+
+int COLORS = 0;
+int COLOR_PAIRS = PDC_COLOR_PAIRS;
+static int atrtab_size_alloced;
+
+static bool default_colors = FALSE;
+static int first_col = 0;
+
+#define UNSET_COLOR_PAIR      -2
+
+int start_color(void)
+{
+    PDC_LOG(("start_color() - called\n"));
+
+    assert( SP);
+    if (!SP || SP->mono)
+        return ERR;
+
+    SP->color_started = TRUE;
+
+    PDC_set_blink(FALSE);   /* Also sets COLORS */
+
+    if (!default_colors && SP->orig_attr && getenv("PDC_ORIGINAL_COLORS"))
+        default_colors = TRUE;
+
+    PDC_init_atrtab();
+#if defined( CHTYPE_64) && !defined(OS2) && !defined(DOS)
+    if( COLORS >= 1024 && (long)INT_MAX > 1024L * 1024L)
+        COLOR_PAIRS = 1024 * 1024;
+    else if( COLORS >= 16)
+    {
+        if( (long)COLORS * (long)COLORS < (long)INT_MAX)
+            COLOR_PAIRS = COLORS * COLORS;
+        else
+            COLOR_PAIRS = INT_MAX;
+    }
+#endif
+    return OK;
+}
+
+static int _default_foreground_idx = COLOR_WHITE;
+static int _default_background_idx = COLOR_BLACK;
+
+void PDC_set_default_colors( const int fg_idx, const int bg_idx)
+{
+   _default_foreground_idx = fg_idx;
+   _default_background_idx = bg_idx;
+}
+
+static void _normalize(int *fg, int *bg)
+{
+    const bool using_defaults = (SP->orig_attr && (default_colors || !SP->color_started));
+
+    if (*fg == -1 || *fg == UNSET_COLOR_PAIR)
+        *fg = using_defaults ? SP->orig_fore : _default_foreground_idx;
+
+    if (*bg == -1 || *bg == UNSET_COLOR_PAIR)
+        *bg = using_defaults ? SP->orig_back : _default_background_idx;
+}
+
+static void _init_pair_core(int pair, int fg, int bg)
+{
+    PDC_PAIR *p;
+
+    assert( SP->atrtab);
+    assert( atrtab_size_alloced);
+    if( pair >= atrtab_size_alloced)
+    {
+        int i, new_size = atrtab_size_alloced * 2;
+
+        while( pair >= new_size)
+            new_size += new_size;
+        SP->atrtab = (PDC_PAIR *)realloc( SP->atrtab, new_size * sizeof( PDC_PAIR));
+        assert( SP->atrtab);
+        p = SP->atrtab + atrtab_size_alloced;
+        for( i = new_size - atrtab_size_alloced; i; i--, p++)
+        {
+            p->f = COLOR_GREEN;    /* signal uninitialized pairs by */
+            p->b = COLOR_YELLOW;   /* using unusual colors          */
+        }
+        atrtab_size_alloced = new_size;
+    }
+
+    assert( pair >= 0);
+    assert( pair < atrtab_size_alloced);
+    p = SP->atrtab + pair;
+
+    /* To allow the PDC_PRESERVE_SCREEN option to work, we only reset
+       curscr if this call to init_pair() alters a color pair created by
+       the user. */
+
+    _normalize(&fg, &bg);
+
+    if (p->f != UNSET_COLOR_PAIR)
+    {
+        if (p->f != fg || p->b != bg)
+            curscr->_clear = TRUE;
+    }
+    p->f = fg;
+    p->b = bg;
+}
+
+int init_extended_pair(int pair, int fg, int bg)
+{
+    PDC_LOG(("init_pair() - called: pair %d fg %d bg %d\n", pair, fg, bg));
+
+    assert( SP);
+    if (!SP || !SP->color_started || pair < 1 || pair >= COLOR_PAIRS ||
+        fg < first_col || fg >= COLORS || bg < first_col || bg >= COLORS)
+        return ERR;
+
+    _init_pair_core(pair, fg, bg);
+    curscr->_clear = TRUE;
+    return OK;
+}
+
+bool has_colors(void)
+{
+    PDC_LOG(("has_colors() - called\n"));
+
+    assert( SP);
+    return SP ? !(SP->mono) : FALSE;
+}
+
+int init_extended_color(int color, int red, int green, int blue)
+{
+    PDC_LOG(("init_color() - called\n"));
+
+    assert( SP);
+    if (!SP || color < 0 || color >= COLORS || !PDC_can_change_color() ||
+        red < -1 || red > 1000 || green < -1 || green > 1000 ||
+        blue < -1 || blue > 1000)
+        return ERR;
+
+    SP->dirty = TRUE;
+    curscr->_clear = TRUE;
+    return PDC_init_color(color, red, green, blue);
+}
+
+int extended_color_content(int color, int *red, int *green, int *blue)
+{
+    PDC_LOG(("color_content() - called\n"));
+
+    if (color < 0 || color >= COLORS || !red || !green || !blue)
+        return ERR;
+
+    if (PDC_can_change_color())
+        return PDC_color_content(color, red, green, blue);
+    else
+    {
+        /* Simulated values for platforms that don't support palette
+           changing */
+
+        int maxval = (color & 8) ? 1000 : 680;
+
+        *red = (color & COLOR_RED) ? maxval : 0;
+        *green = (color & COLOR_GREEN) ? maxval : 0;
+        *blue = (color & COLOR_BLUE) ? maxval : 0;
+
+        return OK;
+    }
+}
+
+bool can_change_color(void)
+{
+    PDC_LOG(("can_change_color() - called\n"));
+
+    return PDC_can_change_color();
+}
+
+int extended_pair_content(int pair, int *fg, int *bg)
+{
+    PDC_LOG(("pair_content() - called\n"));
+
+    if (pair < 0 || pair >= COLOR_PAIRS || !fg || !bg)
+        return ERR;
+
+    if( pair >= atrtab_size_alloced)
+    {
+        *fg = COLOR_RED;      /* signal use of uninitialized pair */
+        *bg = COLOR_BLUE;     /* with visible,  but odd,  colors  */
+    }
+    else
+    {
+        *fg = SP->atrtab[pair].f;
+        *bg = SP->atrtab[pair].b;
+    }
+    return OK;
+}
+
+int assume_default_colors(int f, int b)
+{
+    PDC_LOG(("assume_default_colors() - called: f %d b %d\n", f, b));
+
+    if (f < -1 || f >= COLORS || b < -1 || b >= COLORS)
+        return ERR;
+
+    if (SP->color_started)
+    {
+        _init_pair_core(0, f, b);
+        curscr->_clear = TRUE;
+    }
+
+    return OK;
+}
+
+int use_default_colors(void)
+{
+    PDC_LOG(("use_default_colors() - called\n"));
+
+    default_colors = TRUE;
+    first_col = -1;
+
+    return assume_default_colors(-1, -1);
+}
+
+int PDC_set_line_color(short color)
+{
+    PDC_LOG(("PDC_set_line_color() - called: %d\n", color));
+
+    assert( SP);
+    if (!SP || color < -1 || color >= COLORS)
+        return ERR;
+
+    SP->line_color = color;
+    curscr->_clear = TRUE;
+    return OK;
+}
+
+int PDC_init_atrtab(void)
+{
+    assert( SP);
+    if( !SP->atrtab)
+    {
+       atrtab_size_alloced = 1;
+       SP->atrtab = calloc( atrtab_size_alloced, sizeof(PDC_PAIR));
+       if( !SP->atrtab)
+           return -1;
+    }
+    _init_pair_core( 0, UNSET_COLOR_PAIR, UNSET_COLOR_PAIR);
+    return( 0);
+}
+
+int init_pair( short pair, short fg, short bg)
+{
+    return( init_extended_pair( (int)pair, (int)fg, (int)bg));
+}
+
+int pair_content( short pair, short *fg, short *bg)
+{
+    int i_fg, i_bg;
+    const int rval = extended_pair_content( (int)pair, &i_fg, &i_bg);
+
+    if( rval != ERR)
+    {
+        *fg = (short)i_fg;
+        *bg = (short)i_bg;
+    }
+    return( rval);
+}
+
+int init_color( short color, short red, short green, short blue)
+{
+    return( init_extended_color( (int)color, (int)red, (int)green, (int)blue));
+}
+
+int color_content( short color, short *red, short *green, short *blue)
+{
+    int i_red, i_green, i_blue;
+    const int rval = extended_color_content( (int)color, &i_red, &i_green, &i_blue);
+
+    if( rval != ERR)
+    {
+        *red   = (short)i_red;
+        *green = (short)i_green;
+        *blue  = (short)i_blue;
+    }
+    return( rval);
+}
diff --git a/lib/PDCursesMod/pdcurses/debug.c b/lib/PDCursesMod/pdcurses/debug.c
new file mode 100644
index 00000000000..2aaff6c722b
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/debug.c
@@ -0,0 +1,110 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+debug
+-----
+
+### Synopsis
+
+    void traceon(void);
+    void traceoff(void);
+    void PDC_debug(const char *, ...);
+
+### Description
+
+   traceon() and traceoff() toggle the recording of debugging
+   information to the file "trace". Although not standard, similar
+   functions are in some other curses implementations.
+
+   PDC_debug() is the function that writes to the file, based on whether
+   traceon() has been called. It's used from the PDC_LOG() macro.
+
+   The environment variable PDC_TRACE_FLUSH controls whether the trace
+   file contents are fflushed after each write. The default is not. Set
+   it to enable this (may affect performance).
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    traceon                     -       -       -
+    traceoff                    -       -       -
+    PDC_debug                   -       -       -
+
+**man-end****************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <time.h>
+
+static bool want_fflush = FALSE;
+
+void PDC_debug(const char *fmt, ...)
+{
+    va_list args;
+    char hms[9];
+    time_t now;
+
+    assert( SP);
+    if (!SP || !SP->dbfp)
+        return;
+
+    time(&now);
+    strftime(hms, 9, "%H:%M:%S", localtime(&now));
+    fprintf(SP->dbfp, "At: %8.8ld - %s ", (long) clock(), hms);
+
+    va_start(args, fmt);
+    vfprintf(SP->dbfp, fmt, args);
+    va_end(args);
+
+    /* If you are crashing and losing debugging information, enable this
+       by setting the environment variable PDC_TRACE_FLUSH. This may
+       impact performance. */
+
+    if (want_fflush)
+        fflush(SP->dbfp);
+
+    /* If with PDC_TRACE_FLUSH enabled you are still losing logging in
+       crashes, you may need to add a platform-dependent mechanism to
+       flush the OS buffers as well (such as fsync() on POSIX) -- but
+       expect terrible performance. */
+}
+
+void traceon(void)
+{
+    assert( SP);
+    if (!SP)
+        return;
+
+    if (SP->dbfp)
+        fclose(SP->dbfp);
+
+    /* open debug log file append */
+    SP->dbfp = fopen("trace", "a");
+    if (!SP->dbfp)
+    {
+        fprintf(stderr, "PDC_debug(): Unable to open debug log file\n");
+        return;
+    }
+
+    if (getenv("PDC_TRACE_FLUSH"))
+        want_fflush = TRUE;
+
+    PDC_LOG(("traceon() - called\n"));
+}
+
+void traceoff(void)
+{
+    assert( SP);
+    if (!SP || !SP->dbfp)
+        return;
+
+    PDC_LOG(("traceoff() - called\n"));
+
+    fclose(SP->dbfp);
+    SP->dbfp = NULL;
+    want_fflush = FALSE;
+}
diff --git a/lib/PDCursesMod/pdcurses/delch.c b/lib/PDCursesMod/pdcurses/delch.c
new file mode 100644
index 00000000000..3f9219c623b
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/delch.c
@@ -0,0 +1,98 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+delch
+-----
+
+### Synopsis
+
+    int delch(void);
+    int wdelch(WINDOW *win);
+    int mvdelch(int y, int x);
+    int mvwdelch(WINDOW *win, int y, int x);
+
+### Description
+
+   The character under the cursor in the window is deleted. All
+   characters to the right on the same line are moved to the left one
+   position and the last character on the line is filled with a blank.
+   The cursor position does not change (after moving to y, x if
+   coordinates are specified).
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    delch                       Y       Y       Y
+    wdelch                      Y       Y       Y
+    mvdelch                     Y       Y       Y
+    mvwdelch                    Y       Y       Y
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+int wdelch(WINDOW *win)
+{
+    int y, x, maxx;
+    chtype *temp1;
+
+    PDC_LOG(("wdelch() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    y = win->_cury;
+    x = win->_curx;
+    maxx = win->_maxx - 1;
+    temp1 = &win->_y[y][x];
+
+    memmove(temp1, temp1 + 1, (maxx - x) * sizeof(chtype));
+
+    /* wrs (4/10/93) account for window background */
+
+    win->_y[y][maxx] = win->_bkgd;
+
+    win->_lastch[y] = maxx;
+
+    if ((win->_firstch[y] == _NO_CHANGE) || (win->_firstch[y] > x))
+        win->_firstch[y] = x;
+
+    PDC_sync(win);
+
+    return OK;
+}
+
+int delch(void)
+{
+    PDC_LOG(("delch() - called\n"));
+
+    return wdelch(stdscr);
+}
+
+int mvdelch(int y, int x)
+{
+    PDC_LOG(("mvdelch() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wdelch(stdscr);
+}
+
+int mvwdelch(WINDOW *win, int y, int x)
+{
+    PDC_LOG(("mvwdelch() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wdelch(win);
+}
diff --git a/lib/PDCursesMod/pdcurses/deleteln.c b/lib/PDCursesMod/pdcurses/deleteln.c
new file mode 100644
index 00000000000..68072bca133
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/deleteln.c
@@ -0,0 +1,215 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+deleteln
+--------
+
+### Synopsis
+
+    int deleteln(void);
+    int wdeleteln(WINDOW *win);
+    int insdelln(int n);
+    int winsdelln(WINDOW *win, int n);
+    int insertln(void);
+    int winsertln(WINDOW *win);
+
+    int mvdeleteln(int y, int x);
+    int mvwdeleteln(WINDOW *win, int y, int x);
+    int mvinsertln(int y, int x);
+    int mvwinsertln(WINDOW *win, int y, int x);
+
+### Description
+
+   With the deleteln() and wdeleteln() functions, the line under the
+   cursor in the window is deleted. All lines below the current line are
+   moved up one line. The bottom line of the window is cleared. The
+   cursor position does not change.
+
+   With the insertln() and winsertn() functions, a blank line is
+   inserted above the current line and the bottom line is lost.
+
+   mvdeleteln(), mvwdeleteln(), mvinsertln() and mvwinsertln() allow
+   moving the cursor and inserting/deleting in one call.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    deleteln                    Y       Y       Y
+    wdeleteln                   Y       Y       Y
+    mvdeleteln                  -       -       -
+    mvwdeleteln                 -       -       -
+    insdelln                    Y       Y       Y
+    winsdelln                   Y       Y       Y
+    insertln                    Y       Y       Y
+    winsertln                   Y       Y       Y
+    mvinsertln                  -       -       -
+    mvwinsertln                 -       -       -
+
+**man-end****************************************************************/
+
+int wdeleteln(WINDOW *win)
+{
+    chtype blank, *temp, *ptr;
+    int y;
+
+    PDC_LOG(("wdeleteln() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    /* wrs (4/10/93) account for window background */
+
+    blank = win->_bkgd;
+
+    temp = win->_y[win->_cury];
+
+    for (y = win->_cury; y < win->_bmarg; y++)
+    {
+        win->_y[y] = win->_y[y + 1];
+        win->_firstch[y] = 0;
+        win->_lastch[y] = win->_maxx - 1;
+    }
+
+    for (ptr = temp; (ptr - temp < win->_maxx); ptr++)
+        *ptr = blank;           /* make a blank line */
+
+    if (win->_cury <= win->_bmarg)
+    {
+        win->_firstch[win->_bmarg] = 0;
+        win->_lastch[win->_bmarg] = win->_maxx - 1;
+        win->_y[win->_bmarg] = temp;
+    }
+
+    return OK;
+}
+
+int deleteln(void)
+{
+    PDC_LOG(("deleteln() - called\n"));
+
+    return wdeleteln(stdscr);
+}
+
+int mvdeleteln(int y, int x)
+{
+    PDC_LOG(("mvdeleteln() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wdeleteln(stdscr);
+}
+
+int mvwdeleteln(WINDOW *win, int y, int x)
+{
+    PDC_LOG(("mvwdeleteln() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wdeleteln(win);
+}
+
+int winsdelln(WINDOW *win, int n)
+{
+    int i;
+
+    PDC_LOG(("winsdelln() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    if (n > 0)
+    {
+        for (i = 0; i < n; i++)
+            if (winsertln(win) == ERR)
+                return ERR;
+    }
+    else if (n < 0)
+    {
+        n = -n;
+        for (i = 0; i < n; i++)
+            if (wdeleteln(win) == ERR)
+                return ERR;
+    }
+
+    return OK;
+}
+
+int insdelln(int n)
+{
+    PDC_LOG(("insdelln() - called\n"));
+
+    return winsdelln(stdscr, n);
+}
+
+int winsertln(WINDOW *win)
+{
+    chtype blank, *temp, *end;
+    int y;
+
+    PDC_LOG(("winsertln() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    /* wrs (4/10/93) account for window background */
+
+    blank = win->_bkgd;
+
+    temp = win->_y[win->_maxy - 1];
+
+    for (y = win->_maxy - 1; y > win->_cury; y--)
+    {
+        win->_y[y] = win->_y[y - 1];
+        win->_firstch[y] = 0;
+        win->_lastch[y] = win->_maxx - 1;
+    }
+
+    win->_y[win->_cury] = temp;
+
+    for (end = &temp[win->_maxx - 1]; temp <= end; temp++)
+        *temp = blank;
+
+    win->_firstch[win->_cury] = 0;
+    win->_lastch[win->_cury] = win->_maxx - 1;
+
+    return OK;
+}
+
+int insertln(void)
+{
+    PDC_LOG(("insertln() - called\n"));
+
+    return winsertln(stdscr);
+}
+
+int mvinsertln(int y, int x)
+{
+    PDC_LOG(("mvinsertln() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return winsertln(stdscr);
+}
+
+int mvwinsertln(WINDOW *win, int y, int x)
+{
+    PDC_LOG(("mvwinsertln() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return winsertln(win);
+}
diff --git a/lib/PDCursesMod/pdcurses/getch.c b/lib/PDCursesMod/pdcurses/getch.c
new file mode 100644
index 00000000000..7efac0cf96c
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/getch.c
@@ -0,0 +1,602 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+getch
+-----
+
+### Synopsis
+
+    int getch(void);
+    int wgetch(WINDOW *win);
+    int mvgetch(int y, int x);
+    int mvwgetch(WINDOW *win, int y, int x);
+    int ungetch(int ch);
+    int flushinp(void);
+
+    int get_wch(wint_t *wch);
+    int wget_wch(WINDOW *win, wint_t *wch);
+    int mvget_wch(int y, int x, wint_t *wch);
+    int mvwget_wch(WINDOW *win, int y, int x, wint_t *wch);
+    int unget_wch(const wchar_t wch);
+
+    unsigned long PDC_get_key_modifiers(void);
+    int PDC_return_key_modifiers(bool flag);
+
+### Description
+
+   With the getch(), wgetch(), mvgetch(), and mvwgetch() functions, a
+   character is read from the terminal associated with the window. In
+   nodelay mode, if there is no input waiting, the value ERR is
+   returned. In delay mode, the program will hang until the system
+   passes text through to the program. Depending on the setting of
+   cbreak(), this will be after one character or after the first
+   newline. Unless noecho() has been set, the character will also be
+   echoed into the designated window.
+
+   If keypad() is TRUE, and a function key is pressed, the token for
+   that function key will be returned instead of the raw characters.
+   Possible function keys are defined in <curses.h> with integers
+   beginning with 0401, whose names begin with KEY_.
+
+   If nodelay(win, TRUE) has been called on the window and no input is
+   waiting, the value ERR is returned.
+
+   ungetch() places ch back onto the input queue to be returned by the
+   next call to wgetch().
+
+   flushinp() throws away any type-ahead that has been typed by the user
+   and has not yet been read by the program.
+
+   wget_wch() is the wide-character version of wgetch(), available when
+   PDCurses is built with the PDC_WIDE option. It takes a pointer to a
+   wint_t rather than returning the key as an int, and instead returns
+   KEY_CODE_YES if the key is a function key. Otherwise, it returns OK
+   or ERR. It's important to check for KEY_CODE_YES, since regular wide
+   characters can have the same values as function key codes.
+
+   unget_wch() puts a wide character on the input queue.
+
+   PDC_get_key_modifiers() returns the keyboard modifiers (shift,
+   control, alt, numlock) effective at the time of the last getch()
+   call. Use the macros PDC_KEY_MODIFIER_* to determine which
+   modifier(s) were set. PDC_return_key_modifiers() tells getch() to
+   return modifier keys pressed alone as keystrokes (KEY_ALT_L, etc.).
+   These may not work on all platforms.
+
+   NOTE: getch() and ungetch() are implemented as macros, to avoid
+   conflict with many DOS compiler's runtime libraries.
+
+### Return Value
+
+   These functions return ERR or the value of the character, meta
+   character or function key token.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    getch                       Y       Y       Y
+    wgetch                      Y       Y       Y
+    mvgetch                     Y       Y       Y
+    mvwgetch                    Y       Y       Y
+    ungetch                     Y       Y       Y
+    flushinp                    Y       Y       Y
+    get_wch                     Y       Y       Y
+    wget_wch                    Y       Y       Y
+    mvget_wch                   Y       Y       Y
+    mvwget_wch                  Y       Y       Y
+    unget_wch                   Y       Y       Y
+    PDC_get_key_modifiers       -       -       -
+
+**man-end****************************************************************/
+
+#include <stdlib.h>
+
+static int _get_box(int *y_start, int *y_end, int *x_start, int *x_end)
+{
+    int start, end;
+
+    if (SP->sel_start < SP->sel_end)
+    {
+        start = SP->sel_start;
+        end = SP->sel_end;
+    }
+    else
+    {
+        start = SP->sel_end;
+        end = SP->sel_start;
+    }
+
+    *y_start = start / COLS;
+    *x_start = start % COLS;
+
+    *y_end = end / COLS;
+    *x_end = end % COLS;
+
+    return (end - start) + (*y_end - *y_start);
+}
+
+static bool _highlight(void)
+{
+    int i, j, y_start, y_end, x_start, x_end;
+
+    if (-1 == SP->sel_start || SP->sel_start == SP->sel_end)
+        return( FALSE);
+
+    _get_box(&y_start, &y_end, &x_start, &x_end);
+
+    for (j = y_start; j <= y_end; j++)
+        for (i = (j == y_start ? x_start : 0);
+             i < (j == y_end ? x_end : COLS); i++)
+            curscr->_y[j][i] ^= A_REVERSE;
+    return( TRUE);
+}
+
+static void _copy(void)
+{
+#ifdef PDC_WIDE
+    wchar_t *wtmp;
+# define TMP wtmp
+# define MASK A_CHARTEXT
+#else
+# define TMP tmp
+# define MASK 0xff
+#endif
+    char *tmp;
+    long pos;
+    int i, j, y_start, y_end, x_start, x_end, len;
+
+    if (-1 == SP->sel_start)
+        return;
+
+    len = _get_box(&y_start, &y_end, &x_start, &x_end);
+
+    if (!len)
+        return;
+
+#ifdef PDC_WIDE
+    wtmp = malloc((len + 1) * sizeof(wchar_t));
+    len *= 3;
+#endif
+    tmp = malloc(len + 1);
+
+    for (j = y_start, pos = 0; j <= y_end; j++)
+    {
+        for (i = (j == y_start ? x_start : 0);
+             i < (j == y_end ? x_end : COLS); i++)
+#ifdef PDC_WIDE
+            wtmp[pos++] = (wchar_t)( curscr->_y[j][i] & MASK);
+#else
+            tmp[pos++] = (char)( curscr->_y[j][i] & MASK);
+#endif
+
+        while (y_start != y_end && pos > 0 && TMP[pos - 1] == 32)
+            pos--;
+
+        if (j < y_end)
+            TMP[pos++] = 10;
+    }
+    TMP[pos] = 0;
+
+#ifdef PDC_WIDE
+    pos = (long)PDC_wcstombs(tmp, wtmp, len);
+#endif
+
+    PDC_setclipboard(tmp, pos);
+    free(tmp);
+#ifdef PDC_WIDE
+    free(wtmp);
+#endif
+}
+
+static int _paste(void)
+{
+#ifdef PDC_WIDE
+    wchar_t *wpaste;
+# define PASTE wpaste
+#else
+# define PASTE paste
+#endif
+    char *paste;
+    long len, newmax;
+    int key;
+
+    key = PDC_getclipboard(&paste, &len);
+    if (PDC_CLIP_SUCCESS != key || !len)
+        return -1;
+
+#ifdef PDC_WIDE
+    wpaste = malloc(len * sizeof(wchar_t));
+    len = (long)PDC_mbstowcs(wpaste, paste, len);
+#endif
+    newmax = len + SP->c_ungind;
+    if (newmax > SP->c_ungmax)
+    {
+        SP->c_ungch = realloc(SP->c_ungch, newmax * sizeof(int));
+        if (!SP->c_ungch)
+            return -1;
+        SP->c_ungmax = newmax;
+    }
+    while (len > 1)
+        PDC_ungetch(PASTE[--len]);
+    key = *PASTE;
+#ifdef PDC_WIDE
+    free(wpaste);
+#endif
+    PDC_freeclipboard(paste);
+    SP->key_modifiers = 0;
+
+    return key;
+}
+
+static int _mouse_key(void)
+{
+    int i, key = KEY_MOUSE, changes = SP->mouse_status.changes;
+    const unsigned long mbe = SP->_trap_mbe;
+    bool can_select = !(mbe & (BUTTON1_MOVED | BUTTON1_PRESSED | BUTTON1_RELEASED));
+    bool can_paste = !(mbe & BUTTON2_CLICKED);
+            /* really means 'can do these things without shift' */
+
+    /* Selection highlighting? */
+
+    if ((can_select || SP->mouse_status.button[0] & BUTTON_SHIFT) && changes & 1)
+    {
+        i = SP->mouse_status.y * COLS + SP->mouse_status.x;
+        switch (SP->mouse_status.button[0] & BUTTON_ACTION_MASK)
+        {
+        case BUTTON_PRESSED:
+            if( _highlight())
+                wrefresh(curscr);
+            SP->sel_start = SP->sel_end = i;
+            return -1;
+        case BUTTON_MOVED:
+            {
+            const bool refresh_needed = _highlight();
+
+            SP->sel_end = i;
+            if( _highlight() || refresh_needed)
+                wrefresh(curscr);
+            return -1;
+            }
+        case BUTTON_RELEASED:
+            _copy();
+            return -1;
+        }
+    }
+    else if ((can_paste || SP->mouse_status.button[1] & BUTTON_SHIFT) &&
+             changes & 2 && (SP->mouse_status.button[1] &
+             BUTTON_ACTION_MASK) == BUTTON_CLICKED)
+    {
+        SP->key_code = FALSE;
+        return _paste();
+    }
+
+    /* Filter unwanted mouse events */
+
+    for (i = 0; i < 3; i++)
+    {
+        if (changes & (1 << i))
+        {
+            int shf = i * 5;
+            short button = SP->mouse_status.button[i] & BUTTON_ACTION_MASK;
+
+            if (   (!(mbe & (BUTTON1_PRESSED << shf)) &&
+                    (button == BUTTON_PRESSED))
+
+                || (!(mbe & (BUTTON1_CLICKED << shf)) &&
+                    (button == BUTTON_CLICKED))
+
+                || (!(mbe & (BUTTON1_DOUBLE_CLICKED << shf)) &&
+                    (button == BUTTON_DOUBLE_CLICKED))
+
+                || (!(mbe & (BUTTON1_TRIPLE_CLICKED << shf)) &&
+                    (button == BUTTON_TRIPLE_CLICKED))
+
+                || (!(mbe & (BUTTON1_MOVED << shf)) &&
+                    (button == BUTTON_MOVED))
+
+                || (!(mbe & (BUTTON1_RELEASED << shf)) &&
+                    (button == BUTTON_RELEASED))
+            )
+                SP->mouse_status.changes ^= (1 << i);
+        }
+    }
+
+    if (changes & PDC_MOUSE_MOVED)
+    {
+        if (!(mbe & (BUTTON1_MOVED|BUTTON2_MOVED|BUTTON3_MOVED | REPORT_MOUSE_POSITION)))
+            SP->mouse_status.changes ^= PDC_MOUSE_MOVED;
+    }
+
+    if (changes & (PDC_MOUSE_WHEEL_UP|PDC_MOUSE_WHEEL_DOWN))
+    {
+        if (!(mbe & MOUSE_WHEEL_SCROLL))
+            SP->mouse_status.changes &=
+                ~(PDC_MOUSE_WHEEL_UP|PDC_MOUSE_WHEEL_DOWN);
+    }
+
+    if (!changes)
+        return -1;
+
+    /* Check for click in slk area */
+
+    i = PDC_mouse_in_slk(SP->mouse_status.y, SP->mouse_status.x);
+
+    if (i)
+    {
+        if (SP->mouse_status.button[0] & (BUTTON_PRESSED|BUTTON_CLICKED))
+            key = KEY_F(i);
+        else
+            key = -1;
+    }
+
+    return key;
+}
+
+#define WAIT_FOREVER    -1
+
+int wgetch(WINDOW *win)
+{
+    int key, remaining_millisecs;
+
+    PDC_LOG(("wgetch() - called\n"));
+
+    assert( SP);
+    assert( win);
+    if (!win || !SP)
+        return ERR;
+
+    if (SP->delaytenths)
+        remaining_millisecs = 100 * SP->delaytenths;
+    else
+        remaining_millisecs = win->_delayms;
+    if( !remaining_millisecs && !win->_nodelay)
+        remaining_millisecs = WAIT_FOREVER;
+
+    /* refresh window when wgetch is called if there have been changes
+       to it and it is not a pad */
+
+    if (!(win->_flags & _PAD) && ((!win->_leaveit &&
+         (win->_begx + win->_curx != SP->curscol ||
+          win->_begy + win->_cury != SP->cursrow)) || is_wintouched(win)))
+        wrefresh(win);
+
+    /* if ungotten char exists, remove and return it */
+
+    if (SP->c_ungind)
+        return SP->c_ungch[--(SP->c_ungind)];
+
+    /* if normal and data in buffer */
+
+    if ((!SP->raw_inp && !SP->cbreak) && (SP->c_gindex < SP->c_pindex))
+        return SP->c_buffer[SP->c_gindex++];
+
+    /* prepare to buffer data */
+
+    SP->c_pindex = 0;
+    SP->c_gindex = 0;
+
+    /* to get here, no keys are buffered. go and get one. */
+
+    for (;;)            /* loop for any buffering */
+    {
+        /* is there a keystroke ready? */
+
+        while( !PDC_check_key())
+        {
+            /* if not, handle timeout() and halfdelay() */
+            int nap_time = 50;
+
+            if (remaining_millisecs != WAIT_FOREVER)
+            {
+                if (!remaining_millisecs)
+                    return ERR;
+                if( nap_time > remaining_millisecs)
+                    nap_time = remaining_millisecs;
+                remaining_millisecs -= nap_time;
+            }
+            napms( nap_time);
+        }
+
+        /* if there is, fetch it */
+
+        key = PDC_get_key();
+
+        /* copy or paste? */
+
+#ifndef _WIN32
+        if (SP->key_modifiers & PDC_KEY_MODIFIER_SHIFT)
+#endif
+        {
+            if (0x03 == key)
+            {
+                _copy();
+                continue;
+            }
+            else if (0x16 == key)
+                key = _paste();
+        }
+
+        /* filter mouse events; translate mouse clicks in the slk
+           area to function keys */
+
+        if (SP->key_code && key == KEY_MOUSE)
+            key = _mouse_key();
+
+        /* filter special keys if not in keypad mode */
+
+        if (SP->key_code && !win->_use_keypad)
+            key = -1;
+
+        /* unwanted key? loop back */
+
+        if (key == -1)
+            continue;
+
+        if( _highlight())
+            wrefresh(curscr);
+        SP->sel_start = SP->sel_end = -1;
+
+        /* translate CR */
+
+        if (key == '\r' && SP->autocr && !SP->raw_inp)
+            key = '\n';
+
+        /* if echo is enabled */
+
+        if (SP->echo && !SP->key_code)
+        {
+            waddch(win, key);
+            wrefresh(win);
+        }
+
+        /* if no buffering */
+
+        if (SP->raw_inp || SP->cbreak)
+            return key;
+
+        /* if no overflow, put data in buffer */
+
+        if (key == '\b')
+        {
+            if (SP->c_pindex > SP->c_gindex)
+                SP->c_pindex--;
+        }
+        else
+            if (SP->c_pindex < _INBUFSIZ - 2)
+                SP->c_buffer[SP->c_pindex++] = key;
+
+        /* if we got a line */
+
+        if (key == '\n' || key == '\r')
+            return SP->c_buffer[SP->c_gindex++];
+    }
+}
+
+int mvgetch(int y, int x)
+{
+    PDC_LOG(("mvgetch() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wgetch(stdscr);
+}
+
+int mvwgetch(WINDOW *win, int y, int x)
+{
+    PDC_LOG(("mvwgetch() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wgetch(win);
+}
+
+int PDC_ungetch(int ch)
+{
+    PDC_LOG(("ungetch() - called\n"));
+
+    if (SP->c_ungind >= SP->c_ungmax)   /* pushback stack full */
+        return ERR;
+
+    SP->c_ungch[SP->c_ungind++] = ch;
+
+    return OK;
+}
+
+int flushinp(void)
+{
+    PDC_LOG(("flushinp() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    PDC_flushinp();
+
+    SP->c_gindex = 1;       /* set indices to kill buffer */
+    SP->c_pindex = 0;
+    SP->c_ungind = 0;       /* clear SP->c_ungch array */
+
+    return OK;
+}
+
+unsigned long PDC_get_key_modifiers(void)
+{
+    PDC_LOG(("PDC_get_key_modifiers() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return (unsigned long)ERR;
+
+    return SP->key_modifiers;
+}
+
+int PDC_return_key_modifiers(bool flag)
+{
+    PDC_LOG(("PDC_return_key_modifiers() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->return_key_modifiers = flag;
+    return PDC_modifiers_set();
+}
+
+#ifdef PDC_WIDE
+int wget_wch(WINDOW *win, wint_t *wch)
+{
+    int key;
+
+    PDC_LOG(("wget_wch() - called\n"));
+
+    assert( wch);
+    if (!wch)
+        return ERR;
+
+    key = wgetch(win);
+
+    if (key == ERR)
+        return ERR;
+
+    *wch = (wint_t)key;
+
+    return SP->key_code ? KEY_CODE_YES : OK;
+}
+
+int get_wch(wint_t *wch)
+{
+    PDC_LOG(("get_wch() - called\n"));
+
+    return wget_wch(stdscr, wch);
+}
+
+int mvget_wch(int y, int x, wint_t *wch)
+{
+    PDC_LOG(("mvget_wch() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wget_wch(stdscr, wch);
+}
+
+int mvwget_wch(WINDOW *win, int y, int x, wint_t *wch)
+{
+    PDC_LOG(("mvwget_wch() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wget_wch(win, wch);
+}
+
+int unget_wch(const wchar_t wch)
+{
+    return PDC_ungetch(wch);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/getstr.c b/lib/PDCursesMod/pdcurses/getstr.c
new file mode 100644
index 00000000000..f909b4182ab
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/getstr.c
@@ -0,0 +1,480 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+getstr
+------
+
+### Synopsis
+
+    int getstr(char *str);
+    int wgetstr(WINDOW *win, char *str);
+    int mvgetstr(int y, int x, char *str);
+    int mvwgetstr(WINDOW *win, int y, int x, char *str);
+    int getnstr(char *str, int n);
+    int wgetnstr(WINDOW *win, char *str, int n);
+    int mvgetnstr(int y, int x, char *str, int n);
+    int mvwgetnstr(WINDOW *win, int y, int x, char *str, int n);
+
+    int get_wstr(wint_t *wstr);
+    int wget_wstr(WINDOW *win, wint_t *wstr);
+    int mvget_wstr(int y, int x, wint_t *wstr);
+    int mvwget_wstr(WINDOW *win, int, int, wint_t *wstr);
+    int getn_wstr(wint_t *wstr, int n);
+    int wgetn_wstr(WINDOW *win, wint_t *wstr, int n);
+    int mvgetn_wstr(int y, int x, wint_t *wstr, int n);
+    int mvwgetn_wstr(WINDOW *win, int y, int x, wint_t *wstr, int n);
+
+### Description
+
+   These routines call wgetch() repeatedly to build a string,
+   interpreting erase and kill characters along the way, until a newline
+   or carriage return is received. When PDCurses is built with wide-
+   character support enabled, the narrow-character functions convert the
+   wgetch()'d values into a multibyte string in the current locale
+   before returning it. The resulting string is placed in the area
+   pointed to by *str. The routines with n as the last argument read at
+   most n characters.
+
+   Note that there's no way to know how long the buffer passed to
+   wgetstr() is, so use wgetnstr() to avoid buffer overflows.
+
+### Return Value
+
+   These functions return ERR on failure or any other value on success.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    getstr                      Y       Y       Y
+    wgetstr                     Y       Y       Y
+    mvgetstr                    Y       Y       Y
+    mvwgetstr                   Y       Y       Y
+    getnstr                     Y       Y       Y
+    wgetnstr                    Y       Y       Y
+    mvgetnstr                   Y       Y       Y
+    mvwgetnstr                  Y       Y       Y
+    get_wstr                    Y       Y       Y
+    wget_wstr                   Y       Y       Y
+    mvget_wstr                  Y       Y       Y
+    mvwget_wstr                 Y       Y       Y
+    getn_wstr                   Y       Y       Y
+    wgetn_wstr                  Y       Y       Y
+    mvgetn_wstr                 Y       Y       Y
+    mvwgetn_wstr                Y       Y       Y
+
+**man-end****************************************************************/
+
+#define MAXLINE 255
+
+int wgetnstr(WINDOW *win, char *str, int n)
+{
+#ifdef PDC_WIDE
+    wchar_t wstr[MAXLINE + 1];
+
+    if (n < 0 || n > MAXLINE)
+        n = MAXLINE;
+
+    if (wgetn_wstr(win, (wint_t *)wstr, n) == ERR)
+        return ERR;
+
+    return (int)PDC_wcstombs(str, wstr, n);
+#else
+    int ch, i, num, x, chars;
+    char *p;
+    bool stop, oldecho, oldcbreak, oldnodelay;
+
+    PDC_LOG(("wgetnstr() - called\n"));
+
+    assert( win);
+    assert( str);
+    assert( SP);
+    if (!win || !str)
+        return ERR;
+
+    chars = 0;
+    p = str;
+    stop = FALSE;
+
+    x = win->_curx;
+
+    oldcbreak = SP->cbreak; /* remember states */
+    oldecho = SP->echo;
+    oldnodelay = win->_nodelay;
+
+    SP->echo = FALSE;       /* we do echo ourselves */
+    cbreak();               /* ensure each key is returned immediately */
+    win->_nodelay = FALSE;  /* don't return -1 */
+
+    wrefresh(win);
+
+    while (!stop)
+    {
+        ch = wgetch(win);
+
+        switch (ch)
+        {
+
+        case '\t':
+            ch = ' ';
+            num = TABSIZE - (win->_curx - x) % TABSIZE;
+            for (i = 0; i < num; i++)
+            {
+                if (chars < n)
+                {
+                    if (oldecho)
+                        waddch(win, ch);
+                    *p++ = (char)ch;
+                    ++chars;
+                }
+                else
+                    beep();
+            }
+            break;
+
+        case _ECHAR:        /* CTRL-H -- Delete character */
+            if (p > str)
+            {
+                if (oldecho)
+                    waddstr(win, "\b \b");
+                ch = (unsigned char)(*--p);
+                if ((ch < ' ') && (oldecho))
+                    waddstr(win, "\b \b");
+                chars--;
+            }
+            break;
+
+        case _DLCHAR:       /* CTRL-U -- Delete line */
+            while (p > str)
+            {
+                if (oldecho)
+                    waddstr(win, "\b \b");
+                ch = (unsigned char)(*--p);
+                if ((ch < ' ') && (oldecho))
+                    waddstr(win, "\b \b");
+            }
+            chars = 0;
+            break;
+
+        case _DWCHAR:       /* CTRL-W -- Delete word */
+
+            while ((p > str) && (*(p - 1) == ' '))
+            {
+                if (oldecho)
+                    waddstr(win, "\b \b");
+
+                --p;        /* remove space */
+                chars--;
+            }
+            while ((p > str) && (*(p - 1) != ' '))
+            {
+                if (oldecho)
+                    waddstr(win, "\b \b");
+
+                ch = (unsigned char)(*--p);
+                if ((ch < ' ') && (oldecho))
+                    waddstr(win, "\b \b");
+                chars--;
+            }
+            break;
+
+        case '\n':
+        case '\r':
+            stop = TRUE;
+            if (oldecho)
+                waddch(win, '\n');
+            break;
+
+        default:
+            if (chars < n)
+            {
+                if (!SP->key_code && ch < 0x100)
+                {
+                    *p++ = (char)ch;
+                    if (oldecho)
+                        waddch(win, ch);
+                    chars++;
+                }
+            }
+            else
+                beep();
+
+            break;
+
+        }
+
+        wrefresh(win);
+    }
+
+    *p = '\0';
+
+    SP->echo = oldecho;     /* restore old settings */
+    SP->cbreak = oldcbreak;
+    win->_nodelay = oldnodelay;
+
+    return OK;
+#endif
+}
+
+int getstr(char *str)
+{
+    PDC_LOG(("getstr() - called\n"));
+
+    return wgetnstr(stdscr, str, MAXLINE);
+}
+
+int wgetstr(WINDOW *win, char *str)
+{
+    PDC_LOG(("wgetstr() - called\n"));
+
+    return wgetnstr(win, str, MAXLINE);
+}
+
+int mvgetstr(int y, int x, char *str)
+{
+    PDC_LOG(("mvgetstr() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wgetnstr(stdscr, str, MAXLINE);
+}
+
+int mvwgetstr(WINDOW *win, int y, int x, char *str)
+{
+    PDC_LOG(("mvwgetstr() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wgetnstr(win, str, MAXLINE);
+}
+
+int getnstr(char *str, int n)
+{
+    PDC_LOG(("getnstr() - called\n"));
+
+    return wgetnstr(stdscr, str, n);
+}
+
+int mvgetnstr(int y, int x, char *str, int n)
+{
+    PDC_LOG(("mvgetnstr() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wgetnstr(stdscr, str, n);
+}
+
+int mvwgetnstr(WINDOW *win, int y, int x, char *str, int n)
+{
+    PDC_LOG(("mvwgetnstr() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wgetnstr(win, str, n);
+}
+
+#ifdef PDC_WIDE
+int wgetn_wstr(WINDOW *win, wint_t *wstr, int n)
+{
+    int ch, i, num, x, chars;
+    wint_t *p;
+    bool stop, oldecho, oldcbreak, oldnodelay;
+
+    PDC_LOG(("wgetn_wstr() - called\n"));
+
+    assert( win);
+    assert( wstr);
+    assert( SP);
+    if (!win || !wstr)
+        return ERR;
+
+    chars = 0;
+    p = wstr;
+    stop = FALSE;
+
+    x = win->_curx;
+
+    oldcbreak = SP->cbreak; /* remember states */
+    oldecho = SP->echo;
+    oldnodelay = win->_nodelay;
+
+    SP->echo = FALSE;       /* we do echo ourselves */
+    cbreak();               /* ensure each key is returned immediately */
+    win->_nodelay = FALSE;  /* don't return -1 */
+
+    wrefresh(win);
+
+    while (!stop)
+    {
+        ch = wgetch(win);
+
+        switch (ch)
+        {
+
+        case '\t':
+            ch = ' ';
+            num = TABSIZE - (win->_curx - x) % TABSIZE;
+            for (i = 0; i < num; i++)
+            {
+                if (chars < n)
+                {
+                    if (oldecho)
+                        waddch(win, ch);
+                    *p++ = (wint_t)ch;
+                    ++chars;
+                }
+                else
+                    beep();
+            }
+            break;
+
+        case _ECHAR:        /* CTRL-H -- Delete character */
+            if (p > wstr)
+            {
+                if (oldecho)
+                    waddstr(win, "\b \b");
+                ch = *--p;
+                if ((ch < ' ') && (oldecho))
+                    waddstr(win, "\b \b");
+                chars--;
+            }
+            break;
+
+        case _DLCHAR:       /* CTRL-U -- Delete line */
+            while (p > wstr)
+            {
+                if (oldecho)
+                    waddstr(win, "\b \b");
+                ch = *--p;
+                if ((ch < ' ') && (oldecho))
+                    waddstr(win, "\b \b");
+            }
+            chars = 0;
+            break;
+
+        case _DWCHAR:       /* CTRL-W -- Delete word */
+
+            while ((p > wstr) && (*(p - 1) == ' '))
+            {
+                if (oldecho)
+                    waddstr(win, "\b \b");
+
+                --p;        /* remove space */
+                chars--;
+            }
+            while ((p > wstr) && (*(p - 1) != ' '))
+            {
+                if (oldecho)
+                    waddstr(win, "\b \b");
+
+                ch = *--p;
+                if ((ch < ' ') && (oldecho))
+                    waddstr(win, "\b \b");
+                chars--;
+            }
+            break;
+
+        case '\n':
+        case '\r':
+            stop = TRUE;
+            if (oldecho)
+                waddch(win, '\n');
+            break;
+
+        default:
+            if (chars < n)
+            {
+                if (!SP->key_code)
+                {
+                    *p++ = (wint_t)ch;
+                    if (oldecho)
+                        waddch(win, ch);
+                    chars++;
+                }
+            }
+            else
+                beep();
+
+            break;
+
+        }
+
+        wrefresh(win);
+    }
+
+    *p = '\0';
+
+    SP->echo = oldecho;     /* restore old settings */
+    SP->cbreak = oldcbreak;
+    win->_nodelay = oldnodelay;
+
+    return OK;
+}
+
+int get_wstr(wint_t *wstr)
+{
+    PDC_LOG(("get_wstr() - called\n"));
+
+    return wgetn_wstr(stdscr, wstr, MAXLINE);
+}
+
+int wget_wstr(WINDOW *win, wint_t *wstr)
+{
+    PDC_LOG(("wget_wstr() - called\n"));
+
+    return wgetn_wstr(win, wstr, MAXLINE);
+}
+
+int mvget_wstr(int y, int x, wint_t *wstr)
+{
+    PDC_LOG(("mvget_wstr() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wgetn_wstr(stdscr, wstr, MAXLINE);
+}
+
+int mvwget_wstr(WINDOW *win, int y, int x, wint_t *wstr)
+{
+    PDC_LOG(("mvwget_wstr() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wgetn_wstr(win, wstr, MAXLINE);
+}
+
+int getn_wstr(wint_t *wstr, int n)
+{
+    PDC_LOG(("getn_wstr() - called\n"));
+
+    return wgetn_wstr(stdscr, wstr, n);
+}
+
+int mvgetn_wstr(int y, int x, wint_t *wstr, int n)
+{
+    PDC_LOG(("mvgetn_wstr() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wgetn_wstr(stdscr, wstr, n);
+}
+
+int mvwgetn_wstr(WINDOW *win, int y, int x, wint_t *wstr, int n)
+{
+    PDC_LOG(("mvwgetn_wstr() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wgetn_wstr(win, wstr, n);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/getyx.c b/lib/PDCursesMod/pdcurses/getyx.c
new file mode 100644
index 00000000000..0f9b7c8cd3e
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/getyx.c
@@ -0,0 +1,151 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+getyx
+-----
+
+### Synopsis
+
+    void getyx(WINDOW *win, int y, int x);
+    void getparyx(WINDOW *win, int y, int x);
+    void getbegyx(WINDOW *win, int y, int x);
+    void getmaxyx(WINDOW *win, int y, int x);
+
+    void getsyx(int y, int x);
+    void setsyx(int y, int x);
+
+    int getbegy(WINDOW *win);
+    int getbegx(WINDOW *win);
+    int getcury(WINDOW *win);
+    int getcurx(WINDOW *win);
+    int getpary(WINDOW *win);
+    int getparx(WINDOW *win);
+    int getmaxy(WINDOW *win);
+    int getmaxx(WINDOW *win);
+
+### Description
+
+   The getyx() macro (defined in curses.h -- the prototypes here are
+   merely illustrative) puts the current cursor position of the
+   specified window into y and x. getbegyx() and getmaxyx() return the
+   starting coordinates and size of the specified window, respectively.
+   getparyx() returns the starting coordinates of the parent's window,
+   if the specified window is a subwindow; otherwise it sets y and x to
+   -1. These are all macros.
+
+   getsyx() gets the coordinates of the virtual screen cursor, and
+   stores them in y and x. If leaveok() is TRUE, it returns -1, -1. If
+   lines have been removed with ripoffline(), then getsyx() includes
+   these lines in its count; so, the returned y and x values should only
+   be used with setsyx().
+
+   setsyx() sets the virtual screen cursor to the y, x coordinates. If
+   either y or x is -1, leaveok() is set TRUE, else it's set FALSE.
+
+   getsyx() and setsyx() are meant to be used by a library routine that
+   manipulates curses windows without altering the position of the
+   cursor. Note that getsyx() is defined only as a macro.
+
+   getbegy(), getbegx(), getcurx(), getcury(), getmaxy(), getmaxx(),
+   getpary(), and getparx() return the appropriate coordinate or size
+   values, or ERR in the case of a NULL window.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    getyx                       Y       Y       Y
+    getparyx                    Y       Y       Y
+    getbegyx                    Y       Y       Y
+    getmaxyx                    Y       Y       Y
+    getsyx                      -       Y       Y
+    setsyx                      -       Y       Y
+    getbegy                     -       Y       Y
+    getbegx                     -       Y       Y
+    getcury                     -       Y       Y
+    getcurx                     -       Y       Y
+    getpary                     -       Y       Y
+    getparx                     -       Y       Y
+    getmaxy                     -       Y       Y
+    getmaxx                     -       Y       Y
+
+**man-end****************************************************************/
+
+int getbegy(WINDOW *win)
+{
+    PDC_LOG(("getbegy() - called\n"));
+
+    assert( win);
+    return win ? win->_begy : ERR;
+}
+
+int getbegx(WINDOW *win)
+{
+    PDC_LOG(("getbegx() - called\n"));
+
+    assert( win);
+    return win ? win->_begx : ERR;
+}
+
+int getcury(WINDOW *win)
+{
+    PDC_LOG(("getcury() - called\n"));
+
+    assert( win);
+    return win ? win->_cury : ERR;
+}
+
+int getcurx(WINDOW *win)
+{
+    PDC_LOG(("getcurx() - called\n"));
+
+    assert( win);
+    return win ? win->_curx : ERR;
+}
+
+int getpary(WINDOW *win)
+{
+    PDC_LOG(("getpary() - called\n"));
+
+    assert( win);
+    return win ? win->_pary : ERR;
+}
+
+int getparx(WINDOW *win)
+{
+    PDC_LOG(("getparx() - called\n"));
+
+    assert( win);
+    return win ? win->_parx : ERR;
+}
+
+int getmaxy(WINDOW *win)
+{
+    PDC_LOG(("getmaxy() - called\n"));
+
+    assert( win);
+    return win ? win->_maxy : ERR;
+}
+
+int getmaxx(WINDOW *win)
+{
+    PDC_LOG(("getmaxx() - called\n"));
+
+    assert( win);
+    return win ? win->_maxx : ERR;
+}
+
+void setsyx(int y, int x)
+{
+    PDC_LOG(("setsyx() - called\n"));
+
+    if (curscr)
+    {
+        curscr->_leaveit = y == -1 || x == -1;
+
+        if (!curscr->_leaveit)
+            wmove(curscr, y, x);
+    }
+}
diff --git a/lib/PDCursesMod/pdcurses/inch.c b/lib/PDCursesMod/pdcurses/inch.c
new file mode 100644
index 00000000000..c5293bcd691
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/inch.c
@@ -0,0 +1,132 @@
+/* PDCurses */
+
+#include <assert.h>
+#include <curspriv.h>
+
+/*man-start**************************************************************
+
+inch
+----
+
+### Synopsis
+
+    chtype inch(void);
+    chtype winch(WINDOW *win);
+    chtype mvinch(int y, int x);
+    chtype mvwinch(WINDOW *win, int y, int x);
+
+    int in_wch(cchar_t *wcval);
+    int win_wch(WINDOW *win, cchar_t *wcval);
+    int mvin_wch(int y, int x, cchar_t *wcval);
+    int mvwin_wch(WINDOW *win, int y, int x, cchar_t *wcval);
+
+### Description
+
+   The inch() functions retrieve the character and attribute from the
+   current or specified window position, in the form of a chtype. If a
+   NULL window is specified, (chtype)ERR is returned.
+
+   The in_wch() functions are the wide-character versions; instead of
+   returning a chtype, they store a cchar_t at the address specified by
+   wcval, and return OK or ERR. (No value is stored when ERR is
+   returned.) Note that in PDCurses, chtype and cchar_t are the same.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    inch                        Y       Y       Y
+    winch                       Y       Y       Y
+    mvinch                      Y       Y       Y
+    mvwinch                     Y       Y       Y
+    in_wch                      Y       Y       Y
+    win_wch                     Y       Y       Y
+    mvin_wch                    Y       Y       Y
+    mvwin_wch                   Y       Y       Y
+
+**man-end****************************************************************/
+
+chtype winch(WINDOW *win)
+{
+    PDC_LOG(("winch() - called\n"));
+
+    assert( win);
+    if (!win)
+        return (chtype)ERR;
+
+    return win->_y[win->_cury][win->_curx];
+}
+
+chtype inch(void)
+{
+    PDC_LOG(("inch() - called\n"));
+
+    return winch(stdscr);
+}
+
+chtype mvinch(int y, int x)
+{
+    PDC_LOG(("mvinch() - called\n"));
+
+    if (move(y, x) == ERR)
+        return (chtype)ERR;
+
+    return stdscr->_y[stdscr->_cury][stdscr->_curx];
+}
+
+chtype mvwinch(WINDOW *win, int y, int x)
+{
+    PDC_LOG(("mvwinch() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return (chtype)ERR;
+
+    return win->_y[win->_cury][win->_curx];
+}
+
+#ifdef PDC_WIDE
+int win_wch(WINDOW *win, cchar_t *wcval)
+{
+    PDC_LOG(("win_wch() - called\n"));
+
+    assert( win);
+    assert( wcval);
+    if (!win || !wcval)
+        return ERR;
+
+    *wcval = win->_y[win->_cury][win->_curx];
+
+    return OK;
+}
+
+int in_wch(cchar_t *wcval)
+{
+    PDC_LOG(("in_wch() - called\n"));
+
+    return win_wch(stdscr, wcval);
+}
+
+int mvin_wch(int y, int x, cchar_t *wcval)
+{
+    PDC_LOG(("mvin_wch() - called\n"));
+
+    assert( wcval);
+    if (!wcval || (move(y, x) == ERR))
+        return ERR;
+
+    *wcval = stdscr->_y[stdscr->_cury][stdscr->_curx];
+
+    return OK;
+}
+
+int mvwin_wch(WINDOW *win, int y, int x, cchar_t *wcval)
+{
+    PDC_LOG(("mvwin_wch() - called\n"));
+
+    assert( wcval);
+    if (!wcval || (wmove(win, y, x) == ERR))
+        return ERR;
+
+    *wcval = win->_y[win->_cury][win->_curx];
+
+    return OK;
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/inchstr.c b/lib/PDCursesMod/pdcurses/inchstr.c
new file mode 100644
index 00000000000..6718539504b
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/inchstr.c
@@ -0,0 +1,216 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+inchstr
+-------
+
+### Synopsis
+
+    int inchstr(chtype *ch);
+    int inchnstr(chtype *ch, int n);
+    int winchstr(WINDOW *win, chtype *ch);
+    int winchnstr(WINDOW *win, chtype *ch, int n);
+    int mvinchstr(int y, int x, chtype *ch);
+    int mvinchnstr(int y, int x, chtype *ch, int n);
+    int mvwinchstr(WINDOW *, int y, int x, chtype *ch);
+    int mvwinchnstr(WINDOW *, int y, int x, chtype *ch, int n);
+
+    int in_wchstr(cchar_t *wch);
+    int in_wchnstr(cchar_t *wch, int n);
+    int win_wchstr(WINDOW *win, cchar_t *wch);
+    int win_wchnstr(WINDOW *win, cchar_t *wch, int n);
+    int mvin_wchstr(int y, int x, cchar_t *wch);
+    int mvin_wchnstr(int y, int x, cchar_t *wch, int n);
+    int mvwin_wchstr(WINDOW *win, int y, int x, cchar_t *wch);
+    int mvwin_wchnstr(WINDOW *win, int y, int x, cchar_t *wch, int n);
+
+### Description
+
+   These routines read a chtype or cchar_t string from the window,
+   starting at the current or specified position, and ending at the
+   right margin, or after n elements, whichever is less.
+
+### Return Value
+
+   All functions return the number of elements read, or ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    inchstr                     Y       Y       Y
+    winchstr                    Y       Y       Y
+    mvinchstr                   Y       Y       Y
+    mvwinchstr                  Y       Y       Y
+    inchnstr                    Y       Y       Y
+    winchnstr                   Y       Y       Y
+    mvinchnstr                  Y       Y       Y
+    mvwinchnstr                 Y       Y       Y
+    in_wchstr                   Y       Y       Y
+    win_wchstr                  Y       Y       Y
+    mvin_wchstr                 Y       Y       Y
+    mvwin_wchstr                Y       Y       Y
+    in_wchnstr                  Y       Y       Y
+    win_wchnstr                 Y       Y       Y
+    mvin_wchnstr                Y       Y       Y
+    mvwin_wchnstr               Y       Y       Y
+
+**man-end****************************************************************/
+
+int winchnstr(WINDOW *win, chtype *ch, int n)
+{
+    chtype *src;
+    int i;
+
+    PDC_LOG(("winchnstr() - called\n"));
+
+    assert( win);
+    assert( ch);
+    if (!win || !ch || n < 0)
+        return ERR;
+
+    if ((win->_curx + n) > win->_maxx)
+        n = win->_maxx - win->_curx;
+
+    src = win->_y[win->_cury] + win->_curx;
+
+    for (i = 0; i < n; i++)
+        *ch++ = *src++;
+
+    *ch = (chtype)0;
+
+    return OK;
+}
+
+int inchstr(chtype *ch)
+{
+    PDC_LOG(("inchstr() - called\n"));
+
+    return winchnstr(stdscr, ch, stdscr->_maxx - stdscr->_curx);
+}
+
+int winchstr(WINDOW *win, chtype *ch)
+{
+    PDC_LOG(("winchstr() - called\n"));
+
+    return winchnstr(win, ch, win->_maxx - win->_curx);
+}
+
+int mvinchstr(int y, int x, chtype *ch)
+{
+    PDC_LOG(("mvinchstr() - called: y %d x %d\n", y, x));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return winchnstr(stdscr, ch, stdscr->_maxx - stdscr->_curx);
+}
+
+int mvwinchstr(WINDOW *win, int y, int x, chtype *ch)
+{
+    PDC_LOG(("mvwinchstr() - called:\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return winchnstr(win, ch, win->_maxx - win->_curx);
+}
+
+int inchnstr(chtype *ch, int n)
+{
+    PDC_LOG(("inchnstr() - called\n"));
+
+    return winchnstr(stdscr, ch, n);
+}
+
+int mvinchnstr(int y, int x, chtype *ch, int n)
+{
+    PDC_LOG(("mvinchnstr() - called: y %d x %d n %d\n", y, x, n));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return winchnstr(stdscr, ch, n);
+}
+
+int mvwinchnstr(WINDOW *win, int y, int x, chtype *ch, int n)
+{
+    PDC_LOG(("mvwinchnstr() - called: y %d x %d n %d \n", y, x, n));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return winchnstr(win, ch, n);
+}
+
+#ifdef PDC_WIDE
+int win_wchnstr(WINDOW *win, cchar_t *wch, int n)
+{
+    PDC_LOG(("win_wchnstr() - called\n"));
+
+    return winchnstr(win, wch, n);
+}
+
+int in_wchstr(cchar_t *wch)
+{
+    PDC_LOG(("in_wchstr() - called\n"));
+
+    return win_wchnstr(stdscr, wch, stdscr->_maxx - stdscr->_curx);
+}
+
+int win_wchstr(WINDOW *win, cchar_t *wch)
+{
+    PDC_LOG(("win_wchstr() - called\n"));
+
+    return win_wchnstr(win, wch, win->_maxx - win->_curx);
+}
+
+int mvin_wchstr(int y, int x, cchar_t *wch)
+{
+    PDC_LOG(("mvin_wchstr() - called: y %d x %d\n", y, x));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return win_wchnstr(stdscr, wch, stdscr->_maxx - stdscr->_curx);
+}
+
+int mvwin_wchstr(WINDOW *win, int y, int x, cchar_t *wch)
+{
+    PDC_LOG(("mvwin_wchstr() - called:\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return win_wchnstr(win, wch, win->_maxx - win->_curx);
+}
+
+int in_wchnstr(cchar_t *wch, int n)
+{
+    PDC_LOG(("in_wchnstr() - called\n"));
+
+    return win_wchnstr(stdscr, wch, n);
+}
+
+int mvin_wchnstr(int y, int x, cchar_t *wch, int n)
+{
+    PDC_LOG(("mvin_wchnstr() - called: y %d x %d n %d\n", y, x, n));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return win_wchnstr(stdscr, wch, n);
+}
+
+int mvwin_wchnstr(WINDOW *win, int y, int x, cchar_t *wch, int n)
+{
+    PDC_LOG(("mvwinchnstr() - called: y %d x %d n %d \n", y, x, n));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return win_wchnstr(win, wch, n);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/initscr.c b/lib/PDCursesMod/pdcurses/initscr.c
new file mode 100644
index 00000000000..ed443558ba4
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/initscr.c
@@ -0,0 +1,483 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <panel.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+initscr
+-------
+
+### Synopsis
+
+    WINDOW *initscr(void);
+    WINDOW *Xinitscr(int argc, char **argv);
+    int endwin(void);
+    bool isendwin(void);
+    SCREEN *newterm(const char *type, FILE *outfd, FILE *infd);
+    SCREEN *set_term(SCREEN *new);
+    void delscreen(SCREEN *sp);
+
+    int resize_term(int nlines, int ncols);
+    bool is_termresized(void);
+    const char *curses_version(void);
+    void PDC_get_version(PDC_VERSION *ver);
+
+    int set_tabsize(int tabsize);
+
+### Description
+
+   initscr() should be the first curses routine called. It will
+   initialize all curses data structures, and arrange that the first
+   call to refresh() will clear the screen. In case of error, initscr()
+   will write a message to standard error and end the program.
+
+   endwin() should be called before exiting or escaping from curses mode
+   temporarily. It will restore tty modes, move the cursor to the lower
+   left corner of the screen and reset the terminal into the proper
+   non-visual mode. To resume curses after a temporary escape, call
+   refresh() or doupdate().
+
+   isendwin() returns TRUE if endwin() has been called without a
+   subsequent refresh, unless SP is NULL.
+
+   In some implementations of curses, newterm() allows the use of
+   multiple terminals. Here, it's just an alternative interface for
+   initscr(). It always returns SP, or NULL.
+
+   delscreen() frees the memory allocated by newterm() or initscr(),
+   since it's not freed by endwin(). This function is usually not
+   needed. In PDCurses, the parameter must be the value of SP, and
+   delscreen() sets SP to NULL.
+
+   set_term() does nothing meaningful in PDCurses, but is included for
+   compatibility with other curses implementations.
+
+   resize_term() is effectively two functions: When called with nonzero
+   values for nlines and ncols, it attempts to resize the screen to the
+   given size. When called with (0, 0), it merely adjusts the internal
+   structures to match the current size after the screen is resized by
+   the user. On the currently supported platforms, SDL, Windows console,
+   and X11 allow user resizing, while DOS, OS/2, SDL and Windows console
+   allow programmatic resizing. If you want to support user resizing,
+   you should check for getch() returning KEY_RESIZE, and/or call
+   is_termresized() at appropriate times; if either condition occurs,
+   call resize_term(0, 0). Then, with either user or programmatic
+   resizing, you'll have to resize any windows you've created, as
+   appropriate; resize_term() only handles stdscr and curscr.
+
+   is_termresized() returns TRUE if the curses screen has been resized
+   by the user, and a call to resize_term() is needed. Checking for
+   KEY_RESIZE is generally preferable, unless you're not handling the
+   keyboard.
+
+   curses_version() returns a string describing the version of PDCurses.
+
+   PDC_get_version() fills a PDC_VERSION structure provided by the user
+   with more detailed version info (see curses.h).
+
+   set_tabsize() sets the tab interval, stored in TABSIZE.
+
+### Return Value
+
+   All functions return NULL on error, except endwin(), which always
+   returns OK, and resize_term(), which returns either OK or ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    initscr                     Y       Y       Y
+    endwin                      Y       Y       Y
+    isendwin                    Y       Y       Y
+    newterm                     Y       Y       Y
+    set_term                    Y       Y       Y
+    delscreen                   Y       Y       Y
+    resize_term                 -       Y       Y
+    set_tabsize                 -       Y       Y
+    curses_version              -       Y       -
+    is_termresized              -       -       -
+
+**man-end****************************************************************/
+
+#include <stdlib.h>
+
+char ttytype[128];
+
+#if PDC_VER_MONTH == 1
+   #define PDC_VER_MONTH_STR "Jan"
+#elif PDC_VER_MONTH == 2
+   #define PDC_VER_MONTH_STR "Feb"
+#elif PDC_VER_MONTH == 3
+   #define PDC_VER_MONTH_STR "Mar"
+#elif PDC_VER_MONTH == 4
+   #define PDC_VER_MONTH_STR "Apr"
+#elif PDC_VER_MONTH == 5
+   #define PDC_VER_MONTH_STR "May"
+#elif PDC_VER_MONTH == 6
+   #define PDC_VER_MONTH_STR "Jun"
+#elif PDC_VER_MONTH == 7
+   #define PDC_VER_MONTH_STR "Jul"
+#elif PDC_VER_MONTH == 8
+   #define PDC_VER_MONTH_STR "Aug"
+#elif PDC_VER_MONTH == 9
+   #define PDC_VER_MONTH_STR "Sep"
+#elif PDC_VER_MONTH == 10
+   #define PDC_VER_MONTH_STR "Oct"
+#elif PDC_VER_MONTH == 11
+   #define PDC_VER_MONTH_STR "Nov"
+#elif PDC_VER_MONTH == 12
+   #define PDC_VER_MONTH_STR "Dec"
+#else
+   #define PDC_VER_MONTH_STR "!!!"
+#endif
+
+const char *_curses_notice = "PDCurses " PDC_VERDOT " - "\
+                    PDC_stringize( PDC_VER_YEAR) "-" \
+                    PDC_VER_MONTH_STR "-" \
+                    PDC_stringize( PDC_VER_DAY);
+
+SCREEN *SP = (SCREEN*)NULL;           /* curses variables */
+WINDOW *curscr = (WINDOW *)NULL;      /* the current screen image */
+WINDOW *stdscr = (WINDOW *)NULL;      /* the default screen window */
+
+int LINES = 0;                        /* current terminal height */
+int COLS = 0;                         /* current terminal width */
+int TABSIZE = 8;
+
+MOUSE_STATUS Mouse_status;
+
+extern RIPPEDOFFLINE linesripped[5];
+extern char linesrippedoff;
+
+WINDOW *initscr(void)
+{
+    int i;
+
+    PDC_LOG(("initscr() - called\n"));
+
+    if (SP && SP->alive)
+        return NULL;
+    SP = calloc(1, sizeof(SCREEN));
+    assert( SP);
+    if (!SP)
+        return NULL;
+
+    if (PDC_scr_open() == ERR)
+    {
+        fprintf(stderr, "initscr(): Unable to create SP\n");
+        exit(8);
+    }
+
+    SP->autocr = TRUE;       /* cr -> lf by default */
+    SP->raw_out = FALSE;     /* tty I/O modes */
+    SP->raw_inp = FALSE;     /* tty I/O modes */
+    SP->cbreak = TRUE;
+    SP->key_modifiers = 0L;
+    SP->return_key_modifiers = FALSE;
+    SP->echo = TRUE;
+    SP->visibility = 1;
+    SP->resized = FALSE;
+    SP->_trap_mbe = 0L;
+    SP->linesrippedoff = 0;
+    SP->linesrippedoffontop = 0;
+    SP->delaytenths = 0;
+    SP->line_color = -1;
+    SP->lastscr = (WINDOW *)NULL;
+    SP->dbfp = NULL;
+    SP->color_started = FALSE;
+    SP->dirty = FALSE;
+    SP->sel_start = -1;
+    SP->sel_end = -1;
+
+    SP->orig_cursor = PDC_get_cursor_mode();
+
+    LINES = SP->lines = PDC_get_rows();
+    COLS = SP->cols = PDC_get_columns();
+
+    if (LINES < 2 || COLS < 2)
+    {
+        fprintf(stderr, "initscr(): LINES=%d COLS=%d: too small.\n",
+                LINES, COLS);
+        exit(4);
+    }
+
+    curscr = newwin(LINES, COLS, 0, 0);
+    if (!curscr)
+    {
+        fprintf(stderr, "initscr(): Unable to create curscr.\n");
+        exit(2);
+    }
+
+    SP->lastscr = newwin(LINES, COLS, 0, 0);
+    if (!SP->lastscr)
+    {
+        fprintf(stderr, "initscr(): Unable to create SP->lastscr.\n");
+        exit(2);
+    }
+
+    wattrset(SP->lastscr, (chtype)(-1));
+    werase(SP->lastscr);
+
+    PDC_slk_initialize();
+    LINES -= SP->slklines;
+
+    /* We have to sort out ripped off lines here, and reduce the height
+       of stdscr by the number of lines ripped off */
+
+    for (i = 0; i < linesrippedoff; i++)
+    {
+        if (linesripped[i].line < 0)
+            (*linesripped[i].init)(newwin(1, COLS, LINES - 1, 0), COLS);
+        else
+            (*linesripped[i].init)(newwin(1, COLS,
+                                   SP->linesrippedoffontop++, 0), COLS);
+
+        SP->linesrippedoff++;
+        LINES--;
+    }
+
+    linesrippedoff = 0;
+
+    stdscr = newwin(LINES, COLS, SP->linesrippedoffontop, 0);
+    if (!stdscr)
+    {
+        fprintf(stderr, "initscr(): Unable to create stdscr.\n");
+        exit(1);
+    }
+
+    wclrtobot(stdscr);
+
+    /* If preserving the existing screen, don't allow a screen clear */
+
+    if (SP->_preserve)
+    {
+        untouchwin(curscr);
+        untouchwin(stdscr);
+        stdscr->_clear = FALSE;
+        curscr->_clear = FALSE;
+    }
+    else
+        curscr->_clear = TRUE;
+
+    if( PDC_init_atrtab())   /* set up default colors */
+        return NULL;
+
+    MOUSE_X_POS = MOUSE_Y_POS = -1;
+    BUTTON_STATUS(1) = BUTTON_RELEASED;
+    BUTTON_STATUS(2) = BUTTON_RELEASED;
+    BUTTON_STATUS(3) = BUTTON_RELEASED;
+    Mouse_status.changes = 0;
+
+    SP->alive = TRUE;
+
+    def_shell_mode();
+
+    sprintf(ttytype, "pdcurses|PDCurses for %s", PDC_sysname());
+
+    SP->c_buffer = malloc(_INBUFSIZ * sizeof(int));
+    if (!SP->c_buffer)
+        return NULL;
+    SP->c_pindex = 0;
+    SP->c_gindex = 1;
+
+    SP->c_ungch = malloc(NUNGETCH * sizeof(int));
+    if (!SP->c_ungch)
+        return NULL;
+    SP->c_ungind = 0;
+    SP->c_ungmax = NUNGETCH;
+
+    return stdscr;
+}
+
+#ifdef XCURSES
+WINDOW *Xinitscr(int argc, char **argv)
+{
+    PDC_LOG(("Xinitscr() - called\n"));
+
+    PDC_set_args(argc, argv);
+    return initscr();
+}
+#endif
+
+int endwin(void)
+{
+    PDC_LOG(("endwin() - called\n"));
+
+    /* Allow temporary exit from curses using endwin() */
+
+    def_prog_mode();
+    PDC_scr_close();
+
+    assert( SP);
+    SP->alive = FALSE;
+
+    return OK;
+}
+
+bool isendwin(void)
+{
+    PDC_LOG(("isendwin() - called\n"));
+
+    assert( SP);
+    return SP ? !(SP->alive) : FALSE;
+}
+
+SCREEN *newterm(const char *type, FILE *outfd, FILE *infd)
+{
+    PDC_LOG(("newterm() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( type);
+    INTENTIONALLY_UNUSED_PARAMETER( outfd);
+    INTENTIONALLY_UNUSED_PARAMETER( infd);
+    return initscr() ? SP : NULL;
+}
+
+SCREEN *set_term(SCREEN *new)
+{
+    PDC_LOG(("set_term() - called\n"));
+
+    /* We only support one screen */
+
+    return (new == SP) ? SP : NULL;
+}
+
+void delscreen(SCREEN *sp)
+{
+    PDC_LOG(("delscreen() - called\n"));
+
+    assert( SP);
+    if (!SP || sp != SP)
+        return;
+
+    free(SP->c_ungch);
+    free(SP->c_buffer);
+    free(SP->atrtab);
+
+    PDC_slk_free();     /* free the soft label keys, if needed */
+
+    delwin(stdscr);
+    delwin(curscr);
+    delwin(SP->lastscr);
+    stdscr = (WINDOW *)NULL;
+    curscr = (WINDOW *)NULL;
+    SP->lastscr = (WINDOW *)NULL;
+
+    SP->alive = FALSE;
+
+    PDC_scr_free();
+
+    free(SP);
+    SP = (SCREEN *)NULL;
+}
+
+int resize_term(int nlines, int ncols)
+{
+    PANEL *panel_ptr = NULL;
+
+    PDC_LOG(("resize_term() - called: nlines %d\n", nlines));
+
+    if( PDC_resize_screen(nlines, ncols) == ERR)
+        return ERR;
+
+    if( !stdscr)
+        return OK;
+
+    SP->resized = FALSE;
+
+    SP->lines = PDC_get_rows();
+    LINES = SP->lines - SP->linesrippedoff - SP->slklines;
+    SP->cols = COLS = PDC_get_columns();
+
+    if (SP->cursrow >= SP->lines)
+        SP->cursrow = SP->lines - 1;
+    if (SP->curscol >= SP->cols)
+        SP->curscol = SP->cols - 1;
+
+    if (wresize(curscr, SP->lines, SP->cols) == ERR ||
+        wresize(stdscr, LINES, COLS) == ERR ||
+        wresize(SP->lastscr, SP->lines, SP->cols) == ERR)
+        return ERR;
+
+    werase(SP->lastscr);
+    curscr->_clear = TRUE;
+
+    if (SP->slk_winptr)
+    {
+        if (wresize(SP->slk_winptr, SP->slklines, COLS) == ERR)
+            return ERR;
+
+        wmove(SP->slk_winptr, 0, 0);
+        wclrtobot(SP->slk_winptr);
+        PDC_slk_initialize();
+        slk_noutrefresh();
+    }
+
+    touchwin(stdscr);
+    wnoutrefresh(stdscr);
+
+    while( (panel_ptr = panel_above( panel_ptr)) != NULL)
+    {
+        touchwin(panel_window(panel_ptr));
+        wnoutrefresh(panel_window(panel_ptr));
+    }
+    return OK;
+}
+
+bool is_termresized(void)
+{
+    PDC_LOG(("is_termresized() - called\n"));
+
+    return SP->resized;
+}
+
+const char *curses_version(void)
+{
+    return _curses_notice;
+}
+
+void PDC_get_version(PDC_VERSION *ver)
+{
+    extern enum PDC_port PDC_port_val;
+
+    assert( ver);
+    if (!ver)
+        return;
+
+    ver->flags = 0
+#ifdef PDCDEBUG
+        | PDC_VFLAG_DEBUG
+#endif
+#ifdef PDC_WIDE
+        | PDC_VFLAG_WIDE
+#endif
+#ifdef PDC_FORCE_UTF8
+        | PDC_VFLAG_UTF8
+#endif
+#ifdef PDC_DLL_BUILD
+        | PDC_VFLAG_DLL
+#endif
+#ifdef PDC_RGB
+        | PDC_VFLAG_RGB
+#endif
+        ;
+
+    ver->build = PDC_BUILD;
+    ver->major = PDC_VER_MAJOR;
+    ver->minor = PDC_VER_MINOR;
+    ver->change = PDC_VER_CHANGE;
+    ver->csize = sizeof(chtype);
+    ver->bsize = sizeof(bool);
+    ver->port = PDC_port_val;
+}
+
+int set_tabsize(int tabsize)
+{
+    PDC_LOG(("set_tabsize() - called: tabsize %d\n", tabsize));
+
+    if (tabsize < 1)
+        return ERR;
+
+    TABSIZE = tabsize;
+
+    return OK;
+}
diff --git a/lib/PDCursesMod/pdcurses/inopts.c b/lib/PDCursesMod/pdcurses/inopts.c
new file mode 100644
index 00000000000..13b7d120ab6
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/inopts.c
@@ -0,0 +1,389 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+inopts
+------
+
+### Synopsis
+
+    int cbreak(void);
+    int nocbreak(void);
+    int echo(void);
+    int noecho(void);
+    int halfdelay(int tenths);
+    int intrflush(WINDOW *win, bool bf);
+    int keypad(WINDOW *win, bool bf);
+    int meta(WINDOW *win, bool bf);
+    int nl(void);
+    int nonl(void);
+    int nodelay(WINDOW *win, bool bf);
+    int notimeout(WINDOW *win, bool bf);
+    int raw(void);
+    int noraw(void);
+    void noqiflush(void);
+    void qiflush(void);
+    void timeout(int delay);
+    void wtimeout(WINDOW *win, int delay);
+    int typeahead(int fildes);
+
+    int crmode(void);
+    int nocrmode(void);
+
+    bool is_keypad(const WINDOW *win);
+
+### Description
+
+   cbreak() and nocbreak() toggle cbreak mode. In cbreak mode,
+   characters typed by the user are made available immediately, and
+   erase/kill character processing is not performed. In nocbreak mode,
+   typed characters are buffered until a newline or carriage return.
+   Interrupt and flow control characters are unaffected by this mode.
+   PDCurses always starts in cbreak mode.
+
+   echo() and noecho() control whether typed characters are echoed by
+   the input routine. Initially, input characters are echoed. Subsequent
+   calls to echo() and noecho() do not flush type-ahead.
+
+   halfdelay() is similar to cbreak(), but allows for a time limit to be
+   specified, in tenths of a second. This causes getch() to block for
+   that period before returning ERR if no key has been received. tenths
+   must be between 1 and 255.
+
+   keypad() controls whether getch() returns function/special keys as
+   single key codes (e.g., the left arrow key as KEY_LEFT). Per X/Open,
+   the default for keypad mode is OFF. You'll probably want it on. With
+   keypad mode off, if a special key is pressed, getch() does nothing or
+   returns ERR.
+
+   nodelay() controls whether wgetch() is a non-blocking call. If the
+   option is enabled, and no input is ready, wgetch() will return ERR.
+   If disabled, wgetch() will hang until input is ready.
+
+   nl() enables the translation of a carriage return into a newline on
+   input. nonl() disables this. Initially, the translation does occur.
+
+   raw() and noraw() toggle raw mode. Raw mode is similar to cbreak
+   mode, in that characters typed are immediately passed through to the
+   user program. The difference is that in raw mode, the INTR, QUIT,
+   SUSP, and STOP characters are passed through without being
+   interpreted, and without generating a signal.
+
+   In PDCurses, the meta() function sets raw mode on or off.
+
+   timeout() and wtimeout() set blocking or non-blocking reads for the
+   specified window. If the delay is negative, a blocking read is used;
+   if zero, then non-blocking reads are done -- if no input is waiting,
+   ERR is returned immediately. If the delay is positive, the read
+   blocks for the delay period; if the period expires, ERR is returned.
+   The delay is given in milliseconds, but this is rounded down to 50ms
+   (1/20th sec) intervals, with a minimum of one interval if a postive
+   delay is given; i.e., 1-99 will wait 50ms, 100-149 will wait 100ms,
+   etc.
+
+   intrflush(), notimeout(), noqiflush(), qiflush() and typeahead() do
+   nothing in PDCurses, but are included for compatibility with other
+   curses implementations.
+
+   crmode() and nocrmode() are archaic equivalents to cbreak() and
+   nocbreak(), respectively.
+
+   is_keypad() reports whether the specified window is in keypad mode.
+
+### Return Value
+
+   All functions except is_keypad() and the void functions return OK on
+   success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    cbreak                      Y       Y       Y
+    nocbreak                    Y       Y       Y
+    echo                        Y       Y       Y
+    noecho                      Y       Y       Y
+    halfdelay                   Y       Y       Y
+    intrflush                   Y       Y       Y
+    keypad                      Y       Y       Y
+    meta                        Y       Y       Y
+    nl                          Y       Y       Y
+    nonl                        Y       Y       Y
+    nodelay                     Y       Y       Y
+    notimeout                   Y       Y       Y
+    raw                         Y       Y       Y
+    noraw                       Y       Y       Y
+    noqiflush                   Y       Y       Y
+    qiflush                     Y       Y       Y
+    timeout                     Y       Y       Y
+    wtimeout                    Y       Y       Y
+    typeahead                   Y       Y       Y
+    crmode                      Y       Y       Y
+    nocrmode                    Y       Y       Y
+    is_keypad                   -       Y       Y
+
+**man-end****************************************************************/
+
+int cbreak(void)
+{
+    PDC_LOG(("cbreak() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->cbreak = TRUE;
+
+    return OK;
+}
+
+int nocbreak(void)
+{
+    PDC_LOG(("nocbreak() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->cbreak = FALSE;
+    SP->delaytenths = 0;
+
+    return OK;
+}
+
+int echo(void)
+{
+    PDC_LOG(("echo() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->echo = TRUE;
+
+    return OK;
+}
+
+int noecho(void)
+{
+    PDC_LOG(("noecho() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->echo = FALSE;
+
+    return OK;
+}
+
+int halfdelay(int tenths)
+{
+    PDC_LOG(("halfdelay() - called\n"));
+
+    assert( SP);
+    if (!SP || tenths < 1 || tenths > 255)
+        return ERR;
+
+    SP->delaytenths = tenths;
+
+    return OK;
+}
+
+int intrflush(WINDOW *win, bool bf)
+{
+    PDC_LOG(("intrflush() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( win);
+    INTENTIONALLY_UNUSED_PARAMETER( bf);
+    return OK;
+}
+
+int keypad(WINDOW *win, bool bf)
+{
+    PDC_LOG(("keypad() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_use_keypad = bf;
+
+    return OK;
+}
+
+int meta(WINDOW *win, bool bf)
+{
+    PDC_LOG(("meta() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( win);
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->raw_inp = bf;
+
+    return OK;
+}
+
+int nl(void)
+{
+    PDC_LOG(("nl() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->autocr = TRUE;
+
+    return OK;
+}
+
+int nonl(void)
+{
+    PDC_LOG(("nonl() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->autocr = FALSE;
+
+    return OK;
+}
+
+int nodelay(WINDOW *win, bool flag)
+{
+    PDC_LOG(("nodelay() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_nodelay = flag;
+
+    return OK;
+}
+
+int notimeout(WINDOW *win, bool flag)
+{
+    PDC_LOG(("notimeout() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( win);
+    INTENTIONALLY_UNUSED_PARAMETER( flag);
+    return OK;
+}
+
+int raw(void)
+{
+    PDC_LOG(("raw() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    PDC_set_keyboard_binary(TRUE);
+    SP->raw_inp = TRUE;
+
+    return OK;
+}
+
+int noraw(void)
+{
+    PDC_LOG(("noraw() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    PDC_set_keyboard_binary(FALSE);
+    SP->raw_inp = FALSE;
+
+    return OK;
+}
+
+void noqiflush(void)
+{
+    PDC_LOG(("noqiflush() - called\n"));
+}
+
+void qiflush(void)
+{
+    PDC_LOG(("qiflush() - called\n"));
+}
+
+int typeahead(int fildes)
+{
+    INTENTIONALLY_UNUSED_PARAMETER( fildes);
+    PDC_LOG(("typeahead() - called\n"));
+
+    return OK;
+}
+
+void wtimeout(WINDOW *win, int delay)
+{
+    PDC_LOG(("wtimeout() - called\n"));
+
+    assert( win);
+    if (!win)
+        return;
+
+    if (delay < 0)
+    {
+        /* This causes a blocking read on the window, so turn on delay
+           mode */
+
+        win->_nodelay = FALSE;
+        win->_delayms = 0;
+    }
+    else if (!delay)
+    {
+        /* This causes a non-blocking read on the window, so turn off
+           delay mode */
+
+        win->_nodelay = TRUE;
+        win->_delayms = 0;
+    }
+    else
+    {
+        /* This causes the read on the window to delay for the number of
+           milliseconds. Also forces the window into non-blocking read
+           mode */
+
+        /*win->_nodelay = TRUE;*/
+        win->_delayms = delay;
+    }
+}
+
+void timeout(int delay)
+{
+    PDC_LOG(("timeout() - called\n"));
+
+    wtimeout(stdscr, delay);
+}
+
+int crmode(void)
+{
+    PDC_LOG(("crmode() - called\n"));
+
+    return cbreak();
+}
+
+int nocrmode(void)
+{
+    PDC_LOG(("nocrmode() - called\n"));
+
+    return nocbreak();
+}
+
+bool is_keypad(const WINDOW *win)
+{
+    PDC_LOG(("is_keypad() - called\n"));
+
+    assert( win);
+    if (!win)
+        return FALSE;
+
+    return win->_use_keypad;
+}
diff --git a/lib/PDCursesMod/pdcurses/insch.c b/lib/PDCursesMod/pdcurses/insch.c
new file mode 100644
index 00000000000..cf829fe2134
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/insch.c
@@ -0,0 +1,274 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+insch
+-----
+
+### Synopsis
+
+    int insch(chtype ch);
+    int winsch(WINDOW *win, chtype ch);
+    int mvinsch(int y, int x, chtype ch);
+    int mvwinsch(WINDOW *win, int y, int x, chtype ch);
+
+    int insrawch(chtype ch);
+    int winsrawch(WINDOW *win, chtype ch);
+    int mvinsrawch(int y, int x, chtype ch);
+    int mvwinsrawch(WINDOW *win, int y, int x, chtype ch);
+
+    int ins_wch(const cchar_t *wch);
+    int wins_wch(WINDOW *win, const cchar_t *wch);
+    int mvins_wch(int y, int x, const cchar_t *wch);
+    int mvwins_wch(WINDOW *win, int y, int x, const cchar_t *wch);
+
+### Description
+
+   The insch() functions insert a chtype into the window at the current
+   or specified cursor position. The cursor is NOT advanced. A newline
+   is equivalent to clrtoeol(); tabs are expanded; other control
+   characters are converted as with unctrl().
+
+   The ins_wch() functions are the wide-character equivalents, taking
+   cchar_t pointers rather than chtypes.
+
+   Video attributes can be combined with a character by ORing them into
+   the parameter. Text, including attributes, can be copied from one
+   place to another using inch() and insch().
+
+   insrawch() etc. are PDCurses-specific wrappers for insch() etc. that
+   disable the translation of control characters.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    insch                       Y       Y       Y
+    winsch                      Y       Y       Y
+    mvinsch                     Y       Y       Y
+    mvwinsch                    Y       Y       Y
+    ins_wch                     Y       Y       Y
+    wins_wch                    Y       Y       Y
+    mvins_wch                   Y       Y       Y
+    mvwins_wch                  Y       Y       Y
+    insrawch                    -       -       -
+    winsrawch                   -       -       -
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+int winsch(WINDOW *win, chtype ch)
+{
+    int x, y;
+    chtype attr;
+    bool xlat;
+
+    PDC_LOG(("winsch() - called: win=%p ch=%x (text=%c attr=0x%x)\n",
+             win, ch, ch & A_CHARTEXT, ch & A_ATTRIBUTES));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    x = win->_curx;
+    y = win->_cury;
+
+    if (y > win->_maxy || x > win->_maxx || y < 0 || x < 0)
+        return ERR;
+
+    xlat = !SP->raw_out && !(ch & A_ALTCHARSET);
+    attr = ch & A_ATTRIBUTES;
+    ch &= A_CHARTEXT;
+
+    if (xlat && (ch < ' ' || ch == 0x7f))
+    {
+        int x2;
+
+        switch ((int)ch)
+        {
+        case '\t':
+            for (x2 = ((x / TABSIZE) + 1) * TABSIZE; x < x2; x++)
+            {
+                if (winsch(win, attr | ' ') == ERR)
+                    return ERR;
+            }
+            return OK;
+
+        case '\n':
+            wclrtoeol(win);
+            break;
+
+        case 0x7f:
+            if (winsch(win, attr | '?') == ERR)
+                return ERR;
+
+            return winsch(win, attr | '^');
+
+        default:
+            /* handle control chars */
+
+            if (winsch(win, attr | (ch + '@')) == ERR)
+                return ERR;
+
+            return winsch(win, attr | '^');
+        }
+    }
+    else
+    {
+        int maxx;
+        chtype *temp;
+
+        /* If the incoming character doesn't have its own attribute,
+           then use the current attributes for the window. If it has
+           attributes but not a color component, OR the attributes to
+           the current attributes for the window. If it has a color
+           component, use the attributes solely from the incoming
+           character. */
+
+        if (!(attr & A_COLOR))
+            attr |= win->_attrs;
+
+        /* wrs (4/10/93): Apply the same sort of logic for the window
+           background, in that it only takes precedence if other color
+           attributes are not there and that the background character
+           will only print if the printing character is blank. */
+
+        if (!(attr & A_COLOR))
+            attr |= win->_bkgd & A_ATTRIBUTES;
+        else
+            attr |= win->_bkgd & (A_ATTRIBUTES ^ A_COLOR);
+
+        if (ch == ' ')
+            ch = win->_bkgd & A_CHARTEXT;
+
+        /* Add the attribute back into the character. */
+
+        ch |= attr;
+
+        maxx = win->_maxx;
+        temp = &win->_y[y][x];
+
+        memmove(temp + 1, temp, (maxx - x - 1) * sizeof(chtype));
+
+        win->_lastch[y] = maxx - 1;
+
+        if ((win->_firstch[y] == _NO_CHANGE) || (win->_firstch[y] > x))
+            win->_firstch[y] = x;
+
+        *temp = ch;
+    }
+
+    PDC_sync(win);
+
+    return OK;
+}
+
+int insch(chtype ch)
+{
+    PDC_LOG(("insch() - called\n"));
+
+    return winsch(stdscr, ch);
+}
+
+int mvinsch(int y, int x, chtype ch)
+{
+    PDC_LOG(("mvinsch() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return winsch(stdscr, ch);
+}
+
+int mvwinsch(WINDOW *win, int y, int x, chtype ch)
+{
+    PDC_LOG(("mvwinsch() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return winsch(win, ch);
+}
+
+int winsrawch(WINDOW *win, chtype ch)
+{
+    PDC_LOG(("winsrawch() - called: win=%p ch=%x "
+             "(char=%c attr=0x%x)\n", win, ch,
+             ch & A_CHARTEXT, ch & A_ATTRIBUTES));
+
+    if ((ch & A_CHARTEXT) < ' ' || (ch & A_CHARTEXT) == 0x7f)
+        ch |= A_ALTCHARSET;
+
+    return winsch(win, ch);
+}
+
+int insrawch(chtype ch)
+{
+    PDC_LOG(("insrawch() - called\n"));
+
+    return winsrawch(stdscr, ch);
+}
+
+int mvinsrawch(int y, int x, chtype ch)
+{
+    PDC_LOG(("mvinsrawch() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return winsrawch(stdscr, ch);
+}
+
+int mvwinsrawch(WINDOW *win, int y, int x, chtype ch)
+{
+    PDC_LOG(("mvwinsrawch() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return winsrawch(win, ch);
+}
+
+#ifdef PDC_WIDE
+int wins_wch(WINDOW *win, const cchar_t *wch)
+{
+    PDC_LOG(("wins_wch() - called\n"));
+
+    assert( win);
+    assert( wch);
+    return wch ? winsch(win, *wch) : ERR;
+}
+
+int ins_wch(const cchar_t *wch)
+{
+    PDC_LOG(("ins_wch() - called\n"));
+
+    return wins_wch(stdscr, wch);
+}
+
+int mvins_wch(int y, int x, const cchar_t *wch)
+{
+    PDC_LOG(("mvins_wch() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wins_wch(stdscr, wch);
+}
+
+int mvwins_wch(WINDOW *win, int y, int x, const cchar_t *wch)
+{
+    PDC_LOG(("mvwins_wch() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wins_wch(win, wch);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/insstr.c b/lib/PDCursesMod/pdcurses/insstr.c
new file mode 100644
index 00000000000..e35d850b532
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/insstr.c
@@ -0,0 +1,268 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+insstr
+------
+
+### Synopsis
+
+    int insstr(const char *str);
+    int insnstr(const char *str, int n);
+    int winsstr(WINDOW *win, const char *str);
+    int winsnstr(WINDOW *win, const char *str, int n);
+    int mvinsstr(int y, int x, const char *str);
+    int mvinsnstr(int y, int x, const char *str, int n);
+    int mvwinsstr(WINDOW *win, int y, int x, const char *str);
+    int mvwinsnstr(WINDOW *win, int y, int x, const char *str, int n);
+
+    int ins_wstr(const wchar_t *wstr);
+    int ins_nwstr(const wchar_t *wstr, int n);
+    int wins_wstr(WINDOW *win, const wchar_t *wstr);
+    int wins_nwstr(WINDOW *win, const wchar_t *wstr, int n);
+    int mvins_wstr(int y, int x, const wchar_t *wstr);
+    int mvins_nwstr(int y, int x, const wchar_t *wstr, int n);
+    int mvwins_wstr(WINDOW *win, int y, int x, const wchar_t *wstr);
+    int mvwins_nwstr(WINDOW *win, int y, int x, const wchar_t *wstr, int n);
+
+### Description
+
+   The insstr() functions insert a character string into a window at the
+   current cursor position, by repeatedly calling winsch(). When
+   PDCurses is built with wide-character support enabled, the narrow-
+   character functions treat the string as a multibyte string in the
+   current locale, and convert it first. All characters to the right of
+   the cursor are moved to the right, with the possibility of the
+   rightmost characters on the line being lost. The cursor position
+   does not change (after moving to y, x, if specified). The routines
+   with n as the last argument insert at most n characters; if n is
+   negative, then the entire string is inserted.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    insstr                      Y       Y       Y
+    winsstr                     Y       Y       Y
+    mvinsstr                    Y       Y       Y
+    mvwinsstr                   Y       Y       Y
+    insnstr                     Y       Y       Y
+    winsnstr                    Y       Y       Y
+    mvinsnstr                   Y       Y       Y
+    mvwinsnstr                  Y       Y       Y
+    ins_wstr                    Y       Y       Y
+    wins_wstr                   Y       Y       Y
+    mvins_wstr                  Y       Y       Y
+    mvwins_wstr                 Y       Y       Y
+    ins_nwstr                   Y       Y       Y
+    wins_nwstr                  Y       Y       Y
+    mvins_nwstr                 Y       Y       Y
+    mvwins_nwstr                Y       Y       Y
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+int winsnstr(WINDOW *win, const char *str, int n)
+{
+#ifdef PDC_WIDE
+    wchar_t wstr[513], *p;
+    int i;
+#endif
+    int len;
+
+    PDC_LOG(("winsnstr() - called: string=\"%s\" n %d \n", str, n));
+
+    assert( win);
+    assert( str);
+    if (!win || !str)
+        return ERR;
+
+    len = (int)strlen(str);
+
+    if (n < 0 || n > len)
+        n = len;
+
+#ifdef PDC_WIDE
+    if (n > 512)
+        n = 512;
+
+    p = wstr;
+    i = 0;
+
+    while( i < n && str[i])
+    {
+        int retval = PDC_mbtowc(p, str + i, n - i);
+
+        if (retval <= 0)
+            break;
+        p++;
+        i += retval;
+    }
+
+    while (p > wstr)
+        if (winsch(win, *--p) == ERR)
+#else
+    while (n)
+        if (winsch(win, (unsigned char)(str[--n])) == ERR)
+#endif
+            return ERR;
+
+    return OK;
+}
+
+int insstr(const char *str)
+{
+    PDC_LOG(("insstr() - called: string=\"%s\"\n", str));
+
+    return winsnstr(stdscr, str, -1);
+}
+
+int winsstr(WINDOW *win, const char *str)
+{
+    PDC_LOG(("winsstr() - called: string=\"%s\"\n", str));
+
+    return winsnstr(win, str, -1);
+}
+
+int mvinsstr(int y, int x, const char *str)
+{
+    PDC_LOG(("mvinsstr() - called: y %d x %d string=\"%s\"\n", y, x, str));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return winsnstr(stdscr, str, -1);
+}
+
+int mvwinsstr(WINDOW *win, int y, int x, const char *str)
+{
+    PDC_LOG(("mvwinsstr() - called: string=\"%s\"\n", str));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return winsnstr(win, str, -1);
+}
+
+int insnstr(const char *str, int n)
+{
+    PDC_LOG(("insnstr() - called: string=\"%s\" n %d \n", str, n));
+
+    return winsnstr(stdscr, str, n);
+}
+
+int mvinsnstr(int y, int x, const char *str, int n)
+{
+    PDC_LOG(("mvinsnstr() - called: y %d x %d string=\"%s\" n %d \n",
+             y, x, str, n));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return winsnstr(stdscr, str, n);
+}
+
+int mvwinsnstr(WINDOW *win, int y, int x, const char *str, int n)
+{
+    PDC_LOG(("mvwinsnstr() - called: y %d x %d string=\"%s\" n %d \n",
+             y, x, str, n));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return winsnstr(win, str, n);
+}
+
+#ifdef PDC_WIDE
+int wins_nwstr(WINDOW *win, const wchar_t *wstr, int n)
+{
+    const wchar_t *p;
+    int len;
+
+    PDC_LOG(("wins_nwstr() - called\n"));
+
+    assert( win);
+    assert( wstr);
+    if (!win || !wstr)
+        return ERR;
+
+    for (len = 0, p = wstr; *p; p++)
+        len++;
+
+    if (n < 0 || n > len)
+        n = len;
+
+    while (n)
+        if (winsch(win, wstr[--n]) == ERR)
+            return ERR;
+
+    return OK;
+}
+
+int ins_wstr(const wchar_t *wstr)
+{
+    PDC_LOG(("ins_wstr() - called\n"));
+
+    return wins_nwstr(stdscr, wstr, -1);
+}
+
+int wins_wstr(WINDOW *win, const wchar_t *wstr)
+{
+    PDC_LOG(("wins_wstr() - called\n"));
+
+    return wins_nwstr(win, wstr, -1);
+}
+
+int mvins_wstr(int y, int x, const wchar_t *wstr)
+{
+    PDC_LOG(("mvins_wstr() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wins_nwstr(stdscr, wstr, -1);
+}
+
+int mvwins_wstr(WINDOW *win, int y, int x, const wchar_t *wstr)
+{
+    PDC_LOG(("mvwinsstr() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wins_nwstr(win, wstr, -1);
+}
+
+int ins_nwstr(const wchar_t *wstr, int n)
+{
+    PDC_LOG(("ins_nwstr() - called\n"));
+
+    return wins_nwstr(stdscr, wstr, n);
+}
+
+int mvins_nwstr(int y, int x, const wchar_t *wstr, int n)
+{
+    PDC_LOG(("mvinsnstr() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return wins_nwstr(stdscr, wstr, n);
+}
+
+int mvwins_nwstr(WINDOW *win, int y, int x, const wchar_t *wstr, int n)
+{
+    PDC_LOG(("mvwinsnstr() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return wins_nwstr(win, wstr, n);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/instr.c b/lib/PDCursesMod/pdcurses/instr.c
new file mode 100644
index 00000000000..42194a9ac9e
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/instr.c
@@ -0,0 +1,252 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+instr
+-----
+
+### Synopsis
+
+    int instr(char *str);
+    int innstr(char *str, int n);
+    int winstr(WINDOW *win, char *str);
+    int winnstr(WINDOW *win, char *str, int n);
+    int mvinstr(int y, int x, char *str);
+    int mvinnstr(int y, int x, char *str, int n);
+    int mvwinstr(WINDOW *win, int y, int x, char *str);
+    int mvwinnstr(WINDOW *win, int y, int x, char *str, int n);
+
+    int inwstr(wchar_t *wstr);
+    int innwstr(wchar_t *wstr, int n);
+    int winwstr(WINDOW *win, wchar_t *wstr);
+    int winnwstr(WINDOW *win, wchar_t *wstr, int n);
+    int mvinwstr(int y, int x, wchar_t *wstr);
+    int mvinnwstr(int y, int x, wchar_t *wstr, int n);
+    int mvwinwstr(WINDOW *win, int y, int x, wchar_t *wstr);
+    int mvwinnwstr(WINDOW *win, int y, int x, wchar_t *wstr, int n);
+
+### Description
+
+   These functions take characters (or wide characters) from the current
+   or specified position in the window, and return them as a string in
+   str (or wstr). Attributes are ignored. The functions with n as the
+   last argument return a string at most n characters long.
+
+### Return Value
+
+   Upon successful completion, innstr(), mvinnstr(), mvwinnstr() and
+   winnstr() return the number of characters actually read into the
+   string; instr(), mvinstr(), mvwinstr() and winstr() return OK.
+   Otherwise, all these functions return ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    instr                       Y       Y       Y
+    winstr                      Y       Y       Y
+    mvinstr                     Y       Y       Y
+    mvwinstr                    Y       Y       Y
+    innstr                      Y       Y       Y
+    winnstr                     Y       Y       Y
+    mvinnstr                    Y       Y       Y
+    mvwinnstr                   Y       Y       Y
+    inwstr                      Y       Y       Y
+    winwstr                     Y       Y       Y
+    mvinwstr                    Y       Y       Y
+    mvwinwstr                   Y       Y       Y
+    innwstr                     Y       Y       Y
+    winnwstr                    Y       Y       Y
+    mvinnwstr                   Y       Y       Y
+    mvwinnwstr                  Y       Y       Y
+
+**man-end****************************************************************/
+
+int winnstr(WINDOW *win, char *str, int n)
+{
+#ifdef PDC_WIDE
+    wchar_t wstr[513];
+
+    assert( win);
+    assert( str);
+    if (n < 0 || n > 512)
+        n = 512;
+
+    if (winnwstr(win, wstr, n) == ERR)
+        return ERR;
+
+    return (int)PDC_wcstombs(str, wstr, n);
+#else
+    chtype *src;
+    int i;
+
+    assert( win);
+    assert( str);
+    PDC_LOG(("winnstr() - called: n %d \n", n));
+
+    if (!win || !str)
+        return ERR;
+
+    if (n < 0 || (win->_curx + n) > win->_maxx)
+        n = win->_maxx - win->_curx;
+
+    src = win->_y[win->_cury] + win->_curx;
+
+    for (i = 0; i < n; i++)
+        str[i] = (char)( src[i] & A_CHARTEXT);
+
+    str[i] = '\0';
+
+    return i;
+#endif
+}
+
+int instr(char *str)
+{
+    PDC_LOG(("instr() - called: string=\"%s\"\n", str));
+
+    return (ERR == winnstr(stdscr, str, stdscr->_maxx)) ? ERR : OK;
+}
+
+int winstr(WINDOW *win, char *str)
+{
+    PDC_LOG(("winstr() - called: \n"));
+
+    return (ERR == winnstr(win, str, win->_maxx)) ? ERR : OK;
+}
+
+int mvinstr(int y, int x, char *str)
+{
+    PDC_LOG(("mvinstr() - called: y %d x %d \n", y, x));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return (ERR == winnstr(stdscr, str, stdscr->_maxx)) ? ERR : OK;
+}
+
+int mvwinstr(WINDOW *win, int y, int x, char *str)
+{
+    PDC_LOG(("mvwinstr() - called: y %d x %d \n", y, x));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return (ERR == winnstr(win, str, win->_maxx)) ? ERR : OK;
+}
+
+int innstr(char *str, int n)
+{
+    PDC_LOG(("innstr() - called: n %d \n", n));
+
+    return winnstr(stdscr, str, n);
+}
+
+int mvinnstr(int y, int x, char *str, int n)
+{
+    PDC_LOG(("mvinnstr() - called: y %d x %d n %d \n", y, x, n));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return winnstr(stdscr, str, n);
+}
+
+int mvwinnstr(WINDOW *win, int y, int x, char *str, int n)
+{
+    PDC_LOG(("mvwinnstr() - called: y %d x %d n %d \n", y, x, n));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return winnstr(win, str, n);
+}
+
+#ifdef PDC_WIDE
+int winnwstr(WINDOW *win, wchar_t *wstr, int n)
+{
+    chtype *src;
+    int i;
+
+    PDC_LOG(("winnstr() - called: n %d \n", n));
+
+    assert( win);
+    assert( wstr);
+    if (!win || !wstr)
+        return ERR;
+
+    if (n < 0 || (win->_curx + n) > win->_maxx)
+        n = win->_maxx - win->_curx;
+
+    src = win->_y[win->_cury] + win->_curx;
+
+    for (i = 0; i < n; i++)
+        wstr[i] = (wchar_t)src[i] & A_CHARTEXT;
+
+    wstr[i] = L'\0';
+
+    return i;
+}
+
+int inwstr(wchar_t *wstr)
+{
+    PDC_LOG(("inwstr() - called\n"));
+
+    return (ERR == winnwstr(stdscr, wstr, stdscr->_maxx)) ? ERR : OK;
+}
+
+int winwstr(WINDOW *win, wchar_t *wstr)
+{
+    PDC_LOG(("winwstr() - called\n"));
+
+    return (ERR == winnwstr(win, wstr, win->_maxx)) ? ERR : OK;
+}
+
+int mvinwstr(int y, int x, wchar_t *wstr)
+{
+    PDC_LOG(("mvinwstr() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return (ERR == winnwstr(stdscr, wstr, stdscr->_maxx)) ? ERR : OK;
+}
+
+int mvwinwstr(WINDOW *win, int y, int x, wchar_t *wstr)
+{
+    PDC_LOG(("mvwinstr() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return (ERR == winnwstr(win, wstr, win->_maxx)) ? ERR : OK;
+}
+
+int innwstr(wchar_t *wstr, int n)
+{
+    PDC_LOG(("innwstr() - called\n"));
+
+    return winnwstr(stdscr, wstr, n);
+}
+
+int mvinnwstr(int y, int x, wchar_t *wstr, int n)
+{
+    PDC_LOG(("mvinnstr() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    return winnwstr(stdscr, wstr, n);
+}
+
+int mvwinnwstr(WINDOW *win, int y, int x, wchar_t *wstr, int n)
+{
+    PDC_LOG(("mvwinnwstr() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    return winnwstr(win, wstr, n);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/kernel.c b/lib/PDCursesMod/pdcurses/kernel.c
new file mode 100644
index 00000000000..67efff4cb56
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/kernel.c
@@ -0,0 +1,312 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+kernel
+------
+
+### Synopsis
+
+    int def_prog_mode(void);
+    int def_shell_mode(void);
+    int reset_prog_mode(void);
+    int reset_shell_mode(void);
+    int resetty(void);
+    int savetty(void);
+    int ripoffline(int line, int (*init)(WINDOW *, int));
+    int curs_set(int visibility);
+    int napms(int ms);
+
+    int draino(int ms);
+    int resetterm(void);
+    int fixterm(void);
+    int saveterm(void);
+
+### Description
+
+   def_prog_mode() and def_shell_mode() save the current terminal modes
+   as the "program" (in curses) or "shell" (not in curses) state for use
+   by the reset_prog_mode() and reset_shell_mode() functions. This is
+   done automatically by initscr().
+
+   reset_prog_mode() and reset_shell_mode() restore the terminal to
+   "program" (in curses) or "shell" (not in curses) state. These are
+   done automatically by endwin() and doupdate() after an endwin(), so
+   they would normally not be called before these functions.
+
+   savetty() and resetty() save and restore the state of the terminal
+   modes. savetty() saves the current state in a buffer, and resetty()
+   restores the state to what it was at the last call to savetty().
+
+   curs_set() alters the appearance of the cursor. A visibility of 0
+   makes it disappear; 1 makes it appear "normal" (usually an underline)
+   and 2 makes it "highly visible" (usually a block).
+
+   ripoffline() reduces the size of stdscr by one line. If the "line"
+   parameter is positive, the line is removed from the top of the
+   screen; if negative, from the bottom. Up to 5 lines can be ripped off
+   stdscr by calling ripoffline() repeatedly. The function argument,
+   init, is called from within initscr() or newterm(), so ripoffline()
+   must be called before either of these functions. The init function
+   receives a pointer to a one-line WINDOW, and the width of the window.
+   Calling ripoffline() with a NULL init function pointer is an error.
+
+   napms() suspends the program for the specified number of
+   milliseconds. draino() is an archaic equivalent. Note that since
+   napms() attempts to give up a time slice and yield control back to
+   the OS, all times are approximate. (In DOS, the delay is actually
+   rounded down to 50ms (1/20th sec) intervals, with a minimum of one
+   interval; i.e., 1-99 will wait 50ms, 100-149 will wait 100ms, etc.)
+   0 returns immediately.
+
+   resetterm(), fixterm() and saveterm() are archaic equivalents for
+   reset_shell_mode(), reset_prog_mode() and def_prog_mode(),
+   respectively.
+
+### Return Value
+
+   All functions return OK on success and ERR on error, except
+   curs_set(), which returns the previous visibility.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    def_prog_mode               Y       Y       Y
+    def_shell_mode              Y       Y       Y
+    reset_prog_mode             Y       Y       Y
+    reset_shell_mode            Y       Y       Y
+    resetty                     Y       Y       Y
+    savetty                     Y       Y       Y
+    ripoffline                  Y       Y       Y
+    curs_set                    Y       Y       Y
+    napms                       Y       Y       Y
+    fixterm                     -       Y       -
+    resetterm                   -       Y       -
+    saveterm                    -       Y       -
+    draino                      -       -       -
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+RIPPEDOFFLINE linesripped[5];
+char linesrippedoff = 0;
+
+static struct cttyset
+{
+    bool been_set;
+    SCREEN saved;
+} ctty[3];
+
+enum { PDC_SH_TTY, PDC_PR_TTY, PDC_SAVE_TTY };
+
+static void _save_mode(int i)
+{
+    ctty[i].been_set = TRUE;
+
+    memcpy(&(ctty[i].saved), SP, sizeof(SCREEN));
+
+    PDC_save_screen_mode(i);
+}
+
+static int _restore_mode(int i)
+{
+    if (ctty[i].been_set == TRUE)
+    {
+        PDC_PAIR *atrtab = SP->atrtab;
+
+        memcpy(SP, &(ctty[i].saved), sizeof(SCREEN));
+        SP->atrtab = atrtab;
+
+        if (ctty[i].saved.raw_out)
+            raw();
+
+        PDC_restore_screen_mode(i);
+
+        if ((LINES != ctty[i].saved.lines) ||
+            (COLS != ctty[i].saved.cols))
+            resize_term(ctty[i].saved.lines, ctty[i].saved.cols);
+
+        PDC_curs_set(ctty[i].saved.visibility);
+
+        PDC_gotoyx(ctty[i].saved.cursrow, ctty[i].saved.curscol);
+    }
+
+    return ctty[i].been_set ? OK : ERR;
+}
+
+int def_prog_mode(void)
+{
+    PDC_LOG(("def_prog_mode() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    _save_mode(PDC_PR_TTY);
+
+    return OK;
+}
+
+int def_shell_mode(void)
+{
+    PDC_LOG(("def_shell_mode() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    _save_mode(PDC_SH_TTY);
+
+    return OK;
+}
+
+int reset_prog_mode(void)
+{
+    PDC_LOG(("reset_prog_mode() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    _restore_mode(PDC_PR_TTY);
+    PDC_reset_prog_mode();
+
+    return OK;
+}
+
+int reset_shell_mode(void)
+{
+    PDC_LOG(("reset_shell_mode() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    _restore_mode(PDC_SH_TTY);
+    PDC_reset_shell_mode();
+
+    return OK;
+}
+
+int resetty(void)
+{
+    PDC_LOG(("resetty() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    return _restore_mode(PDC_SAVE_TTY);
+}
+
+int savetty(void)
+{
+    PDC_LOG(("savetty() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    _save_mode(PDC_SAVE_TTY);
+
+    return OK;
+}
+
+int curs_set(int visibility)
+{
+    int ret_vis;
+
+    PDC_LOG(("curs_set() - called: visibility=%d\n", visibility));
+
+    if ((visibility < 0) || (visibility > 0x10000))
+        return ERR;
+
+    ret_vis = PDC_curs_set(visibility);
+
+    /* If the cursor is changing from invisible to visible, update
+       its position */
+
+    if (visibility && !ret_vis)
+        PDC_gotoyx(SP->cursrow, SP->curscol);
+
+    return ret_vis;
+}
+
+/* TODO : must initscr() be called for napms to work?  Certainly not
+on some platforms,  but is it true for all?  */
+
+int napms(int ms)
+{
+    PDC_LOG(("napms() - called: ms=%d\n", ms));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    if (SP->dirty)
+    {
+        int curs_state = SP->visibility;
+        bool leave_state = is_leaveok(curscr);
+
+        SP->dirty = FALSE;
+
+        leaveok(curscr, TRUE);
+
+        wrefresh(curscr);
+
+        leaveok(curscr, leave_state);
+        curs_set(curs_state);
+    }
+
+    if (ms)
+        PDC_napms(ms);
+
+    return OK;
+}
+
+int ripoffline(int line, int (*init)(WINDOW *, int))
+{
+    PDC_LOG(("ripoffline() - called: line=%d\n", line));
+
+    assert( init);
+    if (linesrippedoff < 5 && line && init)
+    {
+        linesripped[(int)linesrippedoff].line = line;
+        linesripped[(int)linesrippedoff++].init = init;
+
+        return OK;
+    }
+
+    return ERR;
+}
+
+int draino(int ms)
+{
+    PDC_LOG(("draino() - called\n"));
+
+    return napms(ms);
+}
+
+int resetterm(void)
+{
+    PDC_LOG(("resetterm() - called\n"));
+
+    return reset_shell_mode();
+}
+
+int fixterm(void)
+{
+    PDC_LOG(("fixterm() - called\n"));
+
+    return reset_prog_mode();
+}
+
+int saveterm(void)
+{
+    PDC_LOG(("saveterm() - called\n"));
+
+    return def_prog_mode();
+}
diff --git a/lib/PDCursesMod/pdcurses/keyname.c b/lib/PDCursesMod/pdcurses/keyname.c
new file mode 100644
index 00000000000..f81c83384f1
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/keyname.c
@@ -0,0 +1,139 @@
+/* PDCurses */
+
+#include <curspriv.h>
+
+/*man-start**************************************************************
+
+keyname
+-------
+
+### Synopsis
+
+    char *keyname(int key);
+
+    char *key_name(wchar_t c);
+
+    bool has_key(int key);
+
+### Description
+
+   keyname() returns a string corresponding to the argument key. key may
+   be any key returned by wgetch().
+
+   key_name() is the wide-character version. It takes a wchar_t
+   parameter, but still returns a char *.
+
+   has_key() returns TRUE for recognized keys, FALSE otherwise. This
+   function is an ncurses extension.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    keyname                     Y       Y       Y
+    key_name                    Y       Y       Y
+    has_key                     -       Y       Y
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+char *keyname(int key)
+{
+    static char _keyname[14];
+
+    /* Key names must be in exactly the same order as in curses.h */
+
+    static char *key_names[] =
+    {
+    "KEY_BREAK", "KEY_DOWN", "KEY_UP", "KEY_LEFT", "KEY_RIGHT",
+    "KEY_HOME", "KEY_BACKSPACE", "KEY_F0", "KEY_F(1)", "KEY_F(2)",
+    "KEY_F(3)", "KEY_F(4)", "KEY_F(5)", "KEY_F(6)", "KEY_F(7)",
+    "KEY_F(8)", "KEY_F(9)", "KEY_F(10)", "KEY_F(11)", "KEY_F(12)",
+    "KEY_F(13)", "KEY_F(14)", "KEY_F(15)", "KEY_F(16)", "KEY_F(17)",
+    "KEY_F(18)", "KEY_F(19)", "KEY_F(20)", "KEY_F(21)", "KEY_F(22)",
+    "KEY_F(23)", "KEY_F(24)", "KEY_F(25)", "KEY_F(26)", "KEY_F(27)",
+    "KEY_F(28)", "KEY_F(29)", "KEY_F(30)", "KEY_F(31)", "KEY_F(32)",
+    "KEY_F(33)", "KEY_F(34)", "KEY_F(35)", "KEY_F(36)", "KEY_F(37)",
+    "KEY_F(38)", "KEY_F(39)", "KEY_F(40)", "KEY_F(41)", "KEY_F(42)",
+    "KEY_F(43)", "KEY_F(44)", "KEY_F(45)", "KEY_F(46)", "KEY_F(47)",
+    "KEY_F(48)", "KEY_F(49)", "KEY_F(50)", "KEY_F(51)", "KEY_F(52)",
+    "KEY_F(53)", "KEY_F(54)", "KEY_F(55)", "KEY_F(56)", "KEY_F(57)",
+    "KEY_F(58)", "KEY_F(59)", "KEY_F(60)", "KEY_F(61)", "KEY_F(62)",
+    "KEY_F(63)", "KEY_DL", "KEY_IL", "KEY_DC", "KEY_IC", "KEY_EIC",
+    "KEY_CLEAR", "KEY_EOS", "KEY_EOL", "KEY_SF", "KEY_SR", "KEY_NPAGE",
+    "KEY_PPAGE", "KEY_STAB", "KEY_CTAB", "KEY_CATAB", "KEY_ENTER",
+    "KEY_SRESET", "KEY_RESET", "KEY_PRINT", "KEY_LL", "KEY_ABORT",
+    "KEY_SHELP", "KEY_LHELP", "KEY_BTAB", "KEY_BEG", "KEY_CANCEL",
+    "KEY_CLOSE", "KEY_COMMAND", "KEY_COPY", "KEY_CREATE", "KEY_END",
+    "KEY_EXIT", "KEY_FIND", "KEY_HELP", "KEY_MARK", "KEY_MESSAGE",
+    "KEY_MOVE", "KEY_NEXT", "KEY_OPEN", "KEY_OPTIONS", "KEY_PREVIOUS",
+    "KEY_REDO", "KEY_REFERENCE", "KEY_REFRESH", "KEY_REPLACE",
+    "KEY_RESTART", "KEY_RESUME", "KEY_SAVE", "KEY_SBEG", "KEY_SCANCEL",
+    "KEY_SCOMMAND", "KEY_SCOPY", "KEY_SCREATE", "KEY_SDC", "KEY_SDL",
+    "KEY_SELECT", "KEY_SEND", "KEY_SEOL", "KEY_SEXIT", "KEY_SFIND",
+    "KEY_SHOME", "KEY_SIC", "UNKNOWN KEY", "KEY_SLEFT", "KEY_SMESSAGE",
+    "KEY_SMOVE", "KEY_SNEXT", "KEY_SOPTIONS", "KEY_SPREVIOUS",
+    "KEY_SPRINT", "KEY_SREDO", "KEY_SREPLACE", "KEY_SRIGHT",
+    "KEY_SRSUME", "KEY_SSAVE", "KEY_SSUSPEND", "KEY_SUNDO",
+    "KEY_SUSPEND", "KEY_UNDO", "ALT_0", "ALT_1", "ALT_2", "ALT_3",
+    "ALT_4", "ALT_5", "ALT_6", "ALT_7", "ALT_8", "ALT_9", "ALT_A",
+    "ALT_B", "ALT_C", "ALT_D", "ALT_E", "ALT_F", "ALT_G", "ALT_H",
+    "ALT_I", "ALT_J", "ALT_K", "ALT_L", "ALT_M", "ALT_N", "ALT_O",
+    "ALT_P", "ALT_Q", "ALT_R", "ALT_S", "ALT_T", "ALT_U", "ALT_V",
+    "ALT_W", "ALT_X", "ALT_Y", "ALT_Z", "CTL_LEFT", "CTL_RIGHT",
+    "CTL_PGUP", "CTL_PGDN", "CTL_HOME", "CTL_END", "KEY_A1", "KEY_A2",
+    "KEY_A3", "KEY_B1", "KEY_B2", "KEY_B3", "KEY_C1", "KEY_C2",
+    "KEY_C3", "PADSLASH", "PADENTER", "CTL_PADENTER", "ALT_PADENTER",
+    "PADSTOP", "PADSTAR", "PADMINUS", "PADPLUS", "CTL_PADSTOP",
+    "CTL_PADCENTER", "CTL_PADPLUS", "CTL_PADMINUS", "CTL_PADSLASH",
+    "CTL_PADSTAR", "ALT_PADPLUS", "ALT_PADMINUS", "ALT_PADSLASH",
+    "ALT_PADSTAR", "ALT_PADSTOP", "CTL_INS", "ALT_DEL", "ALT_INS",
+    "CTL_UP", "CTL_DOWN", "CTL_TAB", "ALT_TAB", "ALT_MINUS",
+    "ALT_EQUAL", "ALT_HOME", "ALT_PGUP", "ALT_PGDN", "ALT_END",
+    "ALT_UP", "ALT_DOWN", "ALT_RIGHT", "ALT_LEFT", "ALT_ENTER",
+    "ALT_ESC", "ALT_BQUOTE", "ALT_LBRACKET", "ALT_RBRACKET",
+    "ALT_SEMICOLON", "ALT_FQUOTE", "ALT_COMMA", "ALT_STOP",
+    "ALT_FSLASH", "ALT_BKSP", "CTL_BKSP", "PAD0", "CTL_PAD0",
+    "CTL_PAD1", "CTL_PAD2", "CTL_PAD3", "CTL_PAD4", "CTL_PAD5",
+    "CTL_PAD6", "CTL_PAD7","CTL_PAD8", "CTL_PAD9", "ALT_PAD0",
+    "ALT_PAD1", "ALT_PAD2", "ALT_PAD3", "ALT_PAD4", "ALT_PAD5",
+    "ALT_PAD6", "ALT_PAD7", "ALT_PAD8", "ALT_PAD9", "CTL_DEL",
+    "ALT_BSLASH", "CTL_ENTER", "SHF_PADENTER", "SHF_PADSLASH",
+    "SHF_PADSTAR", "SHF_PADPLUS", "SHF_PADMINUS", "SHF_UP", "SHF_DOWN",
+    "SHF_IC", "SHF_DC", "KEY_MOUSE", "KEY_SHIFT_L", "KEY_SHIFT_R",
+    "KEY_CONTROL_L", "KEY_CONTROL_R", "KEY_ALT_L", "KEY_ALT_R",
+    "KEY_RESIZE", "KEY_SUP", "KEY_SDOWN",
+                  /* PDCursesMod additions: */
+              "KEY_APPS", "KEY_PAUSE",
+              "KEY_PRINTSCREEN", "KEY_SCROLLLOCK",
+              "BROWSER_BACK", "BROWSER_FWD", "BROWSER_REF", "BROWSER_STOP",
+              "SEARCH", "FAVORITES", "BROWSER_HOME",
+              "VOLUME_MUTE", "VOLUME_DOWN", "VOLUME_UP",
+              "NEXT_TRACK", "PREV_TRACK", "MEDIA_STOP", "PLAY_PAUSE",
+              "LAUNCH_MAIL", "MEDIA_SELECT",
+              "LAUNCH_APP1", "LAUNCH_APP2", "LAUNCH_APP3", "LAUNCH_APP4",
+              "LAUNCH_APP5", "LAUNCH_APP6", "LAUNCH_APP7", "LAUNCH_APP8",
+              "LAUNCH_APP9", "LAUNCH_APP10" };
+
+    PDC_LOG(("keyname() - called: key %d\n", key));
+
+    strcpy(_keyname, ((key >= 0) && (key < 0x80)) ? unctrl((chtype)key) :
+           has_key(key) ? key_names[key - KEY_MIN] : "UNKNOWN KEY");
+
+    return _keyname;
+}
+
+bool has_key(int key)
+{
+    PDC_LOG(("has_key() - called: key %d\n", key));
+
+    return (key >= KEY_MIN && key <= KEY_MAX);
+}
+
+#ifdef PDC_WIDE
+char *key_name(wchar_t c)
+{
+    PDC_LOG(("key_name() - called\n"));
+
+    return keyname((int)c);
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/mouse.c b/lib/PDCursesMod/pdcurses/mouse.c
new file mode 100644
index 00000000000..c09d843857c
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/mouse.c
@@ -0,0 +1,449 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+mouse
+-----
+
+### Synopsis
+
+    int mouse_set(mmask_t mbe);
+    int mouse_on(mmask_t mbe);
+    int mouse_off(mmask_t mbe);
+    int request_mouse_pos(void);
+    void wmouse_position(WINDOW *win, int *y, int *x);
+    mmask_t getmouse(void);
+
+    int mouseinterval(int wait);
+    bool wenclose(const WINDOW *win, int y, int x);
+    bool wmouse_trafo(const WINDOW *win, int *y, int *x, bool to_screen);
+    bool mouse_trafo(int *y, int *x, bool to_screen);
+    mmask_t mousemask(mmask_t mask, mmask_t *oldmask);
+    int nc_getmouse(MEVENT *event);
+    int ungetmouse(MEVENT *event);
+    bool has_mouse(void);
+
+### Description
+
+   As of PDCurses 3.0, there are two separate mouse interfaces: the
+   classic interface, which is based on the undocumented Sys V mouse
+   functions; and an ncurses-compatible interface. Both are active at
+   all times, and you can mix and match functions from each, though it's
+   not recommended. The ncurses interface is essentially an emulation
+   layer built on top of the classic interface; it's here to allow
+   easier porting of ncurses apps.
+
+   The classic interface: mouse_set(), mouse_on(), mouse_off(),
+   request_mouse_pos(), wmouse_position(), and getmouse(). An
+   application using this interface would start by calling mouse_set()
+   or mouse_on() with a non-zero value, often ALL_MOUSE_EVENTS. Then it
+   would check for a KEY_MOUSE return from getch(). If found, it would
+   call request_mouse_pos() to get the current mouse status.
+
+   mouse_set(), mouse_on() and mouse_off() are analagous to attrset(),
+   attron() and attroff(). These functions set the mouse button events
+   to trap. The button masks used in these functions are defined in
+   curses.h and can be or'ed together. They are the group of masks
+   starting with BUTTON1_RELEASED.
+
+   request_mouse_pos() requests curses to fill in the Mouse_status
+   structure with the current state of the mouse.
+
+   wmouse_position() determines if the current mouse position is within
+   the window passed as an argument. If the mouse is outside the current
+   window, -1 is returned in the y and x arguments; otherwise the y and
+   x coordinates of the mouse (relative to the top left corner of the
+   window) are returned in y and x.
+
+   getmouse() returns the current status of the trapped mouse buttons as
+   set by mouse_set() or mouse_on().
+
+   The ncurses interface: mouseinterval(), wenclose(), wmouse_trafo(),
+   mouse_trafo(), mousemask(), nc_getmouse(), ungetmouse() and
+   has_mouse(). A typical application using this interface would start
+   by calling mousemask() with a non-zero value, often ALL_MOUSE_EVENTS.
+   Then it would check for a KEY_MOUSE return from getch(). If found, it
+   would call nc_getmouse() to get the current mouse status.
+
+   mouseinterval() sets the timeout for a mouse click. On all current
+   platforms, PDCurses receives mouse button press and release events,
+   but must synthesize click events. It does this by checking whether a
+   release event is queued up after a press event. If it gets a press
+   event, and there are no more events waiting, it will wait for the
+   timeout interval, then check again for a release. A press followed by
+   a release is reported as BUTTON_CLICKED; otherwise it's passed
+   through as BUTTON_PRESSED. The default timeout is 150ms; valid values
+   are 0 (no clicks reported) through 1000ms. In x11, the timeout can
+   also be set via the clickPeriod resource. The return value from
+   mouseinterval() is the old timeout. To check the old value without
+   setting a new one, call it with a parameter of -1. Note that although
+   there's no classic equivalent for this function (apart from the
+   clickPeriod resource), the value set applies in both interfaces.
+
+   wenclose() reports whether the given screen-relative y, x coordinates
+   fall within the given window.
+
+   wmouse_trafo() converts between screen-relative and window-relative
+   coordinates. A to_screen parameter of TRUE means to convert from
+   window to screen; otherwise the reverse. The function returns FALSE
+   if the coordinates aren't within the window, or if any of the
+   parameters are NULL. The coordinates have been converted when the
+   function returns TRUE.
+
+   mouse_trafo() is the stdscr version of wmouse_trafo().
+
+   mousemask() is nearly equivalent to mouse_set(), but instead of
+   OK/ERR, it returns the value of the mask after setting it. (This
+   isn't necessarily the same value passed in, since the mask could be
+   altered on some platforms.) And if the second parameter is a non-null
+   pointer, mousemask() stores the previous mask value there. Also,
+   since the ncurses interface doesn't work with PDCurses' BUTTON_MOVED
+   events, mousemask() filters them out.
+
+   nc_getmouse() returns the current mouse status in an MEVENT struct.
+   This is equivalent to ncurses' getmouse(), renamed to avoid conflict
+   with PDCurses' getmouse(). But if you define PDC_NCMOUSE before
+   including curses.h, it defines getmouse() to nc_getmouse(), along
+   with a few other redefintions needed for compatibility with ncurses
+   code. nc_getmouse() calls request_mouse_pos(), which (not getmouse())
+   is the classic equivalent.
+
+   ungetmouse() is the mouse equivalent of ungetch(). However, PDCurses
+   doesn't maintain a queue of mouse events; only one can be pushed
+   back, and it can overwrite or be overwritten by real mouse events.
+
+   has_mouse() reports whether the mouse is available at all on the
+   current platform.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    mouse_set                   -       -       -
+    mouse_on                    -       -       -
+    mouse_off                   -       -       -
+    request_mouse_pos           -       -       -
+    wmouse_position             -       -       -
+    getmouse                    -       *       -
+    mouseinterval               -       Y       -
+    wenclose                    -       Y       -
+    wmouse_trafo                -       Y       -
+    mouse_trafo                 -       Y       -
+    mousemask                   -       Y       -
+    nc_getmouse                 -       *       -
+    ungetmouse                  -       Y       -
+    has_mouse                   -       Y       -
+
+    * See above, under Description
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+static bool ungot = FALSE;
+
+int mouse_set(mmask_t mbe)
+{
+    PDC_LOG(("mouse_set() - called: event %x\n", mbe));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->_trap_mbe = mbe;
+    return PDC_mouse_set();
+}
+
+int mouse_on(mmask_t mbe)
+{
+    PDC_LOG(("mouse_on() - called: event %x\n", mbe));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->_trap_mbe |= mbe;
+    return PDC_mouse_set();
+}
+
+int mouse_off(mmask_t mbe)
+{
+    PDC_LOG(("mouse_off() - called: event %x\n", mbe));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->_trap_mbe &= ~mbe;
+    return PDC_mouse_set();
+}
+
+int request_mouse_pos(void)
+{
+    PDC_LOG(("request_mouse_pos() - called\n"));
+
+    Mouse_status = SP->mouse_status;
+
+    return OK;
+}
+
+void wmouse_position(WINDOW *win, int *y, int *x)
+{
+    PDC_LOG(("wmouse_position() - called\n"));
+
+    if (win && wenclose(win, MOUSE_Y_POS, MOUSE_X_POS))
+    {
+        if (y)
+            *y = MOUSE_Y_POS - win->_begy;
+        if (x)
+            *x = MOUSE_X_POS - win->_begx;
+    }
+    else
+    {
+        if (y)
+            *y = -1;
+        if (x)
+            *x = -1;
+    }
+}
+
+mmask_t getmouse(void)
+{
+    PDC_LOG(("getmouse() - called\n"));
+
+    assert( SP);
+    return SP ? SP->_trap_mbe : (mmask_t)0;
+}
+
+/* ncurses mouse interface */
+
+const int max_mouse_interval = 32767;        /* 32.767 seconds */
+
+int mouseinterval(int wait)
+{
+    int old_wait;
+
+    PDC_LOG(("mouseinterval() - called: %d\n", wait));
+
+    if (!SP)
+        return max_mouse_interval;
+
+    old_wait = SP->mouse_wait;
+
+    if (wait >= 0 && wait <= max_mouse_interval)
+        SP->mouse_wait = wait;
+
+    return old_wait;
+}
+
+bool wenclose(const WINDOW *win, int y, int x)
+{
+    PDC_LOG(("wenclose() - called: %p %d %d\n", win, y, x));
+
+    assert( win);
+    return (win && y >= win->_begy && y < win->_begy + win->_maxy
+                && x >= win->_begx && x < win->_begx + win->_maxx);
+}
+
+bool wmouse_trafo(const WINDOW *win, int *y, int *x, bool to_screen)
+{
+    int newy, newx;
+
+    PDC_LOG(("wmouse_trafo() - called\n"));
+
+    assert( win);
+    assert( x);
+    assert( y);
+    if (!win || !y || !x)
+        return FALSE;
+
+    newy = *y;
+    newx = *x;
+
+    if (to_screen)
+    {
+        newy += win->_begy;
+        newx += win->_begx;
+
+        if (!wenclose(win, newy, newx))
+            return FALSE;
+    }
+    else
+    {
+        if (wenclose(win, newy, newx))
+        {
+            newy -= win->_begy;
+            newx -= win->_begx;
+        }
+        else
+            return FALSE;
+    }
+
+    *y = newy;
+    *x = newx;
+
+    return TRUE;
+}
+
+bool mouse_trafo(int *y, int *x, bool to_screen)
+{
+    PDC_LOG(("mouse_trafo() - called\n"));
+
+    return wmouse_trafo(stdscr, y, x, to_screen);
+}
+
+mmask_t mousemask(mmask_t mask, mmask_t *oldmask)
+{
+    PDC_LOG(("mousemask() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return (mmask_t)0;
+
+    if (oldmask)
+        *oldmask = SP->_trap_mbe;
+
+    /* The ncurses interface doesn't work with our move events, so
+       filter them here */
+
+    mask &= ~(BUTTON1_MOVED | BUTTON2_MOVED | BUTTON3_MOVED);
+
+    mouse_set(mask);
+
+    return SP->_trap_mbe;
+}
+
+#define BITS_PER_BUTTON       5
+
+int nc_getmouse(MEVENT *event)
+{
+    int i;
+    mmask_t bstate = 0;
+
+    PDC_LOG(("nc_getmouse() - called\n"));
+
+    assert( SP);
+    assert( event);
+    if (!event || !SP)
+        return ERR;
+
+    ungot = FALSE;
+
+    request_mouse_pos();
+
+    event->id = 0;
+
+    event->x = Mouse_status.x;
+    event->y = Mouse_status.y;
+    event->z = 0;
+
+    for (i = 0; i < 3; i++)
+    {
+        if (Mouse_status.changes & (1 << i))
+        {
+            const int shf = i * BITS_PER_BUTTON;
+            const short button = Mouse_status.button[i] & BUTTON_ACTION_MASK;
+
+            if (button == BUTTON_RELEASED)
+                bstate |= (BUTTON1_RELEASED << shf);
+            else if (button == BUTTON_PRESSED)
+                bstate |= (BUTTON1_PRESSED << shf);
+            else if (button == BUTTON_CLICKED)
+                bstate |= (BUTTON1_CLICKED << shf);
+            else if (button == BUTTON_DOUBLE_CLICKED)
+                bstate |= (BUTTON1_DOUBLE_CLICKED << shf);
+            else if (button == BUTTON_TRIPLE_CLICKED)
+                bstate |= (BUTTON1_TRIPLE_CLICKED << shf);
+        }
+    }
+
+    if (MOUSE_WHEEL_UP)
+        bstate |= BUTTON4_PRESSED;
+    else if (MOUSE_WHEEL_DOWN)
+        bstate |= BUTTON5_PRESSED;
+                     /* 'Moves' (i.e.,  button is pressed) and 'position reports' */
+                     /* (mouse moved with no button down) are all reported as     */
+                     /* 'position reports' in NCurses,  which lacks 'move' events. */
+    if( (MOUSE_MOVED || MOUSE_POS_REPORT) && (SP->_trap_mbe & REPORT_MOUSE_POSITION))
+        bstate |= REPORT_MOUSE_POSITION;
+
+    for( i = 0; i < 3; i++)
+    {
+       if( Mouse_status.button[i] & PDC_BUTTON_SHIFT)
+           bstate |= BUTTON_MODIFIER_SHIFT;
+       if( Mouse_status.button[i] & PDC_BUTTON_CONTROL)
+           bstate |= BUTTON_MODIFIER_CONTROL;
+       if( Mouse_status.button[i] & PDC_BUTTON_ALT)
+           bstate |= BUTTON_MODIFIER_ALT;
+    }
+
+    /* extra filter pass -- mainly for button modifiers */
+
+    event->bstate = bstate & SP->_trap_mbe;
+
+    return OK;
+}
+
+int ungetmouse(MEVENT *event)
+{
+    int i;
+    mmask_t bstate;
+
+    PDC_LOG(("ungetmouse() - called\n"));
+
+    assert( event);
+    if (!event || ungot)
+        return ERR;
+
+    ungot = TRUE;
+
+    SP->mouse_status.x = event->x;
+    SP->mouse_status.y = event->y;
+
+    SP->mouse_status.changes = 0;
+    bstate = event->bstate;
+
+    for (i = 0; i < 3; i++)
+    {
+        int shf = i * 5;
+        short button = 0;
+
+        if (bstate & ((BUTTON1_RELEASED | BUTTON1_PRESSED |
+            BUTTON1_TRIPLE_CLICKED |
+            BUTTON1_CLICKED | BUTTON1_DOUBLE_CLICKED) << shf))
+        {
+            SP->mouse_status.changes |= 1 << i;
+
+            if (bstate & (BUTTON1_PRESSED << shf))
+                button = BUTTON_PRESSED;
+            if (bstate & (BUTTON1_CLICKED << shf))
+                button = BUTTON_CLICKED;
+            if (bstate & (BUTTON1_DOUBLE_CLICKED << shf))
+                button = BUTTON_DOUBLE_CLICKED;
+            if (bstate & (BUTTON1_TRIPLE_CLICKED << shf))
+                button = BUTTON_TRIPLE_CLICKED;
+
+            if (bstate & BUTTON_MODIFIER_SHIFT)
+                button |= PDC_BUTTON_SHIFT;
+            if (bstate & BUTTON_MODIFIER_CONTROL)
+                button |= PDC_BUTTON_CONTROL;
+            if (bstate & BUTTON_MODIFIER_ALT)
+                button |= PDC_BUTTON_ALT;
+        }
+
+        SP->mouse_status.button[i] = button;
+    }
+
+    if (bstate & BUTTON4_PRESSED)
+        SP->mouse_status.changes |= PDC_MOUSE_WHEEL_UP;
+    else if (bstate & BUTTON5_PRESSED)
+        SP->mouse_status.changes |= PDC_MOUSE_WHEEL_DOWN;
+
+    return PDC_ungetch(KEY_MOUSE);
+}
+
+bool has_mouse(void)
+{
+    return PDC_has_mouse();
+}
diff --git a/lib/PDCursesMod/pdcurses/move.c b/lib/PDCursesMod/pdcurses/move.c
new file mode 100644
index 00000000000..db2bc9512a0
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/move.c
@@ -0,0 +1,83 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+move
+----
+
+### Synopsis
+
+    int move(int y, int x);
+    int mvcur(int oldrow, int oldcol, int newrow, int newcol);
+    int wmove(WINDOW *win, int y, int x);
+
+### Description
+
+   move() and wmove() move the cursor associated with the window to the
+   given location. This does not move the physical cursor of the
+   terminal until refresh() is called. The position specified is
+   relative to the upper left corner of the window, which is (0,0).
+
+   mvcur() moves the physical cursor without updating any window cursor
+   positions.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    move                        Y       Y       Y
+    mvcur                       Y       Y       Y
+    wmove                       Y       Y       Y
+
+**man-end****************************************************************/
+
+int move(int y, int x)
+{
+    PDC_LOG(("move() - called: y=%d x=%d\n", y, x));
+
+    assert( stdscr);
+    if (!stdscr || x < 0 || y < 0 || x >= stdscr->_maxx || y >= stdscr->_maxy)
+        return ERR;
+
+    stdscr->_curx = x;
+    stdscr->_cury = y;
+
+    return OK;
+}
+
+int mvcur(int oldrow, int oldcol, int newrow, int newcol)
+{
+    PDC_LOG(("mvcur() - called: oldrow %d oldcol %d newrow %d newcol %d\n",
+             oldrow, oldcol, newrow, newcol));
+
+    assert( SP);
+    INTENTIONALLY_UNUSED_PARAMETER( oldrow);
+    INTENTIONALLY_UNUSED_PARAMETER( oldcol);
+    if (!SP || newrow < 0 || newrow >= LINES || newcol < 0 || newcol >= COLS)
+        return ERR;
+
+    PDC_gotoyx(newrow, newcol);
+    SP->cursrow = newrow;
+    SP->curscol = newcol;
+
+    return OK;
+}
+
+int wmove(WINDOW *win, int y, int x)
+{
+    PDC_LOG(("wmove() - called: y=%d x=%d\n", y, x));
+
+    assert( win);
+    if (!win || x < 0 || y < 0 || x >= win->_maxx || y >= win->_maxy)
+        return ERR;
+
+    win->_curx = x;
+    win->_cury = y;
+
+    return OK;
+}
diff --git a/lib/PDCursesMod/pdcurses/outopts.c b/lib/PDCursesMod/pdcurses/outopts.c
new file mode 100644
index 00000000000..5e4110f4226
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/outopts.c
@@ -0,0 +1,186 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+outopts
+-------
+
+### Synopsis
+
+    int clearok(WINDOW *win, bool bf);
+    int idlok(WINDOW *win, bool bf);
+    void idcok(WINDOW *win, bool bf);
+    void immedok(WINDOW *win, bool bf);
+    int leaveok(WINDOW *win, bool bf);
+    int setscrreg(int top, int bot);
+    int wsetscrreg(WINDOW *win, int top, int bot);
+    int scrollok(WINDOW *win, bool bf);
+
+    int raw_output(bool bf);
+
+    bool is_leaveok(const WINDOW *win);
+
+### Description
+
+   With clearok(), if bf is TRUE, the next call to wrefresh() with this
+   window will clear the screen completely and redraw the entire screen.
+
+   immedok(), called with a second argument of TRUE, causes an automatic
+   wrefresh() every time a change is made to the specified window.
+
+   Normally, the hardware cursor is left at the location of the window
+   being refreshed. leaveok() allows the cursor to be left wherever the
+   update happens to leave it. It's useful for applications where the
+   cursor is not used, since it reduces the need for cursor motions. If
+   possible, the cursor is made invisible when this option is enabled.
+
+   wsetscrreg() sets a scrolling region in a window; "top" and "bot" are
+   the line numbers for the top and bottom margins. If this option and
+   scrollok() are enabled, any attempt to move off the bottom margin
+   will cause all lines in the scrolling region to scroll up one line.
+   setscrreg() is the stdscr version.
+
+   idlok() and idcok() do nothing in PDCurses, but are provided for
+   compatibility with other curses implementations.
+
+   raw_output() enables the output of raw characters using the standard
+   *add* and *ins* curses functions (that is, it disables translation of
+   control characters).
+
+   is_leaveok() reports whether the specified window is in leaveok mode.
+
+### Return Value
+
+   All functions except is_leaveok() return OK on success and ERR on
+   error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    clearok                     Y       Y       Y
+    idlok                       Y       Y       Y
+    idcok                       Y       Y       Y
+    immedok                     Y       Y       Y
+    leaveok                     Y       Y       Y
+    setscrreg                   Y       Y       Y
+    wsetscrreg                  Y       Y       Y
+    scrollok                    Y       Y       Y
+    is_leaveok                  -       Y       Y
+    raw_output                  -       -       -
+
+**man-end****************************************************************/
+
+int clearok(WINDOW *win, bool bf)
+{
+    PDC_LOG(("clearok() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_clear = bf;
+
+    return OK;
+}
+
+int idlok(WINDOW *win, bool bf)
+{
+    INTENTIONALLY_UNUSED_PARAMETER( win);
+    INTENTIONALLY_UNUSED_PARAMETER( bf);
+    PDC_LOG(("idlok() - called\n"));
+
+    return OK;
+}
+
+void idcok(WINDOW *win, bool bf)
+{
+    INTENTIONALLY_UNUSED_PARAMETER( win);
+    INTENTIONALLY_UNUSED_PARAMETER( bf);
+    PDC_LOG(("idcok() - called\n"));
+}
+
+void immedok(WINDOW *win, bool bf)
+{
+    PDC_LOG(("immedok() - called\n"));
+
+    if (win)
+        win->_immed = bf;
+}
+
+int leaveok(WINDOW *win, bool bf)
+{
+    PDC_LOG(("leaveok() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_leaveit = bf;
+
+    curs_set(!bf);
+
+    return OK;
+}
+
+int setscrreg(int top, int bottom)
+{
+    PDC_LOG(("setscrreg() - called: top %d bottom %d\n", top, bottom));
+
+    return wsetscrreg(stdscr, top, bottom);
+}
+
+int wsetscrreg(WINDOW *win, int top, int bottom)
+{
+    PDC_LOG(("wsetscrreg() - called: top %d bottom %d\n", top, bottom));
+
+    assert( win);
+    if (win && 0 <= top && top <= win->_cury &&
+        win->_cury <= bottom && bottom < win->_maxy)
+    {
+        win->_tmarg = top;
+        win->_bmarg = bottom;
+
+        return OK;
+    }
+    else
+        return ERR;
+}
+
+int scrollok(WINDOW *win, bool bf)
+{
+    PDC_LOG(("scrollok() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_scroll = bf;
+
+    return OK;
+}
+
+int raw_output(bool bf)
+{
+    PDC_LOG(("raw_output() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    SP->raw_out = bf;
+
+    return OK;
+}
+
+bool is_leaveok(const WINDOW *win)
+{
+    PDC_LOG(("is_leaveok() - called\n"));
+
+    assert( win);
+    if (!win)
+        return FALSE;
+
+    return win->_leaveit;
+}
diff --git a/lib/PDCursesMod/pdcurses/overlay.c b/lib/PDCursesMod/pdcurses/overlay.c
new file mode 100644
index 00000000000..5b3b317085c
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/overlay.c
@@ -0,0 +1,221 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+overlay
+-------
+
+### Synopsis
+
+    int overlay(const WINDOW *src_w, WINDOW *dst_w)
+    int overwrite(const WINDOW *src_w, WINDOW *dst_w)
+    int copywin(const WINDOW *src_w, WINDOW *dst_w, int src_tr,
+                int src_tc, int dst_tr, int dst_tc, int dst_br,
+                int dst_bc, int _overlay)
+
+### Description
+
+   overlay() and overwrite() copy all the text from src_w into dst_w.
+   The windows need not be the same size. Those characters in the source
+   window that intersect with the destination window are copied, so that
+   the characters appear in the same physical position on the screen.
+   The difference between the two functions is that overlay() is non-
+   destructive (blanks are not copied) while overwrite() is destructive
+   (blanks are copied).
+
+   copywin() is similar, but doesn't require that the two windows
+   overlap. The arguments src_tc and src_tr specify the top left corner
+   of the region to be copied. dst_tc, dst_tr, dst_br, and dst_bc
+   specify the region within the destination window to copy to. The
+   argument "overlay", if TRUE, indicates that the copy is done non-
+   destructively (as in overlay()); blanks in the source window are not
+   copied to the destination window. When overlay is FALSE, blanks are
+   copied.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    overlay                     Y       Y       Y
+    overwrite                   Y       Y       Y
+    copywin                     Y       Y       Y
+
+**man-end****************************************************************/
+
+/* Thanks to Andreas Otte <venn@@uni-paderborn.de> for the
+   corrected overlay()/overwrite() behavior. */
+
+static int _copy_win(const WINDOW *src_w, WINDOW *dst_w, int src_tr,
+                     int src_tc, int src_br, int src_bc, int dst_tr,
+                     int dst_tc, bool _overlay)
+{
+    int col, line, y1, fc, *minchng, *maxchng;
+    chtype *w1ptr, *w2ptr;
+
+    int lc = 0;
+    int xdiff = src_bc - src_tc;
+    int ydiff = src_br - src_tr;
+
+    assert( src_w);
+    assert( dst_w);
+    if (!src_w || !dst_w)
+        return ERR;
+
+    minchng = dst_w->_firstch;
+    maxchng = dst_w->_lastch;
+
+    for (y1 = 0; y1 < dst_tr; y1++)
+    {
+        minchng++;
+        maxchng++;
+    }
+
+    for (line = 0; line < ydiff; line++)
+    {
+        w1ptr = src_w->_y[line + src_tr] + src_tc;
+        w2ptr = dst_w->_y[line + dst_tr] + dst_tc;
+
+        fc = _NO_CHANGE;
+
+        for (col = 0; col < xdiff; col++)
+        {
+            if ((*w1ptr) != (*w2ptr) &&
+                !((*w1ptr & A_CHARTEXT) == ' ' && _overlay))
+            {
+                *w2ptr = *w1ptr;
+
+                if (fc == _NO_CHANGE)
+                    fc = col + dst_tc;
+
+                lc = col + dst_tc;
+            }
+
+            w1ptr++;
+            w2ptr++;
+        }
+
+        if (*minchng == _NO_CHANGE)
+        {
+            *minchng = fc;
+            *maxchng = lc;
+        }
+        else if (fc != _NO_CHANGE)
+        {
+            if (fc < *minchng)
+                *minchng = fc;
+            if (lc > *maxchng)
+                *maxchng = lc;
+        }
+
+        minchng++;
+        maxchng++;
+    }
+
+    return OK;
+}
+
+int _copy_overlap(const WINDOW *src_w, WINDOW *dst_w, bool overlay)
+{
+    int first_line, first_col, last_line, last_col;
+    int src_start_x, src_start_y, dst_start_x, dst_start_y;
+    int xdiff, ydiff;
+
+    assert( src_w);
+    assert( dst_w);
+    if (!src_w || !dst_w)
+        return ERR;
+
+    first_col = max(dst_w->_begx, src_w->_begx);
+    first_line = max(dst_w->_begy, src_w->_begy);
+
+    last_col = min(src_w->_begx + src_w->_maxx, dst_w->_begx + dst_w->_maxx);
+    last_line = min(src_w->_begy + src_w->_maxy, dst_w->_begy + dst_w->_maxy);
+
+    /* determine the overlapping region of the two windows in real
+       coordinates */
+
+    /* if no overlapping region, do nothing */
+
+    if ((last_col < first_col) || (last_line < first_line))
+        return OK;
+
+    /* size of overlapping region */
+
+    xdiff = last_col - first_col;
+    ydiff = last_line - first_line;
+
+    if (src_w->_begx <= dst_w->_begx)
+    {
+        src_start_x = dst_w->_begx - src_w->_begx;
+        dst_start_x = 0;
+    }
+    else
+    {
+        dst_start_x = src_w->_begx - dst_w->_begx;
+        src_start_x = 0;
+    }
+
+    if (src_w->_begy <= dst_w->_begy)
+    {
+        src_start_y = dst_w->_begy - src_w->_begy;
+        dst_start_y = 0;
+    }
+    else
+    {
+        dst_start_y = src_w->_begy - dst_w->_begy;
+        src_start_y = 0;
+    }
+
+    return _copy_win(src_w, dst_w, src_start_y, src_start_x,
+                     src_start_y + ydiff, src_start_x + xdiff,
+                     dst_start_y, dst_start_x, overlay);
+}
+
+int overlay(const WINDOW *src_w, WINDOW *dst_w)
+{
+    PDC_LOG(("overlay() - called\n"));
+
+    return _copy_overlap(src_w, dst_w, TRUE);
+}
+
+int overwrite(const WINDOW *src_w, WINDOW *dst_w)
+{
+    PDC_LOG(("overwrite() - called\n"));
+
+    return _copy_overlap(src_w, dst_w, FALSE);
+}
+
+int copywin(const WINDOW *src_w, WINDOW *dst_w, int src_tr, int src_tc,
+            int dst_tr, int dst_tc, int dst_br, int dst_bc, int _overlay)
+{
+    int src_end_x, src_end_y;
+    int src_rows, src_cols, dst_rows, dst_cols;
+    int min_rows, min_cols;
+
+    PDC_LOG(("copywin() - called\n"));
+
+    assert( src_w);
+    assert( dst_w);
+    if (!src_w || !dst_w || dst_w == curscr || dst_br >= dst_w->_maxy
+        || dst_bc >= dst_w->_maxx || dst_tr < 0 || dst_tc < 0)
+        return ERR;
+
+    src_rows = src_w->_maxy - src_tr;
+    src_cols = src_w->_maxx - src_tc;
+    dst_rows = dst_br - dst_tr + 1;
+    dst_cols = dst_bc - dst_tc + 1;
+
+    min_rows = min(src_rows, dst_rows);
+    min_cols = min(src_cols, dst_cols);
+
+    src_end_y = src_tr + min_rows;
+    src_end_x = src_tc + min_cols;
+
+    return _copy_win(src_w, dst_w, src_tr, src_tc, src_end_y, src_end_x,
+                     dst_tr, dst_tc, (bool)_overlay);
+}
diff --git a/lib/PDCursesMod/pdcurses/pad.c b/lib/PDCursesMod/pdcurses/pad.c
new file mode 100644
index 00000000000..53efc8bf0b6
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/pad.c
@@ -0,0 +1,283 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+pad
+---
+
+### Synopsis
+
+    WINDOW *newpad(int nlines, int ncols);
+    WINDOW *subpad(WINDOW *orig, int nlines, int ncols,
+                   int begy, int begx);
+    int prefresh(WINDOW *win, int py, int px, int sy1, int sx1,
+                 int sy2, int sx2);
+    int pnoutrefresh(WINDOW *w, int py, int px, int sy1, int sx1,
+                     int sy2, int sx2);
+    int pechochar(WINDOW *pad, chtype ch);
+    int pecho_wchar(WINDOW *pad, const cchar_t *wch);
+
+    bool is_pad(const WINDOW *pad);
+
+### Description
+
+   A pad is a special kind of window, which is not restricted by the
+   screen size, and is not necessarily associated with a particular part
+   of the screen. You can use a pad when you need a large window, and
+   only a part of the window will be on the screen at one time. Pads are
+   not refreshed automatically (e.g., from scrolling or echoing of
+   input). You can't call wrefresh() with a pad as an argument; use
+   prefresh() or pnoutrefresh() instead. Note that these routines
+   require additional parameters to specify the part of the pad to be
+   displayed, and the location to use on the screen.
+
+   newpad() creates a new pad data structure.
+
+   subpad() creates a new sub-pad within a pad, at position (begy,
+   begx), with dimensions of nlines lines and ncols columns. This
+   position is relative to the pad, and not to the screen as with
+   subwin. Changes to either the parent pad or sub-pad will affect both.
+   When using sub-pads, you may need to call touchwin() before calling
+   prefresh().
+
+   pnoutrefresh() copies the specified pad to the virtual screen.
+
+   prefresh() calls pnoutrefresh(), followed by doupdate().
+
+   These routines are analogous to wnoutrefresh() and wrefresh(). (py,
+   px) specifies the upper left corner of the part of the pad to be
+   displayed; (sy1, sx1) and (sy2, sx2) describe the screen rectangle
+   that will contain the selected part of the pad.
+
+   pechochar() is functionally equivalent to addch() followed by a call
+   to prefresh(), with the last-used coordinates and dimensions.
+   pecho_wchar() is the wide-character version.
+
+   is_pad() reports whether the specified window is a pad.
+
+### Return Value
+
+   All functions except is_pad() return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    newpad                      Y       Y       Y
+    subpad                      Y       Y       Y
+    prefresh                    Y       Y       Y
+    pnoutrefresh                Y       Y       Y
+    pechochar                   Y       Y       Y
+    pecho_wchar                 Y       Y       Y
+    is_pad                      -       Y       Y
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+/* save values for pechochar() */
+
+static int save_pminrow, save_pmincol;
+static int save_sminrow, save_smincol, save_smaxrow, save_smaxcol;
+
+WINDOW *newpad(int nlines, int ncols)
+{
+    WINDOW *win;
+
+    PDC_LOG(("newpad() - called: lines=%d cols=%d\n", nlines, ncols));
+
+    win = PDC_makenew(nlines, ncols, 0, 0);
+    if (win)
+        win = PDC_makelines(win);
+
+    if (!win)
+        return (WINDOW *)NULL;
+
+    werase(win);
+
+    win->_flags = _PAD;
+
+    /* save default values in case pechochar() is the first call to
+       prefresh(). */
+
+    save_pminrow = 0;
+    save_pmincol = 0;
+    save_sminrow = 0;
+    save_smincol = 0;
+    save_smaxrow = min(LINES, nlines) - 1;
+    save_smaxcol = min(COLS, ncols) - 1;
+
+    return win;
+}
+
+WINDOW *subpad(WINDOW *orig, int nlines, int ncols, int begy, int begx)
+{
+    WINDOW *win;
+    int i;
+
+    PDC_LOG(("subpad() - called: lines=%d cols=%d begy=%d begx=%d\n",
+             nlines, ncols, begy, begx));
+
+    assert( orig);
+    if (!orig || !(orig->_flags & _PAD))
+        return (WINDOW *)NULL;
+
+    /* make sure window fits inside the original one */
+
+    if (begy < 0 || begx < 0 ||
+        (begy + nlines) > orig->_maxy ||
+        (begx + ncols)  > orig->_maxx)
+        return (WINDOW *)NULL;
+
+    if (!nlines)
+        nlines = orig->_maxy - begy;
+
+    if (!ncols)
+        ncols = orig->_maxx - begx;
+
+    win = PDC_makenew(nlines, ncols, begy, begx);
+    if (!win)
+        return (WINDOW *)NULL;
+
+    /* initialize window variables */
+
+    win->_attrs = orig->_attrs;
+    win->_leaveit = orig->_leaveit;
+    win->_scroll = orig->_scroll;
+    win->_nodelay = orig->_nodelay;
+    win->_use_keypad = orig->_use_keypad;
+    win->_parent = orig;
+
+    for (i = 0; i < nlines; i++)
+        win->_y[i] = orig->_y[begy + i] + begx;
+
+    win->_flags = _SUBPAD;
+
+    /* save default values in case pechochar() is the first call
+       to prefresh(). */
+
+    save_pminrow = 0;
+    save_pmincol = 0;
+    save_sminrow = 0;
+    save_smincol = 0;
+    save_smaxrow = min(LINES, nlines) - 1;
+    save_smaxcol = min(COLS, ncols) - 1;
+
+    return win;
+}
+
+int prefresh(WINDOW *win, int py, int px, int sy1, int sx1, int sy2, int sx2)
+{
+    PDC_LOG(("prefresh() - called\n"));
+
+    if (pnoutrefresh(win, py, px, sy1, sx1, sy2, sx2) == ERR)
+        return ERR;
+
+    doupdate();
+    return OK;
+}
+
+int pnoutrefresh(WINDOW *w, int py, int px, int sy1, int sx1, int sy2, int sx2)
+{
+    int num_cols;
+    int sline = sy1;
+    int pline = py;
+
+    PDC_LOG(("pnoutrefresh() - called\n"));
+
+    assert( w);
+    if (!w || !(w->_flags & (_PAD|_SUBPAD)) || (sy2 >= LINES) || (sx2 >= COLS))
+        return ERR;
+
+    if (py < 0)
+        py = 0;
+    if (px < 0)
+        px = 0;
+    if (sy1 < 0)
+        sy1 = 0;
+    if (sx1 < 0)
+        sx1 = 0;
+
+    if (sy2 < sy1 || sx2 < sx1)
+        return ERR;
+
+    num_cols = min((sx2 - sx1 + 1), (w->_maxx - px));
+
+    while (sline <= sy2)
+    {
+        if (pline < w->_maxy)
+        {
+            memcpy(curscr->_y[sline] + sx1, w->_y[pline] + px,
+                   num_cols * sizeof(chtype));
+
+            if ((curscr->_firstch[sline] == _NO_CHANGE)
+                || (curscr->_firstch[sline] > sx1))
+                curscr->_firstch[sline] = sx1;
+
+            if (sx2 > curscr->_lastch[sline])
+                curscr->_lastch[sline] = sx2;
+
+            w->_firstch[pline] = _NO_CHANGE; /* updated now */
+            w->_lastch[pline] = _NO_CHANGE;  /* updated now */
+        }
+
+        sline++;
+        pline++;
+    }
+
+    if (w->_clear)
+    {
+        w->_clear = FALSE;
+        curscr->_clear = TRUE;
+    }
+
+    /* position the cursor to the pad's current position if possible --
+       is the pad current position going to end up displayed? if not,
+       then don't move the cursor; if so, move it to the correct place */
+
+    if (!w->_leaveit && w->_cury >= py && w->_curx >= px &&
+         w->_cury <= py + (sy2 - sy1) && w->_curx <= px + (sx2 - sx1))
+    {
+        curscr->_cury = (w->_cury - py) + sy1;
+        curscr->_curx = (w->_curx - px) + sx1;
+    }
+
+    return OK;
+}
+
+int pechochar(WINDOW *pad, chtype ch)
+{
+    PDC_LOG(("pechochar() - called\n"));
+
+    if (waddch(pad, ch) == ERR)
+        return ERR;
+
+    return prefresh(pad, save_pminrow, save_pmincol, save_sminrow,
+                    save_smincol, save_smaxrow, save_smaxcol);
+}
+
+#ifdef PDC_WIDE
+int pecho_wchar(WINDOW *pad, const cchar_t *wch)
+{
+    PDC_LOG(("pecho_wchar() - called\n"));
+
+    assert( wch);
+    if (!wch || (waddch(pad, *wch) == ERR))
+        return ERR;
+
+    return prefresh(pad, save_pminrow, save_pmincol, save_sminrow,
+                    save_smincol, save_smaxrow, save_smaxcol);
+}
+#endif
+
+bool is_pad(const WINDOW *pad)
+{
+    PDC_LOG(("is_pad() - called\n"));
+
+    assert( pad);
+    if (!pad)
+        return FALSE;
+
+    return (pad->_flags & _PAD) ? TRUE : FALSE;
+}
diff --git a/lib/PDCursesMod/pdcurses/panel.c b/lib/PDCursesMod/pdcurses/panel.c
new file mode 100644
index 00000000000..15ddba5c33d
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/panel.c
@@ -0,0 +1,670 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+panel
+-----
+
+### Synopsis
+
+    int bottom_panel(PANEL *pan);
+    int del_panel(PANEL *pan);
+    int hide_panel(PANEL *pan);
+    int move_panel(PANEL *pan, int starty, int startx);
+    PANEL *new_panel(WINDOW *win);
+    PANEL *panel_above(const PANEL *pan);
+    PANEL *panel_below(const PANEL *pan);
+    PANEL *ground_panel(SCREEN *sp);
+    PANEL *ceiling_panel(SCREEN *sp);
+    int panel_hidden(const PANEL *pan);
+    const void *panel_userptr(const PANEL *pan);
+    WINDOW *panel_window(const PANEL *pan);
+    int replace_panel(PANEL *pan, WINDOW *win);
+    int set_panel_userptr(PANEL *pan, const void *uptr);
+    int show_panel(PANEL *pan);
+    int top_panel(PANEL *pan);
+    void update_panels(void);
+
+### Description
+
+   For historic reasons, and for compatibility with other versions of
+   curses, the panel functions are prototyped in a separate header,
+   panel.h. In many implementations, they're also in a separate library,
+   but PDCurses incorporates them.
+
+   The panel functions provide a way to have depth relationships between
+   curses windows. Panels can overlap without making visible the
+   overlapped portions of underlying windows. The initial curses window,
+   stdscr, lies beneath all panels. The set of currently visible panels
+   is the 'deck' of panels.
+
+   You can create panels, fetch and set their associated windows,
+   shuffle panels in the deck, and manipulate them in other ways.
+
+   bottom_panel() places pan at the bottom of the deck. The size,
+   location and contents of the panel are unchanged.
+
+   del_panel() deletes pan, but not its associated winwow.
+
+   hide_panel() removes a panel from the deck and thus hides it from
+   view.
+
+   move_panel() moves the curses window associated with pan, so that its
+   upper lefthand corner is at the supplied coordinates. (Don't use
+   mvwin() on the window.)
+
+   new_panel() creates a new panel associated with win and returns the
+   panel pointer. The new panel is placed at the top of the deck.
+
+   panel_above() returns a pointer to the panel in the deck above pan,
+   or NULL if pan is the top panel. If the value of pan passed is NULL,
+   this function returns a pointer to the bottom panel in the deck.
+
+   panel_below() returns a pointer to the panel in the deck below pan,
+   or NULL if pan is the bottom panel. If the value of pan passed is
+   NULL, this function returns a pointer to the top panel in the deck.
+
+   ground_panel() returns a pointer to the bottom panel in the deck.
+
+   ceiling_panel() returns a pointer to the top panel in the deck.
+
+   panel_hidden() returns OK if pan is hidden and ERR if it is not.
+
+   panel_userptr() - Each panel has a user pointer available for
+   maintaining relevant information. This function returns a pointer to
+   that information previously set up by set_panel_userptr().
+
+   panel_window() returns a pointer to the curses window associated with
+   the panel.
+
+   replace_panel() replaces the current window of pan with win.
+
+   set_panel_userptr() - Each panel has a user pointer available for
+   maintaining relevant information. This function sets the value of
+   that information.
+
+   show_panel() makes a previously hidden panel visible and places it
+   back in the deck on top.
+
+   top_panel() places pan on the top of the deck. The size, location and
+   contents of the panel are unchanged.
+
+   update_panels() refreshes the virtual screen to reflect the depth
+   relationships between the panels in the deck. The user must use
+   doupdate() to refresh the physical screen.
+
+### Return Value
+
+   Each routine that returns a pointer to an object returns NULL if an
+   error occurs. Each panel routine that returns an integer, returns OK
+   if it executes successfully and ERR if it does not.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    bottom_panel                -       Y       Y
+    del_panel                   -       Y       Y
+    hide_panel                  -       Y       Y
+    move_panel                  -       Y       Y
+    new_panel                   -       Y       Y
+    panel_above                 -       Y       Y
+    panel_below                 -       Y       Y
+    ground_panel                -       Y       N
+    ceiling_panel               -       Y       N
+    panel_hidden                -       Y       Y
+    panel_userptr               -       Y       Y
+    panel_window                -       Y       Y
+    replace_panel               -       Y       Y
+    set_panel_userptr           -       Y       Y
+    show_panel                  -       Y       Y
+    top_panel                   -       Y       Y
+    update_panels               -       Y       Y
+
+  Credits:
+    Original Author - Warren Tucker <wht@n4hgf.mt-park.ga.us>
+
+**man-end****************************************************************/
+
+#include <panel.h>
+#include <stdlib.h>
+
+PANEL *_bottom_panel = (PANEL *)0;
+PANEL *_top_panel = (PANEL *)0;
+PANEL _stdscr_pseudo_panel;
+
+#ifdef PANEL_DEBUG
+
+static void dPanel(char *text, PANEL *pan)
+{
+    PDC_LOG(("%s id=%s b=%s a=%s y=%d x=%d", text, pan->user,
+             pan->below ? pan->below->user : "--",
+             pan->above ? pan->above->user : "--",
+             pan->wstarty, pan->wstartx));
+}
+
+static void dStack(char *fmt, int num, PANEL *pan)
+{
+    char s80[80];
+
+    sprintf(s80, fmt, num, pan);
+    PDC_LOG(("%s b=%s t=%s", s80, _bottom_panel ? _bottom_panel->user : "--",
+             _top_panel    ? _top_panel->user    : "--"));
+
+    if (pan)
+        PDC_LOG(("pan id=%s", pan->user));
+
+    pan = _bottom_panel;
+
+    while (pan)
+    {
+        dPanel("stk", pan);
+        pan = pan->above;
+    }
+}
+
+/* debugging hook for wnoutrefresh */
+
+static void Wnoutrefresh(PANEL *pan)
+{
+    dPanel("wnoutrefresh", pan);
+    wnoutrefresh(pan->win);
+}
+
+static void Touchpan(PANEL *pan)
+{
+    dPanel("Touchpan", pan);
+    touchwin(pan->win);
+}
+
+static void Touchline(PANEL *pan, int start, int count)
+{
+    char s80[80];
+
+    sprintf(s80, "Touchline s=%d c=%d", start, count);
+    dPanel(s80, pan);
+    touchline(pan->win, start, count);
+}
+
+#else   /* PANEL_DEBUG */
+
+#define dPanel(text, pan)
+#define dStack(fmt, num, pan)
+#define Wnoutrefresh(pan) wnoutrefresh((pan)->win)
+#define Touchpan(pan) touchwin((pan)->win)
+#define Touchline(pan, start, count) touchline((pan)->win, start, count)
+
+#endif  /* PANEL_DEBUG */
+
+static bool _panels_overlapped(PANEL *pan1, PANEL *pan2)
+{
+    assert( pan1);
+    assert( pan2);
+    if (!pan1 || !pan2)
+        return FALSE;
+
+    return ((pan1->wstarty >= pan2->wstarty && pan1->wstarty < pan2->wendy)
+         || (pan2->wstarty >= pan1->wstarty && pan2->wstarty < pan1->wendy))
+        && ((pan1->wstartx >= pan2->wstartx && pan1->wstartx < pan2->wendx)
+         || (pan2->wstartx >= pan1->wstartx && pan2->wstartx < pan1->wendx));
+}
+
+static void _free_obscure(PANEL *pan)
+{
+    PANELOBS *tobs = pan->obscure;  /* "this" one */
+    PANELOBS *nobs;                 /* "next" one */
+
+    while (tobs)
+    {
+        nobs = tobs->above;
+        free((char *)tobs);
+        tobs = nobs;
+    }
+    pan->obscure = (PANELOBS *)0;
+}
+
+static void _override(PANEL *pan, int show)
+{
+    int y;
+    PANEL *pan2;
+    PANELOBS *tobs = pan->obscure;      /* "this" one */
+
+    if (show == 1)
+        Touchpan(pan);
+    else if (!show)
+    {
+        Touchpan(pan);
+        Touchpan(&_stdscr_pseudo_panel);
+    }
+    else if (show == -1)
+        while (tobs && (tobs->pan != pan))
+            tobs = tobs->above;
+
+    while (tobs)
+    {
+        if ((pan2 = tobs->pan) != pan)
+            for (y = pan->wstarty; y < pan->wendy; y++)
+                if ((y >= pan2->wstarty) && (y < pan2->wendy) &&
+                   ((is_linetouched(pan->win, y - pan->wstarty)) ||
+                    (is_linetouched(stdscr, y))))
+                    Touchline(pan2, y - pan2->wstarty, 1);
+
+        tobs = tobs->above;
+    }
+}
+
+static void _calculate_obscure(void)
+{
+    PANEL *pan, *pan2;
+    PANELOBS *tobs;     /* "this" one */
+    PANELOBS *lobs;     /* last one */
+
+    pan = _bottom_panel;
+
+    while (pan)
+    {
+        if (pan->obscure)
+            _free_obscure(pan);
+
+        lobs = (PANELOBS *)0;
+        pan2 = _bottom_panel;
+
+        while (pan2)
+        {
+            if (_panels_overlapped(pan, pan2))
+            {
+                if ((tobs = malloc(sizeof(PANELOBS))) == NULL)
+                    return;
+
+                tobs->pan = pan2;
+                dPanel("obscured", pan2);
+                tobs->above = (PANELOBS *)0;
+
+                if (lobs)
+                    lobs->above = tobs;
+                else
+                    pan->obscure = tobs;
+
+                lobs  = tobs;
+            }
+
+            pan2 = pan2->above;
+        }
+
+        _override(pan, 1);
+        pan = pan->above;
+    }
+}
+
+/* check to see if panel is in the stack */
+
+static bool _panel_is_linked(const PANEL *pan)
+{
+    PANEL *pan2 = _bottom_panel;
+
+    while (pan2)
+    {
+        if (pan2 == pan)
+            return TRUE;
+
+        pan2 = pan2->above;
+    }
+
+    return FALSE;
+}
+
+/* link panel into stack at top */
+
+static void _panel_link_top(PANEL *pan)
+{
+#ifdef PANEL_DEBUG
+    dStack("<lt%d>", 1, pan);
+    if (_panel_is_linked(pan))
+        return;
+#endif
+    pan->above = (PANEL *)0;
+    pan->below = (PANEL *)0;
+
+    if (_top_panel)
+    {
+        _top_panel->above = pan;
+        pan->below = _top_panel;
+    }
+
+    _top_panel = pan;
+
+    if (!_bottom_panel)
+        _bottom_panel = pan;
+
+    _calculate_obscure();
+    dStack("<lt%d>", 9, pan);
+}
+
+/* link panel into stack at bottom */
+
+static void _panel_link_bottom(PANEL *pan)
+{
+#ifdef PANEL_DEBUG
+    dStack("<lb%d>", 1, pan);
+    if (_panel_is_linked(pan))
+        return;
+#endif
+    pan->above = (PANEL *)0;
+    pan->below = (PANEL *)0;
+
+    if (_bottom_panel)
+    {
+        _bottom_panel->below = pan;
+        pan->above = _bottom_panel;
+    }
+
+    _bottom_panel = pan;
+
+    if (!_top_panel)
+        _top_panel = pan;
+
+    _calculate_obscure();
+    dStack("<lb%d>", 9, pan);
+}
+
+static void _panel_unlink(PANEL *pan)
+{
+    PANEL *prev;
+    PANEL *next;
+
+#ifdef PANEL_DEBUG
+    dStack("<u%d>", 1, pan);
+    if (!_panel_is_linked(pan))
+        return;
+#endif
+    _override(pan, 0);
+    _free_obscure(pan);
+
+    prev = pan->below;
+    next = pan->above;
+
+    /* if non-zero, we will not update the list head */
+
+    if (prev)
+    {
+        prev->above = next;
+        if(next)
+            next->below = prev;
+    }
+    else if (next)
+        next->below = prev;
+
+    if (pan == _bottom_panel)
+        _bottom_panel = next;
+
+    if (pan == _top_panel)
+        _top_panel = prev;
+
+    _calculate_obscure();
+
+    pan->above = (PANEL *)0;
+    pan->below = (PANEL *)0;
+    dStack("<u%d>", 9, pan);
+
+}
+
+/************************************************************************
+ *   The following are the public functions for the panels library.     *
+ ************************************************************************/
+
+int bottom_panel(PANEL *pan)
+{
+    assert( pan);
+    if (!pan)
+        return ERR;
+
+    if (pan == _bottom_panel)
+        return OK;
+
+    if (_panel_is_linked(pan))
+        hide_panel(pan);
+
+    _panel_link_bottom(pan);
+
+    return OK;
+}
+
+int del_panel(PANEL *pan)
+{
+    assert( pan);
+    if (pan)
+    {
+        if (_panel_is_linked(pan))
+            hide_panel(pan);
+
+        free((char *)pan);
+        return OK;
+    }
+
+    return ERR;
+}
+
+int hide_panel(PANEL *pan)
+{
+    assert( pan);
+    if (!pan)
+        return ERR;
+
+    if (!_panel_is_linked(pan))
+    {
+        pan->above = (PANEL *)0;
+        pan->below = (PANEL *)0;
+        return ERR;
+    }
+
+    _panel_unlink(pan);
+
+    return OK;
+}
+
+int move_panel(PANEL *pan, int starty, int startx)
+{
+    WINDOW *win;
+    int maxy, maxx, rval;
+
+    assert( pan);
+    if (!pan)
+        return ERR;
+
+    if (_panel_is_linked(pan))
+        _override(pan, 0);
+
+    win = pan->win;
+
+    rval = mvwin(win, starty, startx);
+    if( rval != ERR)
+    {
+        getbegyx(win, pan->wstarty, pan->wstartx);
+        getmaxyx(win, maxy, maxx);
+        pan->wendy = pan->wstarty + maxy;
+        pan->wendx = pan->wstartx + maxx;
+    }
+
+    if (_panel_is_linked(pan))
+        _calculate_obscure();
+
+    return rval;
+}
+
+PANEL *new_panel(WINDOW *win)
+{
+    PANEL *pan;
+
+    assert( win);
+    if (!win)
+        return (PANEL *)NULL;
+
+    pan  = malloc(sizeof(PANEL));
+
+    if (!_stdscr_pseudo_panel.win)
+    {
+        _stdscr_pseudo_panel.win = stdscr;
+        _stdscr_pseudo_panel.wstarty = 0;
+        _stdscr_pseudo_panel.wstartx = 0;
+        _stdscr_pseudo_panel.wendy = LINES;
+        _stdscr_pseudo_panel.wendx = COLS;
+        _stdscr_pseudo_panel.user = "stdscr";
+        _stdscr_pseudo_panel.obscure = (PANELOBS *)0;
+    }
+
+    if (pan)
+    {
+        int maxy, maxx;
+
+        pan->win = win;
+        pan->above = (PANEL *)0;
+        pan->below = (PANEL *)0;
+        getbegyx(win, pan->wstarty, pan->wstartx);
+        getmaxyx(win, maxy, maxx);
+        pan->wendy = pan->wstarty + maxy;
+        pan->wendx = pan->wstartx + maxx;
+#ifdef PANEL_DEBUG
+        pan->user = "new";
+#else
+        pan->user = (char *)0;
+#endif
+        pan->obscure = (PANELOBS *)0;
+        show_panel(pan);
+    }
+
+    return pan;
+}
+
+PANEL *panel_above(const PANEL *pan)
+{
+    return pan ? pan->above : _bottom_panel;
+}
+
+PANEL *panel_below(const PANEL *pan)
+{
+    return pan ? pan->below : _top_panel;
+}
+
+PANEL *ceiling_panel( SCREEN *sp)
+{
+   INTENTIONALLY_UNUSED_PARAMETER( sp);
+   return( panel_below( NULL));
+}
+
+PANEL *ground_panel( SCREEN *sp)
+{
+   INTENTIONALLY_UNUSED_PARAMETER( sp);
+   return( panel_above( NULL));
+}
+
+int panel_hidden(const PANEL *pan)
+{
+    assert( pan);
+    if (!pan)
+        return ERR;
+
+    return _panel_is_linked(pan) ? ERR : OK;
+}
+
+const void *panel_userptr(const PANEL *pan)
+{
+    assert( pan);
+    return pan ? pan->user : NULL;
+}
+
+WINDOW *panel_window(const PANEL *pan)
+{
+    PDC_LOG(("panel_window() - called\n"));
+
+    assert( pan);
+    if (!pan)
+        return (WINDOW *)NULL;
+
+    return pan->win;
+}
+
+int replace_panel(PANEL *pan, WINDOW *win)
+{
+    int maxy, maxx;
+
+    assert( pan);
+    assert( win);
+    if (!pan)
+        return ERR;
+
+    if (_panel_is_linked(pan))
+        _override(pan, 0);
+
+    pan->win = win;
+    getbegyx(win, pan->wstarty, pan->wstartx);
+    getmaxyx(win, maxy, maxx);
+    pan->wendy = pan->wstarty + maxy;
+    pan->wendx = pan->wstartx + maxx;
+
+    if (_panel_is_linked(pan))
+        _calculate_obscure();
+
+    return OK;
+}
+
+int set_panel_userptr(PANEL *pan, const void *uptr)
+{
+    assert( pan);
+    if (!pan)
+        return ERR;
+
+    pan->user = uptr;
+    return OK;
+}
+
+int show_panel(PANEL *pan)
+{
+    assert( pan);
+    if (!pan)
+        return ERR;
+
+    if (pan == _top_panel)
+        return OK;
+
+    if (_panel_is_linked(pan))
+        hide_panel(pan);
+
+    _panel_link_top(pan);
+
+    return OK;
+}
+
+int top_panel(PANEL *pan)
+{
+    assert( pan);
+    return show_panel(pan);
+}
+
+void update_panels(void)
+{
+    PANEL *pan;
+
+    PDC_LOG(("update_panels() - called\n"));
+
+    pan = _bottom_panel;
+
+    while (pan)
+    {
+        _override(pan, -1);
+        pan = pan->above;
+    }
+
+    if (is_wintouched(stdscr))
+        Wnoutrefresh(&_stdscr_pseudo_panel);
+
+    pan = _bottom_panel;
+
+    while (pan)
+    {
+        if (is_wintouched(pan->win) || !pan->above)
+            Wnoutrefresh(pan);
+
+        pan = pan->above;
+    }
+}
diff --git a/lib/PDCursesMod/pdcurses/printw.c b/lib/PDCursesMod/pdcurses/printw.c
new file mode 100644
index 00000000000..7d19a9978ea
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/printw.c
@@ -0,0 +1,129 @@
+/* PDCurses */
+
+#include <curspriv.h>
+
+/*man-start**************************************************************
+
+printw
+------
+
+### Synopsis
+
+    int printw(const char *fmt, ...);
+    int wprintw(WINDOW *win, const char *fmt, ...);
+    int mvprintw(int y, int x, const char *fmt, ...);
+    int mvwprintw(WINDOW *win, int y, int x, const char *fmt,...);
+    int vwprintw(WINDOW *win, const char *fmt, va_list varglist);
+    int vw_printw(WINDOW *win, const char *fmt, va_list varglist);
+
+### Description
+
+   The printw() functions add a formatted string to the window at the
+   current or specified cursor position. The format strings are the same
+   as used in the standard C library's printf(). (printw() can be used
+   as a drop-in replacement for printf().)
+
+   The duplication between vwprintw() and vw_printw() is for historic
+   reasons. In PDCurses, they're the same.
+
+### Return Value
+
+   All functions return the number of characters printed, or ERR on
+   error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    printw                      Y       Y       Y
+    wprintw                     Y       Y       Y
+    mvprintw                    Y       Y       Y
+    mvwprintw                   Y       Y       Y
+    vwprintw                    Y       Y       Y
+    vw_printw                   Y       Y       Y
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+int vwprintw(WINDOW *win, const char *fmt, va_list varglist)
+{
+    char printbuf[513];
+    int len;
+
+    PDC_LOG(("vwprintw() - called\n"));
+
+#ifdef HAVE_VSNPRINTF
+    len = vsnprintf(printbuf, 512, fmt, varglist);
+#else
+    len = vsprintf(printbuf, fmt, varglist);
+#endif
+    return (waddstr(win, printbuf) == ERR) ? ERR : len;
+}
+
+int printw(const char *fmt, ...)
+{
+    va_list args;
+    int retval;
+
+    PDC_LOG(("printw() - called\n"));
+
+    va_start(args, fmt);
+    retval = vwprintw(stdscr, fmt, args);
+    va_end(args);
+
+    return retval;
+}
+
+int wprintw(WINDOW *win, const char *fmt, ...)
+{
+    va_list args;
+    int retval;
+
+    PDC_LOG(("wprintw() - called\n"));
+
+    va_start(args, fmt);
+    retval = vwprintw(win, fmt, args);
+    va_end(args);
+
+    return retval;
+}
+
+int mvprintw(int y, int x, const char *fmt, ...)
+{
+    va_list args;
+    int retval;
+
+    PDC_LOG(("mvprintw() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    va_start(args, fmt);
+    retval = vwprintw(stdscr, fmt, args);
+    va_end(args);
+
+    return retval;
+}
+
+int mvwprintw(WINDOW *win, int y, int x, const char *fmt, ...)
+{
+    va_list args;
+    int retval;
+
+    PDC_LOG(("mvwprintw() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    va_start(args, fmt);
+    retval = vwprintw(win, fmt, args);
+    va_end(args);
+
+    return retval;
+}
+
+int vw_printw(WINDOW *win, const char *fmt, va_list varglist)
+{
+    PDC_LOG(("vw_printw() - called\n"));
+
+    return vwprintw(win, fmt, varglist);
+}
diff --git a/lib/PDCursesMod/pdcurses/refresh.c b/lib/PDCursesMod/pdcurses/refresh.c
new file mode 100644
index 00000000000..9531abce76f
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/refresh.c
@@ -0,0 +1,304 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+refresh
+-------
+
+### Synopsis
+
+    int refresh(void);
+    int wrefresh(WINDOW *win);
+    int wnoutrefresh(WINDOW *win);
+    int doupdate(void);
+    int redrawwin(WINDOW *win);
+    int wredrawln(WINDOW *win, int beg_line, int num_lines);
+
+### Description
+
+   wrefresh() copies the named window to the physical terminal screen,
+   taking into account what is already there in order to optimize cursor
+   movement. refresh() does the same, using stdscr. These routines must
+   be called to get any output on the terminal, as other routines only
+   manipulate data structures. Unless leaveok() has been enabled, the
+   physical cursor of the terminal is left at the location of the
+   window's cursor.
+
+   wnoutrefresh() and doupdate() allow multiple updates with more
+   efficiency than wrefresh() alone. wrefresh() works by first calling
+   wnoutrefresh(), which copies the named window to the virtual screen.
+   It then calls doupdate(), which compares the virtual screen to the
+   physical screen and does the actual update. A series of calls to
+   wrefresh() will result in alternating calls to wnoutrefresh() and
+   doupdate(), causing several bursts of output to the screen. By first
+   calling wnoutrefresh() for each window, it is then possible to call
+   doupdate() only once.
+
+   In PDCurses, redrawwin() is equivalent to touchwin(), and wredrawln()
+   is the same as touchline(). In some other curses implementations,
+   there's a subtle distinction, but it has no meaning in PDCurses.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    refresh                     Y       Y       Y
+    wrefresh                    Y       Y       Y
+    wnoutrefresh                Y       Y       Y
+    doupdate                    Y       Y       Y
+    redrawwin                   Y       Y       Y
+    wredrawln                   Y       Y       Y
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+static void _normalize_cursor( WINDOW *win)
+{
+    if( win->_cury < 0)
+        win->_cury = 0;
+    if( win->_cury >= win->_maxy)
+        win->_cury = win->_maxy - 1;
+    if( win->_curx < 0)
+        win->_curx = 0;
+    if( win->_curx >= win->_maxx)
+        win->_curx = win->_maxx - 1;
+}
+
+int wnoutrefresh(WINDOW *win)
+{
+    int begy, begx;     /* window's place on screen   */
+    int i, j;
+
+    PDC_LOG(("wnoutrefresh() - called: win=%p\n", win));
+
+    assert( win);
+    if ( !win || (win->_flags & (_PAD|_SUBPAD)) )
+        return ERR;
+
+    begy = win->_begy;
+    begx = win->_begx;
+
+    for (i = 0, j = begy; i < win->_maxy && j < curscr->_maxy; i++, j++)
+    {
+        if (win->_firstch[i] != _NO_CHANGE && j >= 0)
+        {
+            chtype *src = win->_y[i];
+            chtype *dest = curscr->_y[j] + begx;
+
+            int first = win->_firstch[i]; /* first changed */
+            int last = win->_lastch[i];   /* last changed */
+
+            if( last > curscr->_maxx - begx - 1)    /* don't run off right-hand */
+                last = curscr->_maxx - begx - 1;    /* edge of screen */
+            if( first < -begx)       /* ...nor the left edge */
+                first = -begx;
+
+            /* ignore areas on the outside that are marked as changed,
+               but really aren't */
+
+            while (first <= last && src[first] == dest[first])
+                first++;
+
+            while (last >= first && src[last] == dest[last])
+                last--;
+
+            /* if any have really changed... */
+
+            if (first <= last)
+            {
+                memcpy(dest + first, src + first,
+                       (last - first + 1) * sizeof(chtype));
+
+                first += begx;
+                last += begx;
+
+                if (first < curscr->_firstch[j] ||
+                    curscr->_firstch[j] == _NO_CHANGE)
+                    curscr->_firstch[j] = first;
+
+                if (last > curscr->_lastch[j])
+                    curscr->_lastch[j] = last;
+            }
+
+            win->_firstch[i] = _NO_CHANGE;  /* updated now */
+        }
+
+        win->_lastch[i] = _NO_CHANGE;       /* updated now */
+    }
+
+    if (win->_clear)
+        win->_clear = FALSE;
+
+    if (!win->_leaveit)
+    {
+        curscr->_cury = win->_cury + begy;
+        curscr->_curx = win->_curx + begx;
+        _normalize_cursor( curscr);
+    }
+
+    return OK;
+}
+
+int doupdate(void)
+{
+    int y;
+    bool clearall;
+
+    PDC_LOG(("doupdate() - called\n"));
+
+    assert( SP);
+    assert( curscr);
+    if (!SP || !curscr)
+        return ERR;
+
+    if (isendwin())         /* coming back after endwin() called */
+    {
+        reset_prog_mode();
+        clearall = TRUE;
+        SP->alive = TRUE;   /* so isendwin() result is correct */
+    }
+    else
+        clearall = curscr->_clear;
+
+    for (y = 0; y < SP->lines; y++)
+    {
+        PDC_LOG(("doupdate() - Transforming line %d of %d: %s\n",
+                 y, SP->lines, (curscr->_firstch[y] != _NO_CHANGE) ?
+                 "Yes" : "No"));
+
+        if (clearall || curscr->_firstch[y] != _NO_CHANGE)
+        {
+            int first, last;
+
+            chtype *src = curscr->_y[y];
+            chtype *dest = SP->lastscr->_y[y];
+
+            if (clearall)
+            {
+                first = 0;
+                last = COLS - 1;
+            }
+            else
+            {
+                first = curscr->_firstch[y];
+                last = curscr->_lastch[y];
+            }
+
+            while (first <= last)
+            {
+                int len = 0;
+
+                /* build up a run of changed cells; if two runs are
+                   separated by a single unchanged cell, ignore the
+                   break */
+
+                if (clearall)
+                    len = last - first + 1;
+                else
+                    while (first + len <= last &&
+                           (src[first + len] != dest[first + len] ||
+                            (len && first + len < last &&
+                             src[first + len + 1] != dest[first + len + 1])
+                           )
+                          )
+                        len++;
+
+                /* update the screen, and SP->lastscr */
+
+                if (len)
+                {
+                    PDC_transform_line(y, first, len, src + first);
+                    memcpy(dest + first, src + first, len * sizeof(chtype));
+                    first += len;
+                }
+
+                /* skip over runs of unchanged cells */
+
+                while (first <= last && src[first] == dest[first])
+                    first++;
+            }
+
+            curscr->_firstch[y] = _NO_CHANGE;
+            curscr->_lastch[y] = _NO_CHANGE;
+        }
+    }
+
+    curscr->_clear = FALSE;
+
+    if (SP->visibility)
+        PDC_gotoyx(curscr->_cury, curscr->_curx);
+
+    SP->cursrow = curscr->_cury;
+    SP->curscol = curscr->_curx;
+
+    PDC_doupdate();
+
+    return OK;
+}
+
+int wrefresh(WINDOW *win)
+{
+    bool save_clear;
+
+    PDC_LOG(("wrefresh() - called\n"));
+
+    assert( win);
+    if ( !win || (win->_flags & (_PAD|_SUBPAD)) )
+        return ERR;
+
+    save_clear = win->_clear;
+
+    if (win == curscr)
+        curscr->_clear = TRUE;
+    else
+        wnoutrefresh(win);
+
+    if (save_clear && win->_maxy == SP->lines && win->_maxx == SP->cols)
+        curscr->_clear = TRUE;
+
+    return doupdate();
+}
+
+int refresh(void)
+{
+    PDC_LOG(("refresh() - called\n"));
+
+    return wrefresh(stdscr);
+}
+
+int wredrawln(WINDOW *win, int start, int num)
+{
+    int i;
+
+    PDC_LOG(("wredrawln() - called: win=%p start=%d num=%d\n",
+        win, start, num));
+
+    assert( win);
+    if (!win || start > win->_maxy || start + num > win->_maxy)
+        return ERR;
+
+    for (i = start; i < start + num; i++)
+    {
+        win->_firstch[i] = 0;
+        win->_lastch[i] = win->_maxx - 1;
+    }
+
+    return OK;
+}
+
+int redrawwin(WINDOW *win)
+{
+    PDC_LOG(("redrawwin() - called: win=%p\n", win));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    return wredrawln(win, 0, win->_maxy);
+}
diff --git a/lib/PDCursesMod/pdcurses/scanw.c b/lib/PDCursesMod/pdcurses/scanw.c
new file mode 100644
index 00000000000..23a2d412a3a
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/scanw.c
@@ -0,0 +1,581 @@
+/* PDCurses */
+
+#include <curspriv.h>
+
+/*man-start**************************************************************
+
+scanw
+-----
+
+### Synopsis
+
+    int scanw(const char *fmt, ...);
+    int wscanw(WINDOW *win, const char *fmt, ...);
+    int mvscanw(int y, int x, const char *fmt, ...);
+    int mvwscanw(WINDOW *win, int y, int x, const char *fmt, ...);
+    int vwscanw(WINDOW *win, const char *fmt, va_list varglist);
+    int vw_scanw(WINDOW *win, const char *fmt, va_list varglist);
+
+### Description
+
+   These routines correspond to the standard C library's scanf() family.
+   Each gets a string from the window via wgetnstr(), and uses the
+   resulting line as input for the scan.
+
+   The duplication between vwscanw() and vw_scanw() is for historic
+   reasons. In PDCurses, they're the same.
+
+### Return Value
+
+   On successful completion, these functions return the number of items
+   successfully matched. Otherwise they return ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    scanw                       Y       Y       Y
+    wscanw                      Y       Y       Y
+    mvscanw                     Y       Y       Y
+    mvwscanw                    Y       Y       Y
+    vwscanw                     Y       Y       Y
+    vw_scanw                    Y       Y       Y
+
+**man-end****************************************************************/
+
+#include <string.h>
+
+#ifndef HAVE_VSSCANF
+# include <stdlib.h>
+# include <ctype.h>
+# include <limits.h>
+
+static int _pdc_vsscanf(const char *, const char *, va_list);
+
+# define vsscanf _pdc_vsscanf
+#endif
+
+int vwscanw(WINDOW *win, const char *fmt, va_list varglist)
+{
+    char scanbuf[256];
+
+    PDC_LOG(("vwscanw() - called\n"));
+
+    if (wgetnstr(win, scanbuf, 255) == ERR)
+        return ERR;
+
+    return vsscanf(scanbuf, fmt, varglist);
+}
+
+int scanw(const char *fmt, ...)
+{
+    va_list args;
+    int retval;
+
+    PDC_LOG(("scanw() - called\n"));
+
+    va_start(args, fmt);
+    retval = vwscanw(stdscr, fmt, args);
+    va_end(args);
+
+    return retval;
+}
+
+int wscanw(WINDOW *win, const char *fmt, ...)
+{
+    va_list args;
+    int retval;
+
+    PDC_LOG(("wscanw() - called\n"));
+
+    va_start(args, fmt);
+    retval = vwscanw(win, fmt, args);
+    va_end(args);
+
+    return retval;
+}
+
+int mvscanw(int y, int x, const char *fmt, ...)
+{
+    va_list args;
+    int retval;
+
+    PDC_LOG(("mvscanw() - called\n"));
+
+    if (move(y, x) == ERR)
+        return ERR;
+
+    va_start(args, fmt);
+    retval = vwscanw(stdscr, fmt, args);
+    va_end(args);
+
+    return retval;
+}
+
+int mvwscanw(WINDOW *win, int y, int x, const char *fmt, ...)
+{
+    va_list args;
+    int retval;
+
+    PDC_LOG(("mvscanw() - called\n"));
+
+    if (wmove(win, y, x) == ERR)
+        return ERR;
+
+    va_start(args, fmt);
+    retval = vwscanw(win, fmt, args);
+    va_end(args);
+
+    return retval;
+}
+
+int vw_scanw(WINDOW *win, const char *fmt, va_list varglist)
+{
+    PDC_LOG(("vw_scanw() - called\n"));
+
+    return vwscanw(win, fmt, varglist);
+}
+
+#ifndef HAVE_VSSCANF
+
+/* _pdc_vsscanf() - Internal routine to parse and format an input
+   buffer. It scans a series of input fields; each field is formatted
+   according to a supplied format string and the formatted input is
+   stored in the variable number of addresses passed. Returns the number
+   of input fields or EOF on error.
+
+   Don't compile this unless required. Some compilers (at least Borland
+   C++ 3.0) have to link with math libraries due to the use of floats.
+
+   Based on vsscanf.c and input.c from emx 0.8f library source,
+   Copyright (c) 1990-1992 by Eberhard Mattes, who has kindly agreed to
+   its inclusion in PDCurses. */
+
+#define WHITE(x) ((x) == ' ' || (x) == '\t' || (x) == '\n')
+
+#define NEXT(x) \
+        do { \
+            x = *buf++; \
+            if (!x) \
+               return (count ? count : EOF); \
+            ++chars; \
+           } while (0)
+
+#define UNGETC() \
+        do { \
+            --buf; --chars; \
+           } while (0)
+
+static int _pdc_vsscanf(const char *buf, const char *fmt, va_list arg_ptr)
+{
+    int count, chars, c, width, radix, d, i;
+    int *int_ptr;
+    long *long_ptr;
+    short *short_ptr;
+    char *char_ptr;
+    unsigned char f;
+    char neg, assign, ok, size;
+    long n;
+    char map[256], end;
+    double dx, dd, *dbl_ptr;
+    float *flt_ptr;
+    int exp;
+    char eneg;
+
+    count = 0;
+    chars = 0;
+    c = 0;
+    while ((f = *fmt) != 0)
+    {
+        if (WHITE(f))
+        {
+            do
+            {
+                ++fmt;
+                f = *fmt;
+            }
+            while (WHITE(f));
+            do
+            {
+                c = *buf++;
+                if (!c)
+                {
+                    if (!f || count)
+                        return count;
+                    else
+                        return EOF;
+                } else
+                    ++chars;
+            }
+            while (WHITE(c));
+            UNGETC();
+        } else if (f != '%')
+        {
+            NEXT(c);
+            if (c != f)
+                return count;
+            ++fmt;
+        } else
+        {
+            assign = TRUE;
+            width = INT_MAX;
+            char_ptr = NULL;
+            ++fmt;
+            if (*fmt == '*')
+            {
+                assign = FALSE;
+                ++fmt;
+            }
+            if (isdigit(*fmt))
+            {
+                width = 0;
+                while (isdigit(*fmt))
+                    width = width * 10 + (*fmt++ - '0');
+                if (!width)
+                    width = INT_MAX;
+            }
+            size = 0;
+            if (*fmt == 'h' || *fmt == 'l')
+                size = *fmt++;
+            f = *fmt;
+            switch (f)
+            {
+            case 'c':
+                if (width == INT_MAX)
+                    width = 1;
+                if (assign)
+                    char_ptr = va_arg(arg_ptr, char *);
+                while (width > 0)
+                {
+                    --width;
+                    NEXT(c);
+                    if (assign)
+                    {
+                        *char_ptr++ = (char) c;
+                        ++count;
+                    }
+                }
+                break;
+            case '[':
+                memset(map, 0, 256);
+                end = 0;
+                ++fmt;
+                if (*fmt == '^')
+                {
+                    ++fmt;
+                    end = 1;
+                }
+                i = 0;
+                for (;;)
+                {
+                    f = (unsigned char) *fmt;
+                    switch (f)
+                    {
+                    case 0:
+                        /* avoid skipping past 0 */
+                        --fmt;
+                        NEXT(c);
+                        goto string;
+                    case ']':
+                        if (i > 0)
+                        {
+                            NEXT(c);
+                            goto string;
+                        }
+                        /* no break */
+                    default:
+                        if (fmt[1] == '-' && fmt[2]
+                            && f < (unsigned char)fmt[2])
+                        {
+                            memset(map + f, 1, (unsigned char)fmt[2] - f);
+                            fmt += 2;
+                        }
+                        else
+                            map[f] = 1;
+                        break;
+                    }
+                    ++fmt;
+                    ++i;
+                }
+            case 's':
+                memset(map, 0, 256);
+                map[' '] = 1;
+                map['\n'] = 1;
+                map['\r'] = 1;
+                map['\t'] = 1;
+                end = 1;
+                do
+                {
+                    NEXT(c);
+                }
+                while (WHITE(c));
+            string:
+                if (assign)
+                    char_ptr = va_arg(arg_ptr, char *);
+                while (width > 0 && map[(unsigned char) c] != end)
+                {
+                    --width;
+                    if (assign)
+                        *char_ptr++ = (char) c;
+                    c = *buf++;
+                    if (!c)
+                        break;
+                    else
+                        ++chars;
+                }
+                if (assign)
+                {
+                    *char_ptr = 0;
+                    ++count;
+                }
+                if (!c)
+                    return count;
+                else
+                    UNGETC();
+                break;
+            case 'f':
+            case 'e':
+            case 'E':
+            case 'g':
+            case 'G':
+                neg = ok = FALSE;
+                dx = 0.0;
+                do
+                {
+                    NEXT(c);
+                }
+                while (WHITE(c));
+                if (c == '+')
+                {
+                    NEXT(c);
+                    --width;
+                } else if (c == '-')
+                {
+                    neg = TRUE;
+                    NEXT(c);
+                    --width;
+                }
+                while (width > 0 && isdigit(c))
+                {
+                    --width;
+                    dx = dx * 10.0 + (double) (c - '0');
+                    ok = TRUE;
+                    c = *buf++;
+                    if (!c)
+                        break;
+                    else
+                        ++chars;
+                }
+                if (width > 0 && c == '.')
+                {
+                    --width;
+                    dd = 10.0;
+                    NEXT(c);
+                    while (width > 0 && isdigit(c))
+                    {
+                        --width;
+                        dx += (double) (c - '0') / dd;
+                        dd *= 10.0;
+                        ok = TRUE;
+                        c = *buf++;
+                        if (!c)
+                            break;
+                        else
+                            ++chars;
+                    }
+                }
+                if (!ok)
+                    return count;
+                if (width > 0 && (c == 'e' || c == 'E'))
+                {
+                    eneg = FALSE;
+                    exp = 0;
+                    NEXT(c);
+                    --width;
+                    if (width > 0 && c == '+')
+                    {
+                        NEXT(c);
+                        --width;
+                    } else if (width > 0 && c == '-')
+                    {
+                        eneg = TRUE;
+                        NEXT(c);
+                        --width;
+                    }
+                    if (!(width > 0 && isdigit(c)))
+                    {
+                        UNGETC();
+                        return count;
+                    }
+                    while (width > 0 && isdigit(c))
+                    {
+                        --width;
+                        exp = exp * 10 + (c - '0');
+                        c = *buf++;
+                        if (!c)
+                            break;
+                        else
+                            ++chars;
+                    }
+                    if (eneg)
+                        exp = -exp;
+                    while (exp > 0)
+                    {
+                        dx *= 10.0;
+                        --exp;
+                    }
+                    while (exp < 0)
+                    {
+                        dx /= 10.0;
+                        ++exp;
+                    }
+                }
+                if (assign)
+                {
+                    if (neg)
+                        dx = -dx;
+                    if (size == 'l')
+                    {
+                        dbl_ptr = va_arg(arg_ptr, double *);
+                        *dbl_ptr = dx;
+                    }
+                    else
+                    {
+                        flt_ptr = va_arg(arg_ptr, float *);
+                        *flt_ptr = (float)dx;
+                    }
+                    ++count;
+                }
+                if (!c)
+                    return count;
+                else
+                    UNGETC();
+                break;
+            case 'i':
+                neg = FALSE;
+                radix = 10;
+                do
+                {
+                    NEXT(c);
+                }
+                while (WHITE(c));
+                if (!(width > 0 && c == '0'))
+                    goto scan_complete_number;
+                NEXT(c);
+                --width;
+                if (width > 0 && (c == 'x' || c == 'X'))
+                {
+                    NEXT(c);
+                    radix = 16;
+                    --width;
+                }
+                else if (width > 0 && (c >= '0' && c <= '7'))
+                    radix = 8;
+                goto scan_unsigned_number;
+            case 'd':
+            case 'u':
+            case 'o':
+            case 'x':
+            case 'X':
+                do
+                {
+                    NEXT(c);
+                }
+                while (WHITE(c));
+                switch (f)
+                {
+                case 'o':
+                    radix = 8;
+                    break;
+                case 'x':
+                case 'X':
+                    radix = 16;
+                    break;
+                default:
+                    radix = 10;
+                    break;
+                }
+            scan_complete_number:
+                neg = FALSE;
+                if (width > 0 && c == '+')
+                {
+                    NEXT(c);
+                    --width;
+                }
+                else if (width > 0 && c == '-' && radix == 10)
+                {
+                    neg = TRUE;
+                    NEXT(c);
+                    --width;
+                }
+            scan_unsigned_number:
+                n = 0;
+                ok = FALSE;
+                while (width > 0)
+                {
+                    --width;
+                    if (isdigit(c))
+                        d = c - '0';
+                    else if (isupper(c))
+                        d = c - 'A' + 10;
+                    else if (islower(c))
+                        d = c - 'a' + 10;
+                    else
+                        break;
+                    if (d < 0 || d >= radix)
+                        break;
+                    ok = TRUE;
+                    n = n * radix + d;
+                    c = *buf++;
+                    if (!c)
+                        break;
+                    else
+                        ++chars;
+                }
+                if (!ok)
+                    return count;
+                if (assign)
+                {
+                    if (neg)
+                        n = -n;
+                    switch (size)
+                    {
+                    case 'h':
+                        short_ptr = va_arg(arg_ptr, short *);
+                        *short_ptr = (short) n;
+                        break;
+                    case 'l':
+                        long_ptr = va_arg(arg_ptr, long *);
+                        *long_ptr = (long) n;
+                        break;
+                    default:
+                        int_ptr = va_arg(arg_ptr, int *);
+                        *int_ptr = (int) n;
+                    }
+                    ++count;
+                }
+                if (!c)
+                    return count;
+                else
+                    UNGETC();
+                break;
+            case 'n':
+                if (assign)
+                {
+                    int_ptr = va_arg(arg_ptr, int *);
+                    *int_ptr = chars;
+                    ++count;
+                }
+                break;
+            default:
+                if (!f) /* % at end of string */
+                    return count;
+                NEXT(c);
+                if (c != f)
+                    return count;
+                break;
+            }
+            ++fmt;
+        }
+    }
+    return count;
+}
+#endif /* HAVE_VSSCANF */
diff --git a/lib/PDCursesMod/pdcurses/scr_dump.c b/lib/PDCursesMod/pdcurses/scr_dump.c
new file mode 100644
index 00000000000..1f413f1a2e2
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/scr_dump.c
@@ -0,0 +1,211 @@
+/* PDCurses */
+
+#include <curspriv.h>
+
+/*man-start**************************************************************
+
+scr_dump
+--------
+
+### Synopsis
+
+    int putwin(WINDOW *win, FILE *filep);
+    WINDOW *getwin(FILE *filep);
+    int scr_dump(const char *filename);
+    int scr_init(const char *filename);
+    int scr_restore(const char *filename);
+    int scr_set(const char *filename);
+
+### Description
+
+   getwin() reads window-related data previously stored in a file by
+   putwin(). It then creates and initialises a new window using that
+   data.
+
+   putwin() writes all data associated with a window into a file, using
+   an unspecified format. This information can be retrieved later using
+   getwin().
+
+   scr_dump() writes the current contents of the virtual screen to the
+   file named by filename in an unspecified format.
+
+   scr_restore() function sets the virtual screen to the contents of the
+   file named by filename, which must have been written using
+   scr_dump(). The next refresh operation restores the screen to the way
+   it looked in the dump file.
+
+   In PDCurses, scr_init() does nothing, and scr_set() is a synonym for
+   scr_restore(). Also, scr_dump() and scr_restore() save and load from
+   curscr. This differs from some other implementations, where
+   scr_init() works with curscr, and scr_restore() works with newscr;
+   but the effect should be the same. (PDCurses has no newscr.)
+
+### Return Value
+
+   On successful completion, getwin() returns a pointer to the window it
+   created. Otherwise, it returns a null pointer. Other functions return
+   OK or ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    putwin                      Y       Y       Y
+    getwin                      Y       Y       Y
+    scr_dump                    Y       Y       -
+    scr_init                    Y       Y       -
+    scr_restore                 Y       Y       -
+    scr_set                     Y       Y       -
+
+**man-end****************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+
+#define DUMPVER 1   /* Should be updated whenever the WINDOW struct is
+                       changed */
+
+int putwin(WINDOW *win, FILE *filep)
+{
+    static const char *marker = "PDC";
+    static const unsigned char version = DUMPVER;
+
+    PDC_LOG(("putwin() - called\n"));
+
+    /* write the marker and the WINDOW struct */
+
+    if (filep && fwrite(marker, strlen(marker), 1, filep)
+              && fwrite(&version, 1, 1, filep)
+              && fwrite(win, sizeof(WINDOW), 1, filep))
+    {
+        int i;
+
+        /* write each line */
+
+        for (i = 0; i < win->_maxy && win->_y[i]; i++)
+            if (!fwrite(win->_y[i], win->_maxx * sizeof(chtype), 1, filep))
+                return ERR;
+
+        return OK;
+    }
+
+    return ERR;
+}
+
+WINDOW *getwin(FILE *filep)
+{
+    WINDOW *win;
+    char marker[4];
+    int i, nlines, ncols;
+
+    PDC_LOG(("getwin() - called\n"));
+
+    win = malloc(sizeof(WINDOW));
+    if (!win)
+        return (WINDOW *)NULL;
+
+    /* check for the marker, and load the WINDOW struct */
+
+    if (!filep || !fread(marker, 4, 1, filep) || strncmp(marker, "PDC", 3)
+        || marker[3] != DUMPVER || !fread(win, sizeof(WINDOW), 1, filep))
+    {
+        free(win);
+        return (WINDOW *)NULL;
+    }
+
+    nlines = win->_maxy;
+    ncols = win->_maxx;
+
+    /* allocate the line pointer array */
+
+    win->_y = malloc(nlines * sizeof(chtype *));
+    if (!win->_y)
+    {
+        free(win);
+        return (WINDOW *)NULL;
+    }
+
+    /* allocate the minchng and maxchng arrays */
+
+    win->_firstch = malloc(nlines * sizeof(int) * 2);
+    if (!win->_firstch)
+    {
+        free(win->_y);
+        free(win);
+        return (WINDOW *)NULL;
+    }
+
+    win->_lastch = win->_firstch + nlines;
+
+    /* allocate the lines */
+
+    win = PDC_makelines(win);
+    if (!win)
+        return (WINDOW *)NULL;
+
+    /* read them */
+
+    for (i = 0; i < nlines; i++)
+    {
+        if (!fread(win->_y[i], ncols * sizeof(chtype), 1, filep))
+        {
+            delwin(win);
+            return (WINDOW *)NULL;
+        }
+    }
+
+    touchwin(win);
+
+    return win;
+}
+
+int scr_dump(const char *filename)
+{
+    FILE *filep;
+
+    PDC_LOG(("scr_dump() - called: filename %s\n", filename));
+
+    if (filename && (filep = fopen(filename, "wb")) != NULL)
+    {
+        int result = putwin(curscr, filep);
+        fclose(filep);
+        return result;
+    }
+
+    return ERR;
+}
+
+int scr_init(const char *filename)
+{
+    PDC_LOG(("scr_init() - called: filename %s\n", filename));
+
+    INTENTIONALLY_UNUSED_PARAMETER( filename);
+    return OK;
+}
+
+int scr_restore(const char *filename)
+{
+    FILE *filep;
+
+    PDC_LOG(("scr_restore() - called: filename %s\n", filename));
+
+    if (filename && (filep = fopen(filename, "rb")) != NULL)
+    {
+        WINDOW *replacement = getwin(filep);
+        fclose(filep);
+
+        if (replacement)
+        {
+            int result = overwrite(replacement, curscr);
+            delwin(replacement);
+            return result;
+        }
+    }
+
+    return ERR;
+}
+
+int scr_set(const char *filename)
+{
+    PDC_LOG(("scr_set() - called: filename %s\n", filename));
+
+    return scr_restore(filename);
+}
diff --git a/lib/PDCursesMod/pdcurses/scroll.c b/lib/PDCursesMod/pdcurses/scroll.c
new file mode 100644
index 00000000000..87b07dcd0c8
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/scroll.c
@@ -0,0 +1,103 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+scroll
+------
+
+### Synopsis
+
+    int scroll(WINDOW *win);
+    int scrl(int n);
+    int wscrl(WINDOW *win, int n);
+
+### Description
+
+   scroll() causes the window to scroll up one line. This involves
+   moving the lines in the window data strcture.
+
+   With a positive n, scrl() and wscrl() scroll the window up n lines
+   (line i + n becomes i); otherwise they scroll the window down n
+   lines.
+
+   For these functions to work, scrolling must be enabled via
+   scrollok(). Note also that scrolling is not allowed if the supplied
+   window is a pad.
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    scroll                      Y       Y       Y
+    scrl                        Y       Y       Y
+    wscrl                       Y       Y       Y
+
+**man-end****************************************************************/
+
+int wscrl(WINDOW *win, int n)
+{
+    int i, l, dir, start, end;
+    chtype blank, *temp;
+
+    /* Check if window scrolls. Valid for window AND pad */
+
+    assert( win);
+    if (!win || !win->_scroll || !n)
+        return ERR;
+
+    blank = win->_bkgd;
+
+    if (n > 0)
+    {
+        start = win->_tmarg;
+        end = win->_bmarg;
+        dir = 1;
+    }
+    else
+    {
+        start = win->_bmarg;
+        end = win->_tmarg;
+        dir = -1;
+    }
+
+    for (l = 0; l < (n * dir); l++)
+    {
+        temp = win->_y[start];
+
+        /* re-arrange line pointers */
+
+        for (i = start; i != end; i += dir)
+            win->_y[i] = win->_y[i + dir];
+
+        win->_y[end] = temp;
+
+        /* make a blank line */
+
+        for (i = 0; i < win->_maxx; i++)
+            *temp++ = blank;
+    }
+
+    touchline(win, win->_tmarg, win->_bmarg - win->_tmarg + 1);
+
+    PDC_sync(win);
+    return OK;
+}
+
+int scrl(int n)
+{
+    PDC_LOG(("scrl() - called\n"));
+
+    return wscrl(stdscr, n);
+}
+
+int scroll(WINDOW *win)
+{
+    PDC_LOG(("scroll() - called\n"));
+
+    return wscrl(win, 1);
+}
diff --git a/lib/PDCursesMod/pdcurses/slk.c b/lib/PDCursesMod/pdcurses/slk.c
new file mode 100644
index 00000000000..cfc48c6df8d
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/slk.c
@@ -0,0 +1,631 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+slk
+---
+
+### Synopsis
+
+    int slk_init(int fmt);
+    int slk_set(int labnum, const char *label, int justify);
+    int slk_refresh(void);
+    int slk_noutrefresh(void);
+    char *slk_label(int labnum);
+    int slk_clear(void);
+    int slk_restore(void);
+    int slk_touch(void);
+    int slk_attron(const chtype attrs);
+    int slk_attr_on(const attr_t attrs, void *opts);
+    int slk_attrset(const chtype attrs);
+    int slk_attr_set(const attr_t attrs, short color_pair, void *opts);
+    int slk_attroff(const chtype attrs);
+    int slk_attr_off(const attr_t attrs, void *opts);
+    int slk_color(short color_pair);
+
+    int slk_wset(int labnum, const wchar_t *label, int justify);
+
+    int PDC_mouse_in_slk(int y, int x);
+    void PDC_slk_free(void);
+    void PDC_slk_initialize(void);
+
+    wchar_t *slk_wlabel(int labnum)
+
+### Description
+
+   These functions manipulate a window that contain Soft Label Keys
+   (SLK). To use the SLK functions, a call to slk_init() must be made
+   BEFORE initscr() or newterm(). slk_init() removes 1 or 2 lines from
+   the useable screen, depending on the format selected.
+
+   The line(s) removed from the screen are used as a separate window, in
+   which SLKs are displayed.
+
+   slk_init() requires a single parameter which describes the format of
+   the SLKs as follows:
+
+   0       3-2-3 format
+   1       4-4 format
+   2       4-4-4 format (ncurses extension)
+   3       4-4-4 format with index line (ncurses extension)
+   2 lines used
+   55      5-5 format (pdcurses format)
+
+   In PDCurses,  one can alternatively set fmt as a series of hex
+   digits specifying the format.  For example,  0x414 would result
+   in 4-1-4 format; 0x21b3 would result in 2-1-11-3 format;  and
+   so on.  Also,  negating fmt results in the index line being added.
+
+   Also,  in PDCurses,  one can call slk_init() at any time
+   _after_ initscr(),  to reset the label format.  If you do this,
+   you'll need to reset the label text and call slk_refresh().  However,
+   you can't toggle the index line or turn SLK on or off after initscr()
+   has been called.  Doing so would add/remove a line or two from the
+   useable screen,  which would be difficult to handle correctly.
+
+   slk_refresh(), slk_noutrefresh() and slk_touch() are analogous to
+   refresh(), noutrefresh() and touch().
+
+### Return Value
+
+   All functions return OK on success and ERR on error.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    slk_init                    Y       Y       Y
+    slk_set                     Y       Y       Y
+    slk_refresh                 Y       Y       Y
+    slk_noutrefresh             Y       Y       Y
+    slk_label                   Y       Y       Y
+    slk_clear                   Y       Y       Y
+    slk_restore                 Y       Y       Y
+    slk_touch                   Y       Y       Y
+    slk_attron                  Y       Y       Y
+    slk_attrset                 Y       Y       Y
+    slk_attroff                 Y       Y       Y
+    slk_attr_on                 Y       Y       Y
+    slk_attr_set                Y       Y       Y
+    slk_attr_off                Y       Y       Y
+    slk_wset                    Y       Y       Y
+    PDC_mouse_in_slk            -       -       -
+    PDC_slk_free                -       -       -
+    PDC_slk_initialize          -       -       -
+    slk_wlabel                  -       -       -
+
+**man-end****************************************************************/
+
+#include <stdlib.h>
+
+static int label_length = 0;
+static int labels = 0;
+static int label_fmt = 0;
+static int label_line = 0;
+static bool hidden = FALSE;
+
+#define MAX_LABEL_LENGTH 32
+
+static struct SLK {
+    chtype label[MAX_LABEL_LENGTH];
+    int len;
+    int format;
+    int start_col;
+} *slk = (struct SLK *)NULL;
+
+/* See comments above on this function.   */
+
+int slk_init(int fmt)
+{
+    int i;
+
+    PDC_LOG(("slk_init() - called\n"));
+
+    switch (fmt)
+    {
+    case 0:  /* 3 - 2 - 3 */
+        label_fmt = 0x323;
+        break;
+
+    case 1:   /* 4 - 4 */
+        label_fmt = 0x44;
+        break;
+
+    case 2:   /* 4 4 4 */
+        label_fmt = 0x444;
+        break;
+
+    case 3:   /* 4 4 4  with index */
+        label_fmt = -0x444;
+        break;
+
+    case 55:  /* 5 - 5 */
+        label_fmt = 0x55;
+        break;
+
+    default:
+        label_fmt = fmt;
+        break;
+    }
+
+    labels = 0;
+    for( i = abs( label_fmt); i; i /= 16)
+       labels += i % 16;
+
+    PDC_LOG(("slk_init: fmt %d, %d labels, %p\n",
+               fmt, labels, slk));
+    if( slk)
+        free( slk);
+    slk = calloc(labels, sizeof(struct SLK));
+    PDC_LOG(( "New slk: %p; SP = %p\n", slk, SP));
+
+    if (!slk)
+        labels = 0;
+    if( SP)
+        {
+        if( SP->slk_winptr)
+            wclear( SP->slk_winptr);
+        PDC_slk_initialize( );
+        }
+
+    return slk ? OK : ERR;
+}
+
+/* draw a single button */
+
+static void _drawone(int num)
+{
+    int i, col, slen;
+
+    if (hidden)
+        return;
+
+    slen = slk[num].len;
+
+    switch (slk[num].format)
+    {
+    case 0:  /* LEFT */
+        col = 0;
+        break;
+
+    case 1:  /* CENTER */
+        col = (label_length - slen) / 2;
+
+        if (col + slen > label_length)
+            --col;
+        break;
+
+    default:  /* RIGHT */
+        col = label_length - slen;
+    }
+
+    if( col < 0)  /* Ensure start of label is visible */
+        col = 0;
+    wmove(SP->slk_winptr, label_line, slk[num].start_col);
+
+    for (i = 0; i < label_length; ++i)
+        waddch(SP->slk_winptr, (i >= col && i < (col + slen)) ?
+               slk[num].label[i - col] : ' ');
+}
+
+/* redraw each button */
+
+static void _redraw(void)
+{
+    int i;
+
+    if( !hidden)
+    {
+        for (i = 0; i < labels; ++i)
+            _drawone(i);
+        if (label_fmt < 0)
+        {
+            const chtype save_attr = SP->slk_winptr->_attrs;
+
+            wattrset(SP->slk_winptr, A_NORMAL);
+            wmove(SP->slk_winptr, 0, 0);
+            whline(SP->slk_winptr, 0, COLS);
+
+            for (i = 0; i < labels; i++)
+                mvwprintw(SP->slk_winptr, 0, slk[i].start_col, "F%d", i + 1);
+
+            SP->slk_winptr->_attrs = save_attr;
+        }
+    }
+}
+
+/* slk_set() Used to set a slk label to a string.
+
+   labnum  = 1 - 8 (or 10) (number of the label)
+   label   = string (8 or 7 bytes total), or NULL
+   justify = 0 : left, 1 : center, 2 : right  */
+
+int slk_set(int labnum, const char *label, int justify)
+{
+#ifdef PDC_WIDE
+    wchar_t wlabel[MAX_LABEL_LENGTH];
+
+    PDC_mbstowcs(wlabel, label, MAX_LABEL_LENGTH - 1);
+    return slk_wset(labnum, wlabel, justify);
+#else
+    PDC_LOG(("slk_set() - called\n"));
+
+    if (labnum < 1 || labnum > labels || justify < 0 || justify > 2)
+        return ERR;
+
+    labnum--;
+
+    if (!label || !(*label))
+    {
+        /* Clear the label */
+
+        *slk[labnum].label = 0;
+        slk[labnum].format = 0;
+        slk[labnum].len = 0;
+    }
+    else
+    {
+        int i;
+
+        /* Skip leading spaces */
+
+        while( *label == ' ')
+            label++;
+
+        /* Copy it */
+
+        for (i = 0; label[i] && i < MAX_LABEL_LENGTH - 1; i++)
+            slk[labnum].label[i] = label[i];
+
+        /* Drop trailing spaces */
+
+        while( i && label[i - 1] == ' ')
+            i--;
+
+        slk[labnum].label[i] = 0;
+        slk[labnum].format = justify;
+        slk[labnum].len = i;
+    }
+
+    _drawone(labnum);
+
+    return OK;
+#endif
+}
+
+int slk_refresh(void)
+{
+    PDC_LOG(("slk_refresh() - called\n"));
+
+    return (slk_noutrefresh() == ERR) ? ERR : doupdate();
+}
+
+int slk_noutrefresh(void)
+{
+    PDC_LOG(("slk_noutrefresh() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    return wnoutrefresh(SP->slk_winptr);
+}
+
+char *slk_label(int labnum)
+{
+    static char temp[MAX_LABEL_LENGTH + 1];
+#ifdef PDC_WIDE
+    wchar_t *wtemp = slk_wlabel(labnum);
+
+    PDC_wcstombs(temp, wtemp, MAX_LABEL_LENGTH);
+#else
+    chtype *p;
+    int i;
+
+    PDC_LOG(("slk_label() - called\n"));
+
+    if (labnum < 1 || labnum > labels)
+        return (char *)0;
+
+    for (i = 0, p = slk[labnum - 1].label; *p; i++)
+        temp[i] = (char)*p++;
+
+    temp[i] = '\0';
+#endif
+    return temp;
+}
+
+int slk_clear(void)
+{
+    PDC_LOG(("slk_clear() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    hidden = TRUE;
+    werase(SP->slk_winptr);
+    return wrefresh(SP->slk_winptr);
+}
+
+int slk_restore(void)
+{
+    PDC_LOG(("slk_restore() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    hidden = FALSE;
+    _redraw();
+    return wrefresh(SP->slk_winptr);
+}
+
+int slk_touch(void)
+{
+    PDC_LOG(("slk_touch() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    return touchwin(SP->slk_winptr);
+}
+
+int slk_attron(const chtype attrs)
+{
+    int rc;
+
+    PDC_LOG(("slk_attron() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    rc = wattron(SP->slk_winptr, attrs);
+    _redraw();
+
+    return rc;
+}
+
+int slk_attr_on(const attr_t attrs, void *opts)
+{
+    PDC_LOG(("slk_attr_on() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    return slk_attron(attrs);
+}
+
+int slk_attroff(const chtype attrs)
+{
+    int rc;
+
+    PDC_LOG(("slk_attroff() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    rc = wattroff(SP->slk_winptr, attrs);
+    _redraw();
+
+    return rc;
+}
+
+int slk_attr_off(const attr_t attrs, void *opts)
+{
+    PDC_LOG(("slk_attr_off() - called\n"));
+
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    return slk_attroff(attrs);
+}
+
+int slk_attrset(const chtype attrs)
+{
+    int rc;
+
+    PDC_LOG(("slk_attrset() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    rc = wattrset(SP->slk_winptr, attrs);
+    _redraw();
+
+    return rc;
+}
+
+int slk_color(short color_pair)
+{
+    int rc;
+
+    PDC_LOG(("slk_color() - called\n"));
+
+    assert( SP);
+    if (!SP)
+        return ERR;
+
+    rc = wcolor_set(SP->slk_winptr, color_pair, NULL);
+    _redraw();
+
+    return rc;
+}
+
+int slk_attr_set(const attr_t attrs, short color_pair, void *opts)
+{
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    PDC_LOG(("slk_attr_set() - called\n"));
+
+    return slk_attrset(attrs | COLOR_PAIR(color_pair));
+}
+
+static void _slk_calc(void)
+{
+    int i, j, idx, remaining_space;
+    int n_groups = 0, group_size[10];
+
+    label_length = COLS / labels;
+    if (label_length > MAX_LABEL_LENGTH)
+        label_length = MAX_LABEL_LENGTH;
+    remaining_space = COLS - label_length * labels + 1;
+    for( i = abs( label_fmt); i; i /= 16)
+        group_size[n_groups++] = i % 16;
+               /* We really want at least two spaces between groups: */
+    while( label_length > 1 && remaining_space < n_groups - 1)
+    {
+        label_length--;
+        remaining_space += labels;
+    }
+
+    for( i = idx = 0; i < n_groups; i++)
+        for( j = 0; j < group_size[i]; j++, idx++)
+            slk[idx].start_col = label_length * idx
+                     + (i ? (i * remaining_space) / (n_groups - 1) : 0);
+
+    if( label_length)
+       --label_length;
+
+    /* make sure labels are all in window */
+
+    _redraw();
+}
+
+void PDC_slk_initialize(void)
+{
+    if (slk)
+    {
+        assert( SP);
+        if (label_fmt < 0)
+        {
+            SP->slklines = 2;
+            label_line = 1;
+        }
+        else
+            SP->slklines = 1;
+
+        if (!SP->slk_winptr)
+        {
+            SP->slk_winptr = newwin(SP->slklines, COLS,
+                                    LINES - SP->slklines, 0);
+            if (!SP->slk_winptr)
+                return;
+
+            wattrset(SP->slk_winptr, A_REVERSE);
+        }
+
+        _slk_calc();
+
+        touchwin(SP->slk_winptr);
+    }
+}
+
+void PDC_slk_free(void)
+{
+    if (slk)
+    {
+        if (SP->slk_winptr)
+        {
+            delwin(SP->slk_winptr);
+            SP->slk_winptr = (WINDOW *)NULL;
+        }
+
+        free(slk);
+        slk = (struct SLK *)NULL;
+
+        label_length = 0;
+        labels = 0;
+        label_fmt = 0;
+        label_line = 0;
+        hidden = FALSE;
+    }
+}
+
+int PDC_mouse_in_slk(int y, int x)
+{
+    int i;
+
+    PDC_LOG(("PDC_mouse_in_slk() - called: y->%d x->%d\n", y, x));
+
+    /* If the line on which the mouse was clicked is NOT the last line
+       of the screen, or the SLKs are hidden,  we are not interested in it. */
+
+    assert( SP);
+    if (!slk || hidden || !SP->slk_winptr
+                        || (y != SP->slk_winptr->_begy + label_line))
+        return 0;
+
+    for (i = 0; i < labels; i++)
+        if (x >= slk[i].start_col && x < (slk[i].start_col + label_length))
+            return i + 1;
+
+    return 0;
+}
+
+#ifdef PDC_WIDE
+int slk_wset(int labnum, const wchar_t *label, int justify)
+{
+    PDC_LOG(("slk_wset() - called\n"));
+
+    if (labnum < 1 || labnum > labels || justify < 0 || justify > 2)
+        return ERR;
+
+    labnum--;
+
+    if (!label || !(*label))
+    {
+        /* Clear the label */
+
+        *slk[labnum].label = 0;
+        slk[labnum].format = 0;
+        slk[labnum].len = 0;
+    }
+    else
+    {
+        int i;
+
+        /* Skip leading spaces */
+
+        while( *label == L' ')
+            label++;
+
+        /* Copy it */
+
+        for (i = 0; label[i] && i < MAX_LABEL_LENGTH - 1; i++)
+            slk[labnum].label[i] = label[i];
+
+        /* Drop trailing spaces */
+
+        while( i && label[i - 1] == L' ')
+            i--;
+
+        slk[labnum].label[i] = 0;
+        slk[labnum].format = justify;
+        slk[labnum].len = i;
+    }
+
+    _drawone(labnum);
+
+    return OK;
+}
+
+wchar_t *slk_wlabel(int labnum)
+{
+    static wchar_t temp[MAX_LABEL_LENGTH + 1];
+    chtype *p;
+    int i;
+
+    PDC_LOG(("slk_wlabel() - called\n"));
+
+    if (labnum < 1 || labnum > labels)
+        return (wchar_t *)0;
+
+    for (i = 0, p = slk[labnum - 1].label; *p; i++)
+        temp[i] = (wchar_t)*p++;
+
+    temp[i] = '\0';
+
+    return temp;
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/termattr.c b/lib/PDCursesMod/pdcurses/termattr.c
new file mode 100644
index 00000000000..20e7ae534bc
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/termattr.c
@@ -0,0 +1,176 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+termattr
+--------
+
+### Synopsis
+
+    int baudrate(void);
+    char erasechar(void);
+    bool has_ic(void);
+    bool has_il(void);
+    char killchar(void);
+    char *longname(void);
+    chtype termattrs(void);
+    attr_t term_attrs(void);
+    char *termname(void);
+
+    int erasewchar(wchar_t *ch);
+    int killwchar(wchar_t *ch);
+
+    char wordchar(void);
+
+### Description
+
+   baudrate() is supposed to return the output speed of the terminal. In
+   PDCurses, it simply returns INT_MAX.
+
+   has_ic and has_il() return TRUE. These functions have meaning in some
+   other implementations of curses.
+
+   erasechar() and killchar() return ^H and ^U, respectively -- the
+   ERASE and KILL characters. In other curses implementations, these may
+   vary by terminal type. erasewchar() and killwchar() are the wide-
+   character versions; they take a pointer to a location in which to
+   store the character, and return OK or ERR.
+
+   longname() returns a pointer to a static area containing a verbose
+   description of the current terminal. The maximum length of the string
+   is 128 characters. It is defined only after the call to initscr() or
+   newterm().
+
+   termname() returns a pointer to a static area containing a short
+   description of the current terminal (14 characters).
+
+   termattrs() returns a logical OR of all video attributes supported by
+   the terminal.
+
+   wordchar() is a PDCurses extension of the concept behind the
+   functions erasechar() and killchar(), returning the "delete word"
+   character, ^W.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    baudrate                    Y       Y       Y
+    erasechar                   Y       Y       Y
+    has_ic                      Y       Y       Y
+    has_il                      Y       Y       Y
+    killchar                    Y       Y       Y
+    longname                    Y       Y       Y
+    termattrs                   Y       Y       Y
+    termname                    Y       Y       Y
+    erasewchar                  Y       Y       Y
+    killwchar                   Y       Y       Y
+    term_attrs                  Y       Y       Y
+    wordchar                    -       -       -
+
+**man-end****************************************************************/
+
+#include <string.h>
+#include <limits.h>
+
+int baudrate(void)
+{
+    PDC_LOG(("baudrate() - called\n"));
+
+    return INT_MAX;
+}
+
+char erasechar(void)
+{
+    PDC_LOG(("erasechar() - called\n"));
+
+    return _ECHAR;      /* character delete char (^H) */
+}
+
+bool has_ic(void)
+{
+    PDC_LOG(("has_ic() - called\n"));
+
+    return TRUE;
+}
+
+bool has_il(void)
+{
+    PDC_LOG(("has_il() - called\n"));
+
+    return TRUE;
+}
+
+char killchar(void)
+{
+    PDC_LOG(("killchar() - called\n"));
+
+    return _DLCHAR;     /* line delete char (^U) */
+}
+
+char *longname(void)
+{
+    PDC_LOG(("longname() - called\n"));
+
+    sprintf(ttytype, "pdcurses|PDCurses for %s", PDC_sysname());
+    return ttytype + 9; /* skip "pdcurses|" */
+}
+
+chtype termattrs(void)
+{
+    PDC_LOG(("termattrs() - called\n"));
+
+    return SP ? SP->termattrs : (chtype)0;
+}
+
+attr_t term_attrs(void)
+{
+    PDC_LOG(("term_attrs() - called\n"));
+
+    return SP ? SP->termattrs : (attr_t)0;
+}
+
+char *termname(void)
+{
+    static char _termname[14] = "pdcurses";
+
+    PDC_LOG(("termname() - called\n"));
+
+    return _termname;
+}
+
+char wordchar(void)
+{
+    PDC_LOG(("wordchar() - called\n"));
+
+    return _DWCHAR;         /* word delete char */
+}
+
+#ifdef PDC_WIDE
+int erasewchar(wchar_t *ch)
+{
+    PDC_LOG(("erasewchar() - called\n"));
+
+    assert( ch);
+    if (!ch)
+        return ERR;
+
+    *ch = (wchar_t)_ECHAR;
+
+    return OK;
+}
+
+int killwchar(wchar_t *ch)
+{
+    PDC_LOG(("killwchar() - called\n"));
+
+    assert( ch);
+    if (!ch)
+        return ERR;
+
+    *ch = (wchar_t)_DLCHAR;
+
+    return OK;
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/touch.c b/lib/PDCursesMod/pdcurses/touch.c
new file mode 100644
index 00000000000..56cfa605f74
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/touch.c
@@ -0,0 +1,208 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+touch
+-----
+
+### Synopsis
+
+    int touchwin(WINDOW *win);
+    int touchline(WINDOW *win, int start, int count);
+    int untouchwin(WINDOW *win);
+    int wtouchln(WINDOW *win, int y, int n, int changed);
+    bool is_linetouched(WINDOW *win, int line);
+    bool is_wintouched(WINDOW *win);
+
+    int touchoverlap(const WINDOW *win1, WINDOW *win2);
+
+### Description
+
+   touchwin() and touchline() throw away all information about which
+   parts of the window have been touched, pretending that the entire
+   window has been drawn on. This is sometimes necessary when using
+   overlapping windows, since a change to one window will affect the
+   other window, but the records of which lines have been changed in the
+   other window will not reflect the change.
+
+   untouchwin() marks all lines in the window as unchanged since the
+   last call to wrefresh().
+
+   wtouchln() makes n lines in the window, starting at line y, look as
+   if they have (changed == 1) or have not (changed == 0) been changed
+   since the last call to wrefresh().
+
+   is_linetouched() returns TRUE if the specified line in the specified
+   window has been changed since the last call to wrefresh().
+
+   is_wintouched() returns TRUE if the specified window has been changed
+   since the last call to wrefresh().
+
+   touchoverlap(win1, win2) marks the portion of win2 which overlaps
+   with win1 as modified.
+
+### Return Value
+
+   All functions return OK on success and ERR on error except
+   is_wintouched() and is_linetouched().
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    touchwin                    Y       Y       Y
+    touchline                   Y       Y       Y
+    untouchwin                  Y       Y       Y
+    wtouchln                    Y       Y       Y
+    is_linetouched              Y       Y       Y
+    is_wintouched               Y       Y       Y
+    touchoverlap                -       -       Y
+
+**man-end****************************************************************/
+
+int touchwin(WINDOW *win)
+{
+    int i;
+
+    PDC_LOG(("touchwin() - called: Win=%x\n", win));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    for (i = 0; i < win->_maxy; i++)
+    {
+        win->_firstch[i] = 0;
+        win->_lastch[i] = win->_maxx - 1;
+    }
+
+    return OK;
+}
+
+int touchline(WINDOW *win, int start, int count)
+{
+    int i;
+
+    PDC_LOG(("touchline() - called: win=%p start %d count %d\n",
+             win, start, count));
+
+    assert( win);
+    if (!win || start > win->_maxy || start + count > win->_maxy)
+        return ERR;
+
+    for (i = start; i < start + count; i++)
+    {
+        win->_firstch[i] = 0;
+        win->_lastch[i] = win->_maxx - 1;
+    }
+
+    return OK;
+}
+
+int untouchwin(WINDOW *win)
+{
+    int i;
+
+    PDC_LOG(("untouchwin() - called: win=%p", win));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    for (i = 0; i < win->_maxy; i++)
+    {
+        win->_firstch[i] = _NO_CHANGE;
+        win->_lastch[i] = _NO_CHANGE;
+    }
+
+    return OK;
+}
+
+int wtouchln(WINDOW *win, int y, int n, int changed)
+{
+    int i;
+
+    PDC_LOG(("wtouchln() - called: win=%p y=%d n=%d changed=%d\n",
+             win, y, n, changed));
+
+    assert( win);
+    if (!win || y > win->_maxy || y + n > win->_maxy)
+        return ERR;
+
+    for (i = y; i < y + n; i++)
+    {
+        if (changed)
+        {
+            win->_firstch[i] = 0;
+            win->_lastch[i] = win->_maxx - 1;
+        }
+        else
+        {
+            win->_firstch[i] = _NO_CHANGE;
+            win->_lastch[i] = _NO_CHANGE;
+        }
+    }
+
+    return OK;
+}
+
+bool is_linetouched(WINDOW *win, int line)
+{
+    PDC_LOG(("is_linetouched() - called: win=%p line=%d\n", win, line));
+
+    assert( win);
+    if (!win || line > win->_maxy || line < 0)
+        return FALSE;
+
+    return (win->_firstch[line] != _NO_CHANGE) ? TRUE : FALSE;
+}
+
+bool is_wintouched(WINDOW *win)
+{
+    int i;
+
+    PDC_LOG(("is_wintouched() - called: win=%p\n", win));
+
+    assert( win);
+    if (win)
+        for (i = 0; i < win->_maxy; i++)
+            if (win->_firstch[i] != _NO_CHANGE)
+                return TRUE;
+
+    return FALSE;
+}
+
+int touchoverlap(const WINDOW *win1, WINDOW *win2)
+{
+    int y, endy, endx, starty, startx;
+
+    PDC_LOG(("touchoverlap() - called: win1=%p win2=%p\n", win1, win2));
+
+    assert( win1);
+    assert( win2);
+    if (!win1 || !win2)
+        return ERR;
+
+    starty = max(win1->_begy, win2->_begy);
+    startx = max(win1->_begx, win2->_begx);
+    endy = min(win1->_maxy + win1->_begy, win2->_maxy + win2->_begy);
+    endx = min(win1->_maxx + win1->_begx, win2->_maxx + win2->_begx);
+
+    if (starty >= endy || startx >= endx)
+        return OK;
+
+    starty -= win2->_begy;
+    startx -= win2->_begx;
+    endy -= win2->_begy;
+    endx -= win2->_begx;
+    endx -= 1;
+
+    for (y = starty; y < endy; y++)
+    {
+        win2->_firstch[y] = startx;
+        win2->_lastch[y] = endx;
+    }
+
+    return OK;
+}
diff --git a/lib/PDCursesMod/pdcurses/util.c b/lib/PDCursesMod/pdcurses/util.c
new file mode 100644
index 00000000000..2197370eaaf
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/util.c
@@ -0,0 +1,348 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+util
+----
+
+### Synopsis
+
+    char *unctrl(chtype c);
+    void filter(void);
+    void use_env(bool x);
+    int delay_output(int ms);
+
+    int getcchar(const cchar_t *wcval, wchar_t *wch, attr_t *attrs,
+                 short *color_pair, void *opts);
+    int setcchar(cchar_t *wcval, const wchar_t *wch, const attr_t attrs,
+                 short color_pair, const void *opts);
+    wchar_t *wunctrl(cchar_t *wc);
+
+    int PDC_mbtowc(wchar_t *pwc, const char *s, size_t n);
+    size_t PDC_mbstowcs(wchar_t *dest, const char *src, size_t n);
+    size_t PDC_wcstombs(char *dest, const wchar_t *src, size_t n);
+
+### Description
+
+   unctrl() expands the text portion of the chtype c into a printable
+   string. Control characters are changed to the "^X" notation; others
+   are passed through. wunctrl() is the wide-character version of the
+   function.
+
+   filter() and use_env() are no-ops in PDCurses.
+
+   delay_output() inserts an ms millisecond pause in output.
+
+   getcchar() works in two modes: When wch is not NULL, it reads the
+   cchar_t pointed to by wcval and stores the attributes in attrs, the
+   color pair in color_pair, and the text in the wide-character string
+   wch. When wch is NULL, getcchar() merely returns the number of wide
+   characters in wcval. In either mode, the opts argument is unused.
+
+   setcchar constructs a cchar_t at wcval from the wide-character text
+   at wch, the attributes in attr and the color pair in color_pair. The
+   opts argument is unused.
+
+   Currently, the length returned by getcchar() is always 1 or 0.
+   Similarly, setcchar() will only take the first wide character from
+   wch, and ignore any others that it "should" take (i.e., combining
+   characters). Nor will it correctly handle any character outside the
+   basic multilingual plane (UCS-2).
+
+### Return Value
+
+   wunctrl() returns NULL on failure. delay_output() always returns OK.
+
+   getcchar() returns the number of wide characters wcval points to when
+   wch is NULL; when it's not, getcchar() returns OK or ERR.
+
+   setcchar() returns OK or ERR.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    unctrl                      Y       Y       Y
+    filter                      Y       Y       Y
+    use_env                     Y       Y       Y
+    delay_output                Y       Y       Y
+    getcchar                    Y       Y       Y
+    setcchar                    Y       Y       Y
+    wunctrl                     Y       Y       Y
+    PDC_mbtowc                  -       -       -
+    PDC_mbstowcs                -       -       -
+    PDC_wcstombs                -       -       -
+
+**man-end****************************************************************/
+
+#ifdef PDC_WIDE
+# ifdef PDC_FORCE_UTF8
+#  include <string.h>
+# else
+#  include <stdlib.h>
+# endif
+#endif
+
+char *unctrl(chtype c)
+{
+    static char strbuf[3] = {0, 0, 0};
+
+    chtype ic;
+
+    PDC_LOG(("unctrl() - called\n"));
+
+    ic = c & A_CHARTEXT;
+
+    if (ic >= 0x20 && ic != 0x7f)       /* normal characters */
+    {
+        strbuf[0] = (char)ic;
+        strbuf[1] = '\0';
+        return strbuf;
+    }
+
+    strbuf[0] = '^';            /* '^' prefix */
+
+    if (ic == 0x7f)             /* 0x7f == DEL */
+        strbuf[1] = '?';
+    else                    /* other control */
+        strbuf[1] = (char)(ic + '@');
+
+    return strbuf;
+}
+
+void filter(void)
+{
+    PDC_LOG(("filter() - called\n"));
+}
+
+void use_env(bool x)
+{
+    INTENTIONALLY_UNUSED_PARAMETER( x);
+    PDC_LOG(("use_env() - called: x %d\n", x));
+}
+
+int delay_output(int ms)
+{
+    PDC_LOG(("delay_output() - called: ms %d\n", ms));
+
+    return napms(ms);
+}
+
+int PDC_wc_to_utf8( char *dest, const int32_t code)
+{
+   int n_bytes_out;
+
+   if (code < 0x80)
+   {
+       dest[0] = (char)code;
+       n_bytes_out = 1;
+   }
+   else
+       if (code < 0x800)
+       {
+           dest[0] = (char) (((code >> 6) & 0x1f) | 0xc0);
+           dest[1] = (char) ((code & 0x3f) | 0x80);
+           n_bytes_out = 2;
+       }
+       else if( code < 0x10000)
+       {
+           dest[0] = (char) (((code >> 12) & 0x0f) | 0xe0);
+           dest[1] = (char) (((code >> 6) & 0x3f) | 0x80);
+           dest[2] = (char) ((code & 0x3f) | 0x80);
+           n_bytes_out = 3;
+       }
+       else       /* Unicode past 64K,  i.e.,  SMP */
+       {
+           dest[0] = (char) (((code >> 18) & 0x0f) | 0xf0);
+           dest[1] = (char) (((code >> 12) & 0x3f) | 0x80);
+           dest[2] = (char) (((code >> 6) & 0x3f) | 0x80);
+           dest[3] = (char) ((code & 0x3f) | 0x80);
+           n_bytes_out = 4;
+       }
+   return( n_bytes_out);
+}
+
+#ifdef PDC_WIDE
+int getcchar(const cchar_t *wcval, wchar_t *wch, attr_t *attrs,
+             short *color_pair, void *opts)
+{
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    assert( wcval);
+    if (!wcval)
+        return ERR;
+
+    if (wch)
+    {
+        assert( attrs);
+        assert( color_pair);
+        if (!attrs || !color_pair)
+            return ERR;
+
+        *wch = (wchar_t)(*wcval & A_CHARTEXT);
+        *attrs = (*wcval & (A_ATTRIBUTES & ~A_COLOR));
+        *color_pair = (short)( PAIR_NUMBER(*wcval & A_COLOR));
+
+        if (*wch)
+            *++wch = L'\0';
+
+        return OK;
+    }
+    else
+        return ((*wcval & A_CHARTEXT) != L'\0');
+}
+
+int setcchar(cchar_t *wcval, const wchar_t *wch, const attr_t attrs,
+             short color_pair, const void *opts)
+{
+    INTENTIONALLY_UNUSED_PARAMETER( opts);
+    assert( wcval);
+    assert( wch);
+    if (!wcval || !wch)
+        return ERR;
+
+    *wcval = *wch | attrs | COLOR_PAIR(color_pair);
+
+    return OK;
+}
+
+wchar_t *wunctrl(cchar_t *wc)
+{
+    static wchar_t strbuf[3] = {0, 0, 0};
+
+    cchar_t ic;
+
+    PDC_LOG(("wunctrl() - called\n"));
+
+    assert( wc);
+    if (!wc)
+        return NULL;
+
+    ic = *wc & A_CHARTEXT;
+
+    if (ic >= 0x20 && ic != 0x7f)       /* normal characters */
+    {
+        strbuf[0] = (wchar_t)ic;
+        strbuf[1] = L'\0';
+        return strbuf;
+    }
+
+    strbuf[0] = '^';            /* '^' prefix */
+
+    if (ic == 0x7f)             /* 0x7f == DEL */
+        strbuf[1] = '?';
+    else                    /* other control */
+        strbuf[1] = (wchar_t)(ic + '@');
+
+    return strbuf;
+}
+
+#define IS_CONTINUATION_BYTE( c) (((c) & 0xc0) == 0x80)
+
+int PDC_mbtowc(wchar_t *pwc, const char *s, size_t n)
+{
+# ifdef PDC_FORCE_UTF8
+    uint32_t key;
+    int i = -1;
+    const unsigned char *string;
+
+    assert( s);
+    assert( pwc);
+    if (!s || (n < 1))
+        return -1;
+
+    if (!*s)
+        return 0;
+
+    string = (const unsigned char *)s;
+
+    key = string[0];
+
+    /* Simplistic UTF-8 decoder -- a little validation */
+
+    if ((key & 0xc0) == 0xc0 && IS_CONTINUATION_BYTE( string[1]))
+    {
+        if ((key & 0xe0) == 0xc0 && 1 < n)
+        {
+            key = ((key & 0x1f) << 6) | (string[1] & 0x3f);
+            i = 2;      /* two-byte sequence : U+0080 to U+07FF */
+        }
+        else if ((key & 0xf0) == 0xe0 && 2 < n
+                  && IS_CONTINUATION_BYTE( string[2]))
+        {
+            key = ((key & 0x0f) << 12) | ((string[1] & 0x3f) << 6) |
+                  (string[2] & 0x3f);
+            i = 3;      /* three-byte sequence : U+0800 to U+FFFF */
+        }
+        else if ((key & 0xf8) == 0xf0 && 3 < n    /* SMP:  Unicode past 64K */
+                  && IS_CONTINUATION_BYTE( string[2])
+                  && IS_CONTINUATION_BYTE( string[3]))
+        {
+            key = ((key & 0x07) << 18) | ((string[1] & 0x3f) << 12) |
+                  ((string[2] & 0x3f) << 6) | (string[2] & 0x3f);
+            if( key <= 0x10ffff)
+                i = 4;     /* four-byte sequence : U+10000 to U+10FFFF */
+        }
+    }
+    else             /* 'ordinary' 7-bit ASCII */
+        i = 1;
+
+    *pwc = (wchar_t)key;
+
+    return i;
+# else
+    assert( s);
+    assert( pwc);
+    return mbtowc(pwc, s, n);
+# endif
+}
+
+size_t PDC_mbstowcs(wchar_t *dest, const char *src, size_t n)
+{
+# ifdef PDC_FORCE_UTF8
+    size_t i = 0, len;
+
+    assert( src);
+    assert( dest);
+    if (!src || !dest)
+        return 0;
+
+    len = strlen(src);
+
+    while (*src && i < n)
+    {
+        int retval = PDC_mbtowc(dest + i, src, len);
+
+        if (retval < 1)
+            return (size_t)-1;
+
+        src += retval;
+        len -= retval;
+        i++;
+    }
+# else
+    size_t i = mbstowcs(dest, src, n);
+# endif
+    dest[i] = 0;
+    return i;
+}
+
+size_t PDC_wcstombs(char *dest, const wchar_t *src, size_t n)
+{
+# ifdef PDC_FORCE_UTF8
+    size_t i = 0;
+
+    assert( src);
+    assert( dest);
+    if (!src || !dest)
+        return 0;
+
+    while (*src && i < n)
+       i += PDC_wc_to_utf8( dest + i, *src++);
+# else
+    size_t i = wcstombs(dest, src, n);
+# endif
+    dest[i] = '\0';
+    return i;
+}
+#endif
diff --git a/lib/PDCursesMod/pdcurses/window.c b/lib/PDCursesMod/pdcurses/window.c
new file mode 100644
index 00000000000..60c7a092384
--- /dev/null
+++ b/lib/PDCursesMod/pdcurses/window.c
@@ -0,0 +1,574 @@
+/* PDCurses */
+
+#include <curspriv.h>
+#include <assert.h>
+
+/*man-start**************************************************************
+
+window
+------
+
+### Synopsis
+
+    WINDOW *newwin(int nlines, int ncols, int begy, int begx);
+    WINDOW *derwin(WINDOW* orig, int nlines, int ncols,
+                   int begy, int begx);
+    WINDOW *subwin(WINDOW* orig, int nlines, int ncols,
+                   int begy, int begx);
+    WINDOW *dupwin(WINDOW *win);
+    int delwin(WINDOW *win);
+    int mvwin(WINDOW *win, int y, int x);
+    int mvderwin(WINDOW *win, int pary, int parx);
+    int syncok(WINDOW *win, bool bf);
+    void wsyncup(WINDOW *win);
+    void wcursyncup(WINDOW *win);
+    void wsyncdown(WINDOW *win);
+
+    WINDOW *resize_window(WINDOW *win, int nlines, int ncols);
+    int wresize(WINDOW *win, int nlines, int ncols);
+    WINDOW *PDC_makelines(WINDOW *win);
+    WINDOW *PDC_makenew(int nlines, int ncols, int begy, int begx);
+    void PDC_sync(WINDOW *win);
+
+### Description
+
+   newwin() creates a new window with the given number of lines, nlines
+   and columns, ncols. The upper left corner of the window is at line
+   begy, column begx. If nlines is zero, it defaults to LINES - begy;
+   ncols to COLS - begx. Create a new full-screen window by calling
+   newwin(0, 0, 0, 0).
+
+   delwin() deletes the named window, freeing all associated memory. In
+   the case of overlapping windows, subwindows should be deleted before
+   the main window.
+
+   mvwin() moves the window so that the upper left-hand corner is at
+   position (y,x). If the move would cause the window to be off the
+   screen, it is an error and the window is not moved. Moving subwindows
+   is allowed.
+
+   subwin() creates a new subwindow within a window. The dimensions of
+   the subwindow are nlines lines and ncols columns. The subwindow is at
+   position (begy, begx) on the screen. This position is relative to the
+   screen, and not to the window orig. Changes made to either window
+   will affect both. When using this routine, you will often need to
+   call touchwin() before calling wrefresh().
+
+   derwin() is the same as subwin(), except that begy and begx are
+   relative to the origin of the window orig rather than the screen.
+   There is no difference between subwindows and derived windows.
+
+   mvderwin() moves a derived window (or subwindow) inside its parent
+   window. The screen-relative parameters of the window are not changed.
+   This routine is used to display different parts of the parent window
+   at the same physical position on the screen.
+
+   dupwin() creates an exact duplicate of the window win.
+
+   wsyncup() causes a touchwin() of all of the window's parents.
+
+   If wsyncok() is called with a second argument of TRUE, this causes a
+   wsyncup() to be called every time the window is changed.
+
+   wcursyncup() causes the current cursor position of all of a window's
+   ancestors to reflect the current cursor position of the current
+   window.
+
+   wsyncdown() causes a touchwin() of the current window if any of its
+   parent's windows have been touched.
+
+   resize_window() allows the user to resize an existing window. It
+   returns the pointer to the new window, or NULL on failure.
+
+   wresize() is an ncurses-compatible wrapper for resize_window(). Note
+   that, unlike ncurses, it will NOT process any subwindows of the
+   window. (However, you still can call it _on_ subwindows.) It returns
+   OK or ERR.
+
+   PDC_makenew() allocates all data for a new WINDOW * except the actual
+   lines themselves. If it's unable to allocate memory for the window
+   structure, it will free all allocated memory and return a NULL
+   pointer.
+
+   PDC_makelines() allocates the memory for the lines.
+
+   PDC_sync() handles wrefresh() and wsyncup() calls when a window is
+   changed.
+
+### Return Value
+
+   newwin(), subwin(), derwin() and dupwin() return a pointer to the new
+   window, or NULL on failure. delwin(), mvwin(), mvderwin() and
+   syncok() return OK or ERR. wsyncup(), wcursyncup() and wsyncdown()
+   return nothing.
+
+### Errors
+
+   It is an error to call resize_window() before calling initscr().
+   Also, an error will be generated if we fail to create a newly sized
+   replacement window for curscr, or stdscr. This could happen when
+   increasing the window size. NOTE: If this happens, the previously
+   successfully allocated windows are left alone; i.e., the resize is
+   NOT cancelled for those windows.
+
+### Portability
+                             X/Open  ncurses  NetBSD
+    newwin                      Y       Y       Y
+    delwin                      Y       Y       Y
+    mvwin                       Y       Y       Y
+    subwin                      Y       Y       Y
+    derwin                      Y       Y       Y
+    mvderwin                    Y       Y       Y
+    dupwin                      Y       Y       Y
+    wsyncup                     Y       Y       Y
+    syncok                      Y       Y       Y
+    wcursyncup                  Y       Y       Y
+    wsyncdown                   Y       Y       Y
+    wresize                     -       Y       Y
+    resize_window               -       -       -
+    PDC_makelines               -       -       -
+    PDC_makenew                 -       -       -
+    PDC_sync                    -       -       -
+
+**man-end****************************************************************/
+
+#include <stdlib.h>
+
+WINDOW *PDC_makenew(int nlines, int ncols, int begy, int begx)
+{
+    WINDOW *win;
+
+    PDC_LOG(("PDC_makenew() - called: lines %d cols %d begy %d begx %d\n",
+             nlines, ncols, begy, begx));
+
+    /* allocate the window structure itself */
+
+    win = calloc(1, sizeof(WINDOW));
+    if (!win)
+        return win;
+
+    /* allocate the line pointer array */
+
+    win->_y = malloc(nlines * sizeof(chtype *));
+    if (!win->_y)
+    {
+        free(win);
+        return (WINDOW *)NULL;
+    }
+
+    /* allocate the minchng and maxchng arrays */
+
+    win->_firstch = malloc(nlines * sizeof(int) * 2);
+    if (!win->_firstch)
+    {
+        free(win->_y);
+        free(win);
+        return (WINDOW *)NULL;
+    }
+
+    win->_lastch = win->_firstch + nlines;
+
+    /* initialize window variables */
+
+    win->_maxy = nlines;  /* real max screen size */
+    win->_maxx = ncols;   /* real max screen size */
+    win->_begy = begy;
+    win->_begx = begx;
+    win->_bkgd = ' ';     /* wrs 4/10/93 -- initialize background to blank */
+    win->_clear = (bool) ((nlines == LINES) && (ncols == COLS));
+    win->_bmarg = nlines - 1;
+    win->_parx = win->_pary = -1;
+
+    /* init to say window all changed */
+
+    touchwin(win);
+
+    return win;
+}
+
+WINDOW *PDC_makelines(WINDOW *win)
+{
+    int i, nlines, ncols;
+
+    PDC_LOG(("PDC_makelines() - called\n"));
+
+    assert( win);
+    if (!win)
+        return (WINDOW *)NULL;
+
+    nlines = win->_maxy;
+    ncols = win->_maxx;
+
+    win->_y[0] = malloc(ncols * nlines * sizeof(chtype));
+    if (!win->_y[0])
+    {
+        /* if error, free all the data */
+
+        free(win->_firstch);
+        free(win->_y);
+        free(win);
+
+        return (WINDOW *)NULL;
+    }
+    for (i = 1; i < nlines; i++)
+        win->_y[i] = win->_y[i - 1] + ncols;
+
+    return win;
+}
+
+void PDC_sync(WINDOW *win)
+{
+    PDC_LOG(("PDC_sync() - called:\n"));
+
+    if (win->_immed)
+        wrefresh(win);
+    if (win->_sync)
+        wsyncup(win);
+}
+
+WINDOW *newwin(int nlines, int ncols, int begy, int begx)
+{
+    WINDOW *win;
+
+    PDC_LOG(("newwin() - called:lines=%d cols=%d begy=%d begx=%d\n",
+             nlines, ncols, begy, begx));
+
+    if (!nlines)
+        nlines = LINES - begy;
+    if (!ncols)
+        ncols  = COLS  - begx;
+
+    assert( SP);
+    if (!SP || begy + nlines > SP->lines || begx + ncols > SP->cols)
+        return (WINDOW *)NULL;
+
+    win = PDC_makenew(nlines, ncols, begy, begx);
+    if (win)
+        win = PDC_makelines(win);
+
+    if (win)
+        werase(win);
+
+    return win;
+}
+
+int delwin(WINDOW *win)
+{
+    PDC_LOG(("delwin() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    /* subwindows use parents' lines */
+
+    if (!(win->_flags & (_SUBWIN|_SUBPAD)))
+        if (win->_y[0])
+           free(win->_y[0]);
+
+    free(win->_firstch);
+    free(win->_y);
+    free(win);
+
+    return OK;
+}
+
+int mvwin(WINDOW *win, int y, int x)
+{
+    PDC_LOG(("mvwin() - called\n"));
+
+    assert( win);
+    if (!win || (y + win->_maxy > LINES || y < 0)
+             || (x + win->_maxx > COLS || x < 0))
+        return ERR;
+
+    win->_begy = y;
+    win->_begx = x;
+    touchwin(win);
+
+    return OK;
+}
+
+WINDOW *subwin(WINDOW *orig, int nlines, int ncols, int begy, int begx)
+{
+    WINDOW *win;
+    int i, j, k;
+
+    PDC_LOG(("subwin() - called: lines %d cols %d begy %d begx %d\n",
+             nlines, ncols, begy, begx));
+
+    /* make sure window fits inside the original one */
+
+    assert( orig);
+    if (!orig || (begy < orig->_begy) || (begx < orig->_begx) ||
+        (begy + nlines) > (orig->_begy + orig->_maxy) ||
+        (begx + ncols) > (orig->_begx + orig->_maxx))
+        return (WINDOW *)NULL;
+
+    j = begy - orig->_begy;
+    k = begx - orig->_begx;
+
+    if (!nlines)
+        nlines = orig->_maxy - 1 - j;
+    if (!ncols)
+        ncols  = orig->_maxx - 1 - k;
+
+    win = PDC_makenew(nlines, ncols, begy, begx);
+    if (!win)
+        return (WINDOW *)NULL;
+
+    /* initialize window variables */
+
+    win->_attrs = orig->_attrs;
+    win->_bkgd = orig->_bkgd;
+    win->_leaveit = orig->_leaveit;
+    win->_scroll = orig->_scroll;
+    win->_nodelay = orig->_nodelay;
+    win->_delayms = orig->_delayms;
+    win->_use_keypad = orig->_use_keypad;
+    win->_immed = orig->_immed;
+    win->_sync = orig->_sync;
+    win->_pary = j;
+    win->_parx = k;
+    win->_parent = orig;
+
+    for (i = 0; i < nlines; i++, j++)
+        win->_y[i] = orig->_y[j] + k;
+
+    win->_flags |= _SUBWIN;
+
+    return win;
+}
+
+WINDOW *derwin(WINDOW *orig, int nlines, int ncols, int begy, int begx)
+{
+    return subwin(orig, nlines, ncols, begy + orig->_begy, begx + orig->_begx);
+}
+
+int mvderwin(WINDOW *win, int pary, int parx)
+{
+    int i, j;
+    WINDOW *mypar;
+
+    assert( win);
+    if (!win || !(win->_parent))
+        return ERR;
+
+    mypar = win->_parent;
+
+    if (pary < 0 || parx < 0 || (pary + win->_maxy) > mypar->_maxy ||
+                                (parx + win->_maxx) > mypar->_maxx)
+        return ERR;
+
+    j = pary;
+
+    for (i = 0; i < win->_maxy; i++)
+        win->_y[i] = (mypar->_y[j++]) + parx;
+
+    win->_pary = pary;
+    win->_parx = parx;
+
+    return OK;
+}
+
+WINDOW *dupwin(WINDOW *win)
+{
+    WINDOW *new;
+    chtype *ptr, *ptr1;
+    int nlines, ncols, begy, begx, i;
+
+    assert( win);
+    if (!win)
+        return (WINDOW *)NULL;
+
+    nlines = win->_maxy;
+    ncols = win->_maxx;
+    begy = win->_begy;
+    begx = win->_begx;
+
+    new = PDC_makenew(nlines, ncols, begy, begx);
+    if (new)
+        new = PDC_makelines(new);
+
+    if (!new)
+        return (WINDOW *)NULL;
+
+    /* copy the contents of win into new */
+
+    for (i = 0; i < nlines; i++)
+    {
+        for (ptr = new->_y[i], ptr1 = win->_y[i];
+             ptr < new->_y[i] + ncols; ptr++, ptr1++)
+            *ptr = *ptr1;
+
+        new->_firstch[i] = 0;
+        new->_lastch[i] = ncols - 1;
+    }
+
+    new->_curx = win->_curx;
+    new->_cury = win->_cury;
+    new->_maxy = win->_maxy;
+    new->_maxx = win->_maxx;
+    new->_begy = win->_begy;
+    new->_begx = win->_begx;
+    new->_flags = win->_flags;
+    new->_attrs = win->_attrs;
+    new->_clear = win->_clear;
+    new->_leaveit = win->_leaveit;
+    new->_scroll = win->_scroll;
+    new->_nodelay = win->_nodelay;
+    new->_delayms = win->_delayms;
+    new->_use_keypad = win->_use_keypad;
+    new->_tmarg = win->_tmarg;
+    new->_bmarg = win->_bmarg;
+    new->_parx = win->_parx;
+    new->_pary = win->_pary;
+    new->_parent = win->_parent;
+    new->_bkgd = win->_bkgd;
+    new->_flags = win->_flags;
+
+    return new;
+}
+
+WINDOW *resize_window(WINDOW *win, int nlines, int ncols)
+{
+    WINDOW *new;
+    int save_cury, save_curx, new_begy, new_begx;
+
+    PDC_LOG(("resize_window() - called: nlines %d ncols %d\n",
+             nlines, ncols));
+
+    assert( SP);
+    assert( win);
+    if (!win || !SP)
+        return (WINDOW *)NULL;
+
+    if (win->_flags & _SUBPAD)
+    {
+        new = subpad(win->_parent, nlines, ncols, win->_begy, win->_begx);
+        if (!new)
+            return (WINDOW *)NULL;
+    }
+    else if (win->_flags & _SUBWIN)
+    {
+        new = subwin(win->_parent, nlines, ncols, win->_begy, win->_begx);
+        if (!new)
+            return (WINDOW *)NULL;
+    }
+    else
+    {
+        if (win == SP->slk_winptr)
+        {
+            new_begy = SP->lines - SP->slklines;
+            new_begx = 0;
+        }
+        else
+        {
+            new_begy = win->_begy;
+            new_begx = win->_begx;
+        }
+
+        new = PDC_makenew(nlines, ncols, new_begy, new_begx);
+        if (!new)
+            return (WINDOW *)NULL;
+    }
+
+    save_curx = min(win->_curx, (new->_maxx - 1));
+    save_cury = min(win->_cury, (new->_maxy - 1));
+
+    if (!(win->_flags & (_SUBPAD|_SUBWIN)))
+    {
+        new = PDC_makelines(new);
+        if (!new)
+            return (WINDOW *)NULL;
+
+        werase(new);
+
+        copywin(win, new, 0, 0, 0, 0, min(win->_maxy, new->_maxy) - 1,
+                min(win->_maxx, new->_maxx) - 1, FALSE);
+
+        if (win->_y[0])
+            free(win->_y[0]);
+    }
+
+    new->_flags = win->_flags;
+    new->_attrs = win->_attrs;
+    new->_clear = win->_clear;
+    new->_leaveit = win->_leaveit;
+    new->_scroll = win->_scroll;
+    new->_nodelay = win->_nodelay;
+    new->_delayms = win->_delayms;
+    new->_use_keypad = win->_use_keypad;
+    new->_tmarg = (win->_tmarg > new->_maxy - 1) ? 0 : win->_tmarg;
+    new->_bmarg = (win->_bmarg == win->_maxy - 1) ?
+                  new->_maxy - 1 : min(win->_bmarg, (new->_maxy - 1));
+    new->_parent = win->_parent;
+    new->_immed = win->_immed;
+    new->_sync = win->_sync;
+    new->_bkgd = win->_bkgd;
+
+    new->_curx = save_curx;
+    new->_cury = save_cury;
+
+    free(win->_firstch);
+    free(win->_y);
+
+    *win = *new;
+    free(new);
+
+    return win;
+}
+
+int wresize(WINDOW *win, int nlines, int ncols)
+{
+    return (resize_window(win, nlines, ncols) ? OK : ERR);
+}
+
+void wsyncup(WINDOW *win)
+{
+    WINDOW *tmp;
+
+    PDC_LOG(("wsyncup() - called\n"));
+
+    for (tmp = win; tmp; tmp = tmp->_parent)
+        touchwin(tmp);
+}
+
+int syncok(WINDOW *win, bool bf)
+{
+    PDC_LOG(("syncok() - called\n"));
+
+    assert( win);
+    if (!win)
+        return ERR;
+
+    win->_sync = bf;
+
+    return OK;
+}
+
+void wcursyncup(WINDOW *win)
+{
+    WINDOW *tmp;
+
+    PDC_LOG(("wcursyncup() - called\n"));
+
+    for (tmp = win; tmp && tmp->_parent; tmp = tmp->_parent)
+        wmove(tmp->_parent, tmp->_pary + tmp->_cury, tmp->_parx + tmp->_curx);
+}
+
+void wsyncdown(WINDOW *win)
+{
+    WINDOW *tmp;
+
+    PDC_LOG(("wsyncdown() - called\n"));
+
+    for (tmp = win; tmp; tmp = tmp->_parent)
+    {
+        if (is_wintouched(tmp))
+        {
+            touchwin(win);
+            break;
+        }
+    }
+}
-- 
2.35.1


From 18f6d0c36d1b8be6e07f8952c8b8287669c1b11c Mon Sep 17 00:00:00 2001
From: Samuel Dionne-Riel <samuel@dionne-riel.com>
Date: Mon, 26 Apr 2021 10:20:20 -0400
Subject: [PATCH 2/2] lib/PDCursesMod: Fix build for U-Boot

---
 lib/Kconfig                                   |   2 +
 lib/Makefile                                  |   1 +
 lib/PDCursesMod/.gitignore                    |   1 -
 lib/PDCursesMod/Kconfig                       |  22 ++
 lib/PDCursesMod/Makefile                      |  69 ++++++
 lib/PDCursesMod/ansi/pdcclip.c                |   2 +-
 lib/PDCursesMod/ansi/pdcdisp.c                |  33 ++-
 lib/PDCursesMod/ansi/pdcgetsc.c               |   8 +-
 lib/PDCursesMod/ansi/pdckbd.c                 |  24 +-
 lib/PDCursesMod/ansi/pdcscrn.c                | 231 +++++++++++++++++-
 lib/PDCursesMod/ansi/pdcsetsc.c               |   6 +-
 lib/PDCursesMod/ansi/pdcutil.c                |  14 +-
 lib/PDCursesMod/common/pdccolor.c             |   2 +-
 lib/PDCursesMod/curspriv.h                    |  21 +-
 lib/PDCursesMod/demos/firework.c              |   2 +-
 lib/PDCursesMod/demos/newtest.c               |   4 +-
 lib/PDCursesMod/demos/ozdemo.c                |   2 +-
 lib/PDCursesMod/demos/ptest.c                 |   4 +-
 lib/PDCursesMod/demos/rain.c                  |   2 +-
 lib/PDCursesMod/demos/simplemenu.c            |  19 +-
 lib/PDCursesMod/demos/speed.c                 |   2 +-
 lib/PDCursesMod/demos/test_pan.c              |   2 +-
 lib/PDCursesMod/demos/testcurs.c              |   2 +-
 lib/PDCursesMod/demos/triangles.c             |   2 +-
 lib/PDCursesMod/demos/tui.c                   |   8 +-
 lib/PDCursesMod/demos/tui.h                   |   2 +-
 lib/PDCursesMod/demos/tuidemo.c               |  19 +-
 lib/PDCursesMod/demos/version.c               |   2 +-
 lib/PDCursesMod/demos/worm.c                  |   2 +-
 lib/PDCursesMod/demos/xmas.c                  |   2 +-
 .../{ => include/PDCurses}/curses.h           |  12 +
 .../{ => include/PDCurses}/panel.h            |   2 +-
 lib/PDCursesMod/include/assert.h              |   7 +
 lib/PDCursesMod/include/limits.h              |   7 +
 lib/PDCursesMod/include/wchar.h               |   7 +
 lib/PDCursesMod/pdcurses/addch.c              |  42 ++--
 lib/PDCursesMod/pdcurses/addchstr.c           |  38 +--
 lib/PDCursesMod/pdcurses/addstr.c             |  38 +--
 lib/PDCursesMod/pdcurses/attr.c               |  60 ++---
 lib/PDCursesMod/pdcurses/beep.c               |   6 +-
 lib/PDCursesMod/pdcurses/bkgd.c               |  24 +-
 lib/PDCursesMod/pdcurses/border.c             |  46 ++--
 lib/PDCursesMod/pdcurses/clear.c              |  20 +-
 lib/PDCursesMod/pdcurses/color.c              |  24 +-
 lib/PDCursesMod/pdcurses/debug.c              |  16 +-
 lib/PDCursesMod/pdcurses/delch.c              |  10 +-
 lib/PDCursesMod/pdcurses/deleteln.c           |  22 +-
 lib/PDCursesMod/pdcurses/getch.c              |  26 +-
 lib/PDCursesMod/pdcurses/getstr.c             |  34 +--
 lib/PDCursesMod/pdcurses/getyx.c              |  20 +-
 lib/PDCursesMod/pdcurses/inch.c               |  18 +-
 lib/PDCursesMod/pdcurses/inchstr.c            |  34 +--
 lib/PDCursesMod/pdcurses/initscr.c            |  50 ++--
 lib/PDCursesMod/pdcurses/inopts.c             |  46 ++--
 lib/PDCursesMod/pdcurses/insch.c              |  30 +--
 lib/PDCursesMod/pdcurses/insstr.c             |  38 +--
 lib/PDCursesMod/pdcurses/instr.c              |  34 +--
 lib/PDCursesMod/pdcurses/kernel.c             |  28 +--
 lib/PDCursesMod/pdcurses/keyname.c            |   8 +-
 lib/PDCursesMod/pdcurses/mouse.c              |  28 +--
 lib/PDCursesMod/pdcurses/move.c               |  10 +-
 lib/PDCursesMod/pdcurses/outopts.c            |  22 +-
 lib/PDCursesMod/pdcurses/overlay.c            |   8 +-
 lib/PDCursesMod/pdcurses/pad.c                |  18 +-
 lib/PDCursesMod/pdcurses/panel.c              |  18 +-
 lib/PDCursesMod/pdcurses/printw.c             |  14 +-
 lib/PDCursesMod/pdcurses/refresh.c            |  20 +-
 lib/PDCursesMod/pdcurses/scanw.c              |  14 +-
 lib/PDCursesMod/pdcurses/scr_dump.c           |  20 +-
 lib/PDCursesMod/pdcurses/scroll.c             |   6 +-
 lib/PDCursesMod/pdcurses/slk.c                |  44 ++--
 lib/PDCursesMod/pdcurses/termattr.c           |  26 +-
 lib/PDCursesMod/pdcurses/touch.c              |  20 +-
 lib/PDCursesMod/pdcurses/util.c               |  26 +-
 lib/PDCursesMod/pdcurses/window.c             |  34 +--
 75 files changed, 1040 insertions(+), 547 deletions(-)
 create mode 100644 lib/PDCursesMod/Kconfig
 create mode 100644 lib/PDCursesMod/Makefile
 rename lib/PDCursesMod/{ => include/PDCurses}/curses.h (99%)
 rename lib/PDCursesMod/{ => include/PDCurses}/panel.h (98%)
 create mode 100644 lib/PDCursesMod/include/assert.h
 create mode 100644 lib/PDCursesMod/include/limits.h
 create mode 100644 lib/PDCursesMod/include/wchar.h

diff --git a/lib/Kconfig b/lib/Kconfig
index acc0ac081a4..0549d73a5b9 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -965,4 +965,6 @@ config PHANDLE_CHECK_SEQ
           enable this config option to distinguish them using
 	  phandles in fdtdec_get_alias_seq() function.
 
+source lib/PDCursesMod/Kconfig
+
 endmenu
diff --git a/lib/Makefile b/lib/Makefile
index d9b1811f750..f75d1494c61 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_CMD_BOOTEFI_SELFTEST) += efi_selftest/
 obj-$(CONFIG_LZMA) += lzma/
 obj-$(CONFIG_BZIP2) += bzip2/
 obj-$(CONFIG_TIZEN) += tizen/
+obj-$(CONFIG_PDCURSES) += PDCursesMod/
 obj-$(CONFIG_FIT) += libfdt/
 obj-$(CONFIG_OF_LIVE) += of_live.o
 obj-$(CONFIG_CMD_DHRYSTONE) += dhry/
diff --git a/lib/PDCursesMod/.gitignore b/lib/PDCursesMod/.gitignore
index 517bc2e4cad..e5b5399a5d0 100644
--- a/lib/PDCursesMod/.gitignore
+++ b/lib/PDCursesMod/.gitignore
@@ -15,7 +15,6 @@ tuidemo
 worm
 xmas
 *.sho
-Makefile
 config.h
 config.log
 config.status
diff --git a/lib/PDCursesMod/Kconfig b/lib/PDCursesMod/Kconfig
new file mode 100644
index 00000000000..aaa28dfacd1
--- /dev/null
+++ b/lib/PDCursesMod/Kconfig
@@ -0,0 +1,22 @@
+config PDCURSES
+	bool "Enable curses implementation"
+	imply CFB_CONSOLE_ANSI
+	imply VIDEO_ANSI
+	default n
+	help
+	  Select this option to enable building a curses implementation
+
+config PDCURSES_DEMOS
+	bool "Build PDCurses demos"
+	depends on PDCURSES
+	default n
+	help
+	  Select this option to build demos from PDCurses
+
+config PDCURSES_PREFER_VIDCONSOLE
+	bool "Prefer vidconsole size"
+	depends on PDCURSES
+	default n
+	help
+	  When enabled, the vidconsole sizes will be used.
+	  Otherwise, the smallest intersection between serial and vidconsole will be used.
diff --git a/lib/PDCursesMod/Makefile b/lib/PDCursesMod/Makefile
new file mode 100644
index 00000000000..a1c0f37f753
--- /dev/null
+++ b/lib/PDCursesMod/Makefile
@@ -0,0 +1,69 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# (C) Copyright 2021 Samuel Dionne-Riel
+#
+
+# This file only gets included when CONFIG_PDCURSES is set.
+
+obj- += dummy.o
+
+ifndef CONFIG_SPL_BUILD
+
+#ccflags-y := -I$(srctree)/lib/PDCursesMod/include
+#subdir-ccflags-y += -I$(srctree)/$(src)/
+subdir-ccflags-y += -I$(srctree)/$(src)/include
+
+obj-$(CONFIG_PDCURSES_DEMOS) += demos/simplemenu.o
+obj-$(CONFIG_PDCURSES_DEMOS) += demos/tui.o
+obj-$(CONFIG_PDCURSES_DEMOS) += demos/tuidemo.o
+
+obj-y += pdcurses/addch.o
+obj-y += pdcurses/addchstr.o
+obj-y += pdcurses/addstr.o
+obj-y += pdcurses/attr.o
+obj-y += pdcurses/beep.o
+obj-y += pdcurses/bkgd.o
+obj-y += pdcurses/border.o
+obj-y += pdcurses/clear.o
+obj-y += pdcurses/color.o
+obj-y += pdcurses/delch.o
+obj-y += pdcurses/deleteln.o
+obj-y += pdcurses/getch.o
+obj-y += pdcurses/getstr.o
+obj-y += pdcurses/getyx.o
+obj-y += pdcurses/inch.o
+obj-y += pdcurses/inchstr.o
+obj-y += pdcurses/initscr.o
+obj-y += pdcurses/inopts.o
+obj-y += pdcurses/insch.o
+obj-y += pdcurses/insstr.o
+obj-y += pdcurses/instr.o
+obj-y += pdcurses/kernel.o
+obj-y += pdcurses/keyname.o
+obj-y += pdcurses/mouse.o
+obj-y += pdcurses/move.o
+obj-y += pdcurses/outopts.o
+obj-y += pdcurses/overlay.o
+obj-y += pdcurses/pad.o
+obj-y += pdcurses/panel.o
+obj-y += pdcurses/printw.o
+obj-y += pdcurses/refresh.o
+obj-y += pdcurses/scanw.o
+obj-y += pdcurses/scr_dump.o
+obj-y += pdcurses/scroll.o
+obj-y += pdcurses/slk.o
+obj-y += pdcurses/termattr.o
+obj-y += pdcurses/touch.o
+obj-y += pdcurses/util.o
+obj-y += pdcurses/window.o
+obj-y += pdcurses/debug.o
+
+obj-y += ansi/pdcclip.o
+obj-y += ansi/pdcdisp.o
+obj-y += ansi/pdcgetsc.o
+obj-y += ansi/pdckbd.o
+obj-y += ansi/pdcscrn.o
+obj-y += ansi/pdcsetsc.o
+obj-y += ansi/pdcutil.o
+
+endif
diff --git a/lib/PDCursesMod/ansi/pdcclip.c b/lib/PDCursesMod/ansi/pdcclip.c
index 634a3c83078..ae09c7b8a08 100644
--- a/lib/PDCursesMod/ansi/pdcclip.c
+++ b/lib/PDCursesMod/ansi/pdcclip.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 
 /*man-start**************************************************************
 
diff --git a/lib/PDCursesMod/ansi/pdcdisp.c b/lib/PDCursesMod/ansi/pdcdisp.c
index 387a3f98882..edbe38b10fc 100644
--- a/lib/PDCursesMod/ansi/pdcdisp.c
+++ b/lib/PDCursesMod/ansi/pdcdisp.c
@@ -4,11 +4,16 @@
 #include <stdint.h>
 #include <string.h>
 #include <stdlib.h>
-#include <unistd.h>
 
-#include "curspriv.h"
+#include "../curspriv.h"
 #include "pdcansi.h"
 
+#ifdef __U_BOOT__
+#include <stdio.h>
+#include <console.h>
+#include <stdio_dev.h>
+#endif
+
 #ifdef PDC_WIDE
    #define USE_UNICODE_ACS_CHARS 1
 #else
@@ -26,6 +31,24 @@
 
 static void put_to_stdout( const char *buff, size_t bytes_out)
 {
+#ifdef __U_BOOT__
+	if (buff) {
+#ifdef PDCDEBUG
+		struct stdio_dev *vidconsole = console_search_dev(DEV_FLAGS_OUTPUT, "vidconsole");
+		if (vidconsole) {                        
+#endif
+			for (int i = 0; i < bytes_out; i++) {
+#ifdef PDCDEBUG
+				vidconsole->putc(vidconsole, buff[i]);
+#else
+				putc(buff[i]);
+#endif
+			}
+#ifdef PDCDEBUG
+		}                                     
+#endif
+	}
+#else
     static char *tbuff = NULL;
     static size_t bytes_cached;
     const int stdout_fd = 1;
@@ -66,6 +89,7 @@ static void put_to_stdout( const char *buff, size_t bytes_out)
                     memmove( tbuff, tbuff + bytes_written, bytes_cached);
             }
     }
+#endif
 }
 
 void PDC_puts_to_stdout( const char *buff)
@@ -301,5 +325,10 @@ void PDC_transform_line(int lineno, int x, int len, const chtype *srcp)
 
 void PDC_doupdate(void)
 {
+#ifdef __U_BOOT__
+	// Nothing to do
+	PDC_napms(15);
+#else
     put_to_stdout( NULL, 0);
+#endif
 }
diff --git a/lib/PDCursesMod/ansi/pdcgetsc.c b/lib/PDCursesMod/ansi/pdcgetsc.c
index 664728d71bb..5c29611d2d1 100644
--- a/lib/PDCursesMod/ansi/pdcgetsc.c
+++ b/lib/PDCursesMod/ansi/pdcgetsc.c
@@ -1,10 +1,10 @@
 /* Public Domain Curses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 
 int PDC_get_cursor_mode(void)
 {
-    PDC_LOG(("PDC_get_cursor_mode() - called\n"));
+    PDC_LOG("PDC_get_cursor_mode() - called\n");
 
     return SP->visibility;
 }
@@ -14,7 +14,7 @@ int PDC_get_columns(void)
 {
     extern int PDC_cols;
 
-    PDC_LOG(("PDC_get_columns() - called\n"));
+    PDC_LOG("PDC_get_columns() - called\n");
     return( PDC_cols);
 }
 
@@ -22,6 +22,6 @@ int PDC_get_rows(void)
 {
     extern int PDC_rows;
 
-    PDC_LOG(("PDC_get_rows() - called\n"));
+    PDC_LOG("PDC_get_rows() - called\n");
     return( PDC_rows);
 }
diff --git a/lib/PDCursesMod/ansi/pdckbd.c b/lib/PDCursesMod/ansi/pdckbd.c
index bc6b3ff1d1f..dac989422b5 100644
--- a/lib/PDCursesMod/ansi/pdckbd.c
+++ b/lib/PDCursesMod/ansi/pdckbd.c
@@ -1,11 +1,17 @@
 #include <stdio.h>
 #include <string.h>
 #include <assert.h>
-#include <sys/select.h>
-#include <unistd.h>
-#include "curspriv.h"
+#include "../curspriv.h"
 #include "pdcansi.h"
 
+#ifndef __U_BOOT__
+#include <sys/select.h>
+#endif
+
+#ifdef __U_BOOT__
+#include <linux/delay.h>
+#endif
+
 /* Modified from the accepted answer at
 
 https://stackoverflow.com/questions/33025599/move-the-cursor-in-a-c-program
@@ -25,6 +31,17 @@ extern bool PDC_resize_occurred;
 
 static bool check_key( int *c)
 {
+#ifdef __U_BOOT__
+    PDC_napms(0);
+    if (tstc()) {
+        if (c) {
+            *c = getchar();
+        }
+        return TRUE;
+    }
+
+    return FALSE;
+#else
     bool rval;
     const int STDIN = 0;
     struct timeval timeout;
@@ -45,6 +62,7 @@ static bool check_key( int *c)
     else
        rval = FALSE;
     return( rval);
+#endif
 }
 
 bool PDC_check_key( void)
diff --git a/lib/PDCursesMod/ansi/pdcscrn.c b/lib/PDCursesMod/ansi/pdcscrn.c
index 9afccf814d1..6939512e413 100644
--- a/lib/PDCursesMod/ansi/pdcscrn.c
+++ b/lib/PDCursesMod/ansi/pdcscrn.c
@@ -1,4 +1,8 @@
-// #define USE_TERMIOS
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Includes code from `lib/efi_loader/efi_console.c`
+ * Which is Copyright (c) 2016 Alexander Graf
+ */
 
 #ifdef USE_TERMIOS
 #include <string.h>
@@ -11,11 +15,19 @@ static struct termios orig_term;
 #endif
 
 #include <assert.h>
-#include "curspriv.h"
+#include "../curspriv.h"
 #include "pdcansi.h"
 #include "../common/pdccolor.h"
 #include "../common/pdccolor.c"
 
+#ifdef __U_BOOT__
+#include <common.h>
+#include <dm/device.h>
+#include <env.h>
+#include <video_console.h>
+#include <linux/delay.h>
+#endif
+
 #ifdef USING_COMBINING_CHARACTER_SCHEME
 int PDC_expand_combined_characters( const cchar_t c, cchar_t *added);
 #endif
@@ -26,6 +38,203 @@ const int STDIN = 0;
 chtype PDC_capabilities = 0;
 static mmask_t _stored_trap_mbe;
 
+// Whole #ifdef comes from lib/efi_loader/efi_console.c
+#ifdef __U_BOOT__
+
+#define cESC '\x1b'
+#define ESC "\x1b"
+
+static int term_get_char(s32 *c)
+{
+	u64 timeout;
+
+	/* Wait up to 100 ms for a character */
+	timeout = timer_get_us() + 100000;
+
+	while (!tstc())
+		if (timer_get_us() > timeout)
+			return 1;
+
+	*c = getchar();
+	return 0;
+}
+
+/**
+ * Receive and parse a reply from the terminal.
+ *
+ * @n:		array of return values
+ * @num:	number of return values expected
+ * @end_char:	character indicating end of terminal message
+ * Return:	non-zero indicates error
+ */
+static int term_read_reply(int *n, int num, char end_char)
+{
+	s32 c;
+	int i = 0;
+
+	if (term_get_char(&c) || c != cESC)
+		return -1;
+
+	if (term_get_char(&c) || c != '[')
+		return -1;
+
+	n[0] = 0;
+	while (1) {
+		if (!term_get_char(&c)) {
+			if (c == ';') {
+				i++;
+				if (i >= num)
+					return -1;
+				n[i] = 0;
+				continue;
+			} else if (c == end_char) {
+				break;
+			} else if (c > '9' || c < '0') {
+				return -1;
+			}
+
+			/* Read one more decimal position */
+			n[i] *= 10;
+			n[i] += c - '0';
+		} else {
+			return -1;
+		}
+	}
+	if (i != num - 1)
+		return -1;
+
+	return 0;
+}
+
+/**
+ * query_console_serial() - query serial console size
+ *
+ * When using a serial console or the net console we can only devise the
+ * terminal size by querying the terminal using ECMA-48 control sequences.
+ *
+ * @rows:	pointer to return number of rows
+ * @cols:	pointer to return number of columns
+ * Returns:	0 on success
+ */
+static int query_console_serial(int *rows, int *cols)
+{
+	int ret = 0;
+	int n[2];
+
+	/* Empty input buffer */
+	while (tstc())
+		getchar();
+
+	/*
+	 * Not all terminals understand CSI [18t for querying the console size.
+	 * We should adhere to escape sequences documented in the console_codes
+	 * man page and the ECMA-48 standard.
+	 *
+	 * So here we follow a different approach. We position the cursor to the
+	 * bottom right and query its position. Before leaving the function we
+	 * restore the original cursor position.
+	 */
+	printf(ESC "7"		/* Save cursor position */
+	       ESC "[r"		/* Set scrolling region to full window */
+	       ESC "[999;999H"	/* Move to bottom right corner */
+	       ESC "[6n");	/* Query cursor position */
+
+	/* Read {rows,cols} */
+	if (term_read_reply(n, 2, 'R')) {
+		ret = 1;
+		goto out;
+	}
+
+	*cols = n[1];
+	*rows = n[0];
+out:
+	printf(ESC "8");	/* Restore cursor position */
+	return ret;
+}
+
+/**
+ * query_vidconsole() - query video console size
+ *
+ *
+ * @rows:	pointer to return number of rows
+ * @cols:	pointer to return number of columns
+ * Returns:	0 on success
+ */
+static int __maybe_unused query_vidconsole(int *rows, int *cols)
+{
+	const char *stdout_name = env_get("stdout");
+	struct stdio_dev *stdout_dev;
+	struct udevice *dev;
+	struct vidconsole_priv *priv;
+
+	if (!stdout_name || strncmp(stdout_name, "vidconsole", 10) == 0)
+		return -ENODEV;
+	stdout_dev = stdio_get_by_name("vidconsole");
+	if (!stdout_dev)
+		return -ENODEV;
+	dev = stdout_dev->priv;
+	if (!dev)
+		return -ENODEV;
+	priv = dev_get_uclass_priv(dev);
+	if (!priv)
+		return -ENODEV;
+	*rows = priv->rows;
+	*cols = priv->cols;
+	return 0;
+}
+
+/**
+ * query_console_size() - update the mode table.
+ *
+ * By default the only mode available is 80x25. If the console has at least 50
+ * lines, enable mode 80x50. If we can query the console size and it is neither
+ * 80x25 nor 80x50, set it as an additional mode.
+ */
+static void query_console_size(void)
+{
+	int rows = 25, cols = 80;
+	int srows = -1, scols = -1;
+	int vrows = -1, vcols = -1;
+
+	if (IS_ENABLED(CONFIG_DM_VIDEO)) {
+		(void)query_vidconsole(&vrows, &vcols);
+	}
+
+	(void)query_console_serial(&srows, &scols);
+
+	// No data queried
+	if (srows == -1 && vrows == -1) {
+		goto out;
+	}
+
+#if CONFIG_PDCURSES_PREFER_VIDCONSOLE
+	if (vrows > 0 && vcols > 0) {
+		rows = vrows;
+		cols = vcols;
+	}
+	else if (srows > 0 && scols > 0) {
+		rows = srows;
+		cols = scols;
+	}
+#else
+	// Take the smaller value, only if not -1
+	if (vrows > 0) {
+		if (srows > 0 && vrows > srows) { rows = srows; }
+		else                            { rows = vrows; }
+	}
+	if (vcols > 0) {
+		if (scols > 0 && vcols > scols) { cols = scols; }
+		else                            { cols = vcols; }
+	}
+#endif
+
+out:
+	PDC_cols = cols;
+	PDC_rows = rows;
+}
+
+#endif
+
 /* COLOR_PAIR to attribute encoding table. */
 
 void PDC_reset_prog_mode( void)
@@ -136,20 +345,22 @@ int PDC_scr_open(void)
     struct sigaction sa;
 #endif
 
-    PDC_LOG(("PDC_scr_open called\n"));
+    PDC_LOG("PDC_scr_open called\n");
     COLORS = 16;
     assert( SP);
     if (!SP || PDC_init_palette( ))
         return ERR;
 
+#ifndef __U_BOOT__
     setbuf( stdin, NULL);
+#endif
 #ifdef USE_TERMIOS
     sigemptyset(&sa.sa_mask);
     sa.sa_flags = 0;
     sa.sa_handler = sigwinchHandler;
     if (sigaction(SIGWINCH, &sa, NULL) == -1)
     {
-        fprintf( stderr, "Sigaction failed\n");
+        PDC_perror("Sigaction failed\n");
         return( -1);
     }
     sigwinchHandler( 0);
@@ -157,16 +368,20 @@ int PDC_scr_open(void)
     sa.sa_handler = sigintHandler;
     if (sigaction(SIGINT, &sa, NULL) == -1)
     {
-        fprintf( stderr, "Sigaction (INT) failed\n");
+        PDC_perror("Sigaction (INT) failed\n");
         return( -1);
     }
 #else
     {
+#ifdef __U_BOOT__
+		query_console_size();
+#else
         const char *env = getenv("PDC_LINES");
 
         PDC_rows = (env ? atoi( env) : 25);
         env = getenv( "PDC_COLS");
         PDC_cols = (env ? atoi( env) : 80);
+#endif
     }
 #endif
     SP->mouse_wait = PDC_CLICK_PERIOD;
@@ -194,16 +409,16 @@ int PDC_scr_open(void)
     if (SP->lines < 2 || SP->lines > MAX_LINES
        || SP->cols < 2 || SP->cols > MAX_COLUMNS)
     {
-        fprintf(stderr, "LINES value must be >= 2 and <= %d: got %d\n",
+        PDC_perror("LINES value must be >= 2 and <= %d: got %d\n",
                 MAX_LINES, SP->lines);
-        fprintf(stderr, "COLS value must be >= 2 and <= %d: got %d\n",
+        PDC_perror("COLS value must be >= 2 and <= %d: got %d\n",
                 MAX_COLUMNS, SP->cols);
 
         return ERR;
     }
 
     PDC_reset_prog_mode();
-    PDC_LOG(("PDC_scr_open exit\n"));
+    PDC_LOG("PDC_scr_open exit\n");
     return( 0);
 }
 
diff --git a/lib/PDCursesMod/ansi/pdcsetsc.c b/lib/PDCursesMod/ansi/pdcsetsc.c
index 12bca5bb2d2..3c592977679 100644
--- a/lib/PDCursesMod/ansi/pdcsetsc.c
+++ b/lib/PDCursesMod/ansi/pdcsetsc.c
@@ -1,5 +1,5 @@
 #include <stdio.h>
-#include <curspriv.h>
+#include "../curspriv.h"
 #include "pdcansi.h"
 
 /*man-start**************************************************************
@@ -54,7 +54,7 @@ int PDC_curs_set( int visibility)
 {
     int ret_vis;
 
-    PDC_LOG(("PDC_curs_set() - called: visibility=%d\n", visibility));
+    PDC_LOG("PDC_curs_set() - called: visibility=%d\n", visibility);
 
     ret_vis = SP->visibility;
 
@@ -95,5 +95,5 @@ int PDC_set_bold(bool boldon)
 void PDC_set_title( const char *title)
 {
     (void)title;
-    PDC_LOG(("PDC_set_title() - called:<%s>\n", title));
+    PDC_LOG("PDC_set_title() - called:<%s>\n", title);
 }
diff --git a/lib/PDCursesMod/ansi/pdcutil.c b/lib/PDCursesMod/ansi/pdcutil.c
index 271d2880292..60b042526f7 100644
--- a/lib/PDCursesMod/ansi/pdcutil.c
+++ b/lib/PDCursesMod/ansi/pdcutil.c
@@ -1,5 +1,9 @@
-#include <unistd.h>
-#include "curspriv.h"
+#include "../curspriv.h"
+
+#ifdef __U_BOOT__
+#include <watchdog.h>
+#include <linux/delay.h>
+#endif
 
 void PDC_beep(void)
 {
@@ -7,7 +11,11 @@ void PDC_beep(void)
 
 void PDC_napms(int ms)
 {
-    usleep(1000 * ms);
+    // Ensures U-Boot stuff continue happening.
+    // (Yes, this reduces the precision of napms)
+    WATCHDOG_RESET();
+
+    mdelay(ms);
 }
 
 
diff --git a/lib/PDCursesMod/common/pdccolor.c b/lib/PDCursesMod/common/pdccolor.c
index 76671ca9b9b..c770fae28a6 100644
--- a/lib/PDCursesMod/common/pdccolor.c
+++ b/lib/PDCursesMod/common/pdccolor.c
@@ -21,7 +21,7 @@ rationale of how this works.    */
    #define PACK_RGB( red, green, blue) ((red) | ((green)<<8) | ((PACKED_RGB)(blue) << 16))
 #endif
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include "pdccolor.h"
 
 int PDC_blink_state = 0;
diff --git a/lib/PDCursesMod/curspriv.h b/lib/PDCursesMod/curspriv.h
index f33b52d37fa..756f5ef6258 100644
--- a/lib/PDCursesMod/curspriv.h
+++ b/lib/PDCursesMod/curspriv.h
@@ -4,8 +4,10 @@
 #ifndef __CURSES_INTERNALS__
 #define __CURSES_INTERNALS__ 1
 
+#define __U_BOOT__
+
 #define CURSES_LIBRARY
-#include <curses.h>
+#include <PDCurses/curses.h>
 
 #if defined(__TURBOC__) || defined(__EMX__) || defined(__DJGPP__) || \
     defined(PDC_99) || defined(__WATCOMC__)
@@ -20,6 +22,10 @@
 # endif
 #endif
 
+#ifdef __U_BOOT__
+#include <vsprintf.h>
+#endif
+
 /*----------------------------------------------------------------------*/
 
 typedef struct           /* structure for ripped off lines */
@@ -90,15 +96,24 @@ void    PDC_sync(WINDOW *);
 void    PDC_set_default_colors( const int, const int);
 
 #ifdef PDC_WIDE
+#ifdef __U_BOOT__
+#error PDC_WIDE is not supported under U-Boot
+#endif
 int     PDC_mbtowc(wchar_t *, const char *, size_t);
 size_t  PDC_mbstowcs(wchar_t *, const char *, size_t);
 size_t  PDC_wcstombs(char *, const wchar_t *, size_t);
 #endif
 
 #ifdef PDCDEBUG
-# define PDC_LOG(x) if (SP && SP->dbfp) PDC_debug x
+# define PDC_LOG(fmt, args...)   serial_printf(fmt ,##args)
+#else
+# define PDC_LOG(fmt, args...)
+#endif
+
+#ifdef __U_BOOT__
+# define PDC_perror(fmt, args...)   printf ("ERROR: " fmt ,##args)
 #else
-# define PDC_LOG(x)
+# define PDC_perror(fmt, args...)   fprintf (stderr, fmt ,##args)
 #endif
 
 /* Internal macros for attributes */
diff --git a/lib/PDCursesMod/demos/firework.c b/lib/PDCursesMod/demos/firework.c
index 5788fc0263f..1ccc13fa9a0 100644
--- a/lib/PDCursesMod/demos/firework.c
+++ b/lib/PDCursesMod/demos/firework.c
@@ -1,4 +1,4 @@
-#include <curses.h>
+#include <PDCurses/curses.h>
 #include <stdlib.h>
 #include <time.h>
 
diff --git a/lib/PDCursesMod/demos/newtest.c b/lib/PDCursesMod/demos/newtest.c
index 6bc8b87b78f..ec251806d14 100644
--- a/lib/PDCursesMod/demos/newtest.c
+++ b/lib/PDCursesMod/demos/newtest.c
@@ -12,13 +12,13 @@
 #endif
 
 #if defined (PDC_WIDE)
-   #include <curses.h>
+   #include <PDCurses/curses.h>
    #define HAVE_WIDE
 #elif defined (HAVE_NCURSESW)
    #include <ncursesw/curses.h>
    #define HAVE_WIDE
 #else
-   #include <curses.h>
+   #include <PDCurses/curses.h>
 #endif
 
 #include <string.h>
diff --git a/lib/PDCursesMod/demos/ozdemo.c b/lib/PDCursesMod/demos/ozdemo.c
index 11303928c0b..6a07abaaf21 100644
--- a/lib/PDCursesMod/demos/ozdemo.c
+++ b/lib/PDCursesMod/demos/ozdemo.c
@@ -5,7 +5,7 @@
 
 #include <signal.h>
 #include <string.h>
-#include <curses.h>
+#include <PDCurses/curses.h>
 #include <stdlib.h>
 #include <time.h>
 
diff --git a/lib/PDCursesMod/demos/ptest.c b/lib/PDCursesMod/demos/ptest.c
index 3f02f3a9265..9bc759775bd 100644
--- a/lib/PDCursesMod/demos/ptest.c
+++ b/lib/PDCursesMod/demos/ptest.c
@@ -1,5 +1,5 @@
-#include <curses.h>
-#include <panel.h>
+#include <PDCurses/curses.h>
+#include <PDCurses/panel.h>
 #include <stdlib.h>
 
 PANEL *p1, *p2, *p3, *p4, *p5;
diff --git a/lib/PDCursesMod/demos/rain.c b/lib/PDCursesMod/demos/rain.c
index 52349b48513..1174b015f91 100644
--- a/lib/PDCursesMod/demos/rain.c
+++ b/lib/PDCursesMod/demos/rain.c
@@ -26,7 +26,7 @@
  * authorization.                                                           *
  ****************************************************************************/
 
-#include <curses.h>
+#include <PDCurses/curses.h>
 #include <stdlib.h>
 #include <time.h>
 
diff --git a/lib/PDCursesMod/demos/simplemenu.c b/lib/PDCursesMod/demos/simplemenu.c
index c5d238cfa75..a2513b0d32e 100644
--- a/lib/PDCursesMod/demos/simplemenu.c
+++ b/lib/PDCursesMod/demos/simplemenu.c
@@ -1,5 +1,12 @@
-#include <curses.h>
+#include <PDCurses/curses.h>
+
+#ifdef __U_BOOT__
+#include <command.h>
+#include <linux/compat.h>
+#include <vsprintf.h>
+#else
 #include <stdlib.h>
+#endif
 
 #define str(s) #s
 #define xstr(s) str(s)
@@ -92,7 +99,11 @@ void add_entry(menustate *state, char* label) {
 	state->last_entry = entry;
 }
 
+#ifndef __U_BOOT__
 int main(void) {
+#else
+static int do_demo_simplemenu(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[]) {
+#endif
 	menustate state = {
 		.last_entry = NULL,
 		.first_entry = NULL,
@@ -128,7 +139,7 @@ int main(void) {
 
 	mvwin(
 		state.window,
-		(LINES-menu_height)/2,
+		(LINES-menu_height-2)/2,
 		(COLS-menu_width)/2
 	);
 
@@ -173,4 +184,8 @@ int main(void) {
 	delwin(state.window);
 	wrefresh(stdscr);
 	endwin();
+
+	return 0;
 }
+
+U_BOOT_CMD(demo_simplemenu, 1, 0, do_demo_simplemenu, "PDCurses simplemenu demo...", "demo_simplemenu")
diff --git a/lib/PDCursesMod/demos/speed.c b/lib/PDCursesMod/demos/speed.c
index c4401223810..46b46c26d52 100644
--- a/lib/PDCursesMod/demos/speed.c
+++ b/lib/PDCursesMod/demos/speed.c
@@ -1,5 +1,5 @@
 #include <stdio.h>
-#include <curses.h>
+#include <PDCurses/curses.h>
 
 /* PDCurses/ncurses speed test.  Initializes *curses,  displays
 semi-random numbers on the screen for 3000 milliseconds = 3 seconds,
diff --git a/lib/PDCursesMod/demos/test_pan.c b/lib/PDCursesMod/demos/test_pan.c
index bcb23f02d39..a545dc1fdf2 100644
--- a/lib/PDCursesMod/demos/test_pan.c
+++ b/lib/PDCursesMod/demos/test_pan.c
@@ -27,7 +27,7 @@ http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/panels.html
 
 #define PDC_NCMOUSE
 
-#include <panel.h>
+#include <PDCurses/panel.h>
 #include <stdio.h>
 #include <assert.h>
 
diff --git a/lib/PDCursesMod/demos/testcurs.c b/lib/PDCursesMod/demos/testcurs.c
index 4537986683a..bb87572afc5 100644
--- a/lib/PDCursesMod/demos/testcurs.c
+++ b/lib/PDCursesMod/demos/testcurs.c
@@ -14,7 +14,7 @@
 #include <stdlib.h>
 #include <ctype.h>
 #include <string.h>
-#include <curses.h>
+#include <PDCurses/curses.h>
 
 #ifdef WACS_S1
 # define HAVE_WIDE 1
diff --git a/lib/PDCursesMod/demos/triangles.c b/lib/PDCursesMod/demos/triangles.c
index f7e96bacfa5..d84db62c888 100644
--- a/lib/PDCursesMod/demos/triangles.c
+++ b/lib/PDCursesMod/demos/triangles.c
@@ -1,4 +1,4 @@
-#include <curses.h>
+#include <PDCurses/curses.h>
 #include <stdlib.h>
 #include <sys/random.h>
 
diff --git a/lib/PDCursesMod/demos/tui.c b/lib/PDCursesMod/demos/tui.c
index 751daf9c71e..b5621fbc6ec 100644
--- a/lib/PDCursesMod/demos/tui.c
+++ b/lib/PDCursesMod/demos/tui.c
@@ -7,7 +7,7 @@
  */
 
 #include <ctype.h>
-#include <curses.h>
+#include <PDCurses/curses.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -18,9 +18,11 @@ void statusmsg(char *);
 int waitforkey(void);
 void rmerror(void);
 
+#ifndef __U_BOOT__
 #if defined(__unix) && !defined(__DJGPP__)
 #include <unistd.h>
 #endif
+#endif
 
 #ifdef A_COLOR
 # define TITLECOLOR       1       /* color pair indices */
@@ -167,6 +169,9 @@ static void colorbox(WINDOW *win, chtype color, int hasbox)
 static void idle(void)
 {
     char buf[MAXSTRLEN];
+#ifdef __U_BOOT__
+    sprintf(buf, " No time :( ");
+#else
     time_t t;
     struct tm *tp;
 
@@ -177,6 +182,7 @@ static void idle(void)
     sprintf(buf, " %.4d-%.2d-%.2d  %.2d:%.2d:%.2d",
             tp->tm_year + 1900, tp->tm_mon + 1, tp->tm_mday,
             tp->tm_hour, tp->tm_min, tp->tm_sec);
+#endif
 
     mvwaddstr(wtitl, 0, bw - (int)strlen(buf) - 2, buf);
     wrefresh(wtitl);
diff --git a/lib/PDCursesMod/demos/tui.h b/lib/PDCursesMod/demos/tui.h
index 98bfd5f25b6..d4af9afcdc8 100644
--- a/lib/PDCursesMod/demos/tui.h
+++ b/lib/PDCursesMod/demos/tui.h
@@ -8,7 +8,7 @@
 #ifndef _TUI_H_
 #define _TUI_H_
 
-#include <curses.h>
+#include <PDCurses/curses.h>
 
 #ifdef A_COLOR
 #define A_ATTR  (A_ATTRIBUTES ^ A_COLOR)  /* A_BLINK, A_REVERSE, A_BOLD */
diff --git a/lib/PDCursesMod/demos/tuidemo.c b/lib/PDCursesMod/demos/tuidemo.c
index 585e348aca5..75b5e2b3e60 100644
--- a/lib/PDCursesMod/demos/tuidemo.c
+++ b/lib/PDCursesMod/demos/tuidemo.c
@@ -14,8 +14,14 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <locale.h>
 #include "tui.h"
+#ifdef __U_BOOT__
+#include <command.h>
+#include <linux/compat.h>
+#include <vsprintf.h>
+#else
+#include <locale.h>
+#endif
 
 /* change this if source at other location */
 
@@ -72,6 +78,7 @@ char *getfname(char *desc, char *fname, int field)
 
 void showfile(char *fname)
 {
+#ifndef __U_BOOT__
     int i, bh = bodylen();
     FILE *fp;
     char buf[MAXSTRLEN];
@@ -109,6 +116,7 @@ void showfile(char *fname)
         sprintf(buf, "ERROR: file '%s' not found", fname);
         errormsg(buf);
     }
+#endif
 }
 
 /***************************** forward declarations ***********************/
@@ -218,11 +226,16 @@ void subsub(void)
 
 /***************************** start main menu  ***************************/
 
-int main( void)
-{
+#ifndef __U_BOOT__
+int main(void) {
     setlocale(LC_ALL, "");
+#else
+static int do_demo_tui(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[]) {
+#endif
 
     startmenu(MainMenu, "TUI - 'textual user interface' demonstration program");
 
     return 0;
 }
+
+U_BOOT_CMD(demo_tui, 1, 0, do_demo_tui, "PDCurses TUI demo...", "demo_tui")
diff --git a/lib/PDCursesMod/demos/version.c b/lib/PDCursesMod/demos/version.c
index 41a0d060ab0..8300f989f15 100644
--- a/lib/PDCursesMod/demos/version.c
+++ b/lib/PDCursesMod/demos/version.c
@@ -1,5 +1,5 @@
 #include <stdio.h>
-#include <curses.h>
+#include <PDCurses/curses.h>
 
 /* Example usage of the PDC_get_version function declared in curses.h.  The
 general idea is that,  while we have various macros defined to tell us
diff --git a/lib/PDCursesMod/demos/worm.c b/lib/PDCursesMod/demos/worm.c
index 5102ab601c3..a940e162751 100644
--- a/lib/PDCursesMod/demos/worm.c
+++ b/lib/PDCursesMod/demos/worm.c
@@ -52,7 +52,7 @@ Options:
         -t                      make worms leave droppings
 */
 
-#include <curses.h>
+#include <PDCurses/curses.h>
 #include <stdlib.h>
 #include <time.h>
 
diff --git a/lib/PDCursesMod/demos/xmas.c b/lib/PDCursesMod/demos/xmas.c
index 99b2dd85a6c..2530e399ef6 100644
--- a/lib/PDCursesMod/demos/xmas.c
+++ b/lib/PDCursesMod/demos/xmas.c
@@ -44,7 +44,7 @@
 /*                                                                            */
 /******************************************************************************/
 
-#include <curses.h>
+#include <PDCurses/curses.h>
 
 void lil(WINDOW *);
 void midtop(WINDOW *);
diff --git a/lib/PDCursesMod/curses.h b/lib/PDCursesMod/include/PDCurses/curses.h
similarity index 99%
rename from lib/PDCursesMod/curses.h
rename to lib/PDCursesMod/include/PDCurses/curses.h
index b858f85110b..ea6662a434e 100644
--- a/lib/PDCursesMod/curses.h
+++ b/lib/PDCursesMod/include/PDCurses/curses.h
@@ -5,6 +5,8 @@
 #ifndef __PDCURSES__
 #define __PDCURSES__ 1
 
+#define __U_BOOT__
+
 /*man-start**************************************************************
 
 Define before inclusion (only those needed):
@@ -414,7 +416,9 @@ typedef struct
     short line_color;     /* color of line attributes - default -1 */
     attr_t termattrs;     /* attribute capabilities */
     WINDOW *lastscr;      /* the last screen image */
+#ifndef __U_BOOT__
     FILE *dbfp;           /* debug trace file pointer */
+#endif
     bool  color_started;  /* TRUE after start_color() */
     bool  dirty;          /* redraw on napms() after init_color() */
     int   sel_start;      /* start of selection (y * COLS + x) */
@@ -1254,7 +1258,9 @@ PDCEX  int     flushinp(void);
 PDCEX  chtype  getbkgd(WINDOW *);
 PDCEX  int     getnstr(char *, int);
 PDCEX  int     getstr(char *);
+#ifndef __U_BOOT__
 PDCEX  WINDOW *getwin(FILE *);
+#endif
 PDCEX  int     halfdelay(int);
 PDCEX  bool    has_colors(void);
 PDCEX  bool    has_ic(void);
@@ -1361,7 +1367,9 @@ PDCEX  int     mvwscanw(WINDOW *, int, int, const char *, ...);
 PDCEX  int     mvwvline(WINDOW *, int, int, chtype, int);
 PDCEX  int     napms(int);
 PDCEX  WINDOW *newpad(int, int);
+#ifndef __U_BOOT__
 PDCEX  SCREEN *newterm(const char *, FILE *, FILE *);
+#endif
 PDCEX  WINDOW *newwin(int, int, int, int);
 PDCEX  int     nl(void);
 PDCEX  int     nocbreak(void);
@@ -1378,7 +1386,9 @@ PDCEX  int     pechochar(WINDOW *, chtype);
 PDCEX  int     pnoutrefresh(WINDOW *, int, int, int, int, int, int);
 PDCEX  int     prefresh(WINDOW *, int, int, int, int, int, int);
 PDCEX  int     printw(const char *, ...);
+#ifndef __U_BOOT__
 PDCEX  int     putwin(WINDOW *, FILE *);
+#endif
 PDCEX  void    qiflush(void);
 PDCEX  int     raw(void);
 PDCEX  int     redrawwin(WINDOW *);
@@ -1391,8 +1401,10 @@ PDCEX  int     savetty(void);
 PDCEX  int     scanw(const char *, ...);
 PDCEX  int     scr_dump(const char *);
 PDCEX  int     scr_init(const char *);
+#ifndef __U_BOOT__
 PDCEX  int     scr_restore(const char *);
 PDCEX  int     scr_set(const char *);
+#endif
 PDCEX  int     scrl(int);
 PDCEX  int     scroll(WINDOW *);
 PDCEX  int     scrollok(WINDOW *, bool);
diff --git a/lib/PDCursesMod/panel.h b/lib/PDCursesMod/include/PDCurses/panel.h
similarity index 98%
rename from lib/PDCursesMod/panel.h
rename to lib/PDCursesMod/include/PDCurses/panel.h
index 57ff06d4148..9779af6cf2f 100644
--- a/lib/PDCursesMod/panel.h
+++ b/lib/PDCursesMod/include/PDCurses/panel.h
@@ -7,7 +7,7 @@
 #ifndef __PDCURSES_PANEL_H__
 #define __PDCURSES_PANEL_H__ 1
 
-#include <curses.h>
+#include <PDCurses/curses.h>
 
 #if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
 extern "C"
diff --git a/lib/PDCursesMod/include/assert.h b/lib/PDCursesMod/include/assert.h
new file mode 100644
index 00000000000..0fa2a78d5be
--- /dev/null
+++ b/lib/PDCursesMod/include/assert.h
@@ -0,0 +1,7 @@
+// Shim to reduce changes
+#ifndef __PDCURSES_ASSERT_H
+#define __PDCURSES_ASSERT_H
+
+#include <log.h>
+
+#endif
diff --git a/lib/PDCursesMod/include/limits.h b/lib/PDCursesMod/include/limits.h
new file mode 100644
index 00000000000..4139dc7df9e
--- /dev/null
+++ b/lib/PDCursesMod/include/limits.h
@@ -0,0 +1,7 @@
+// Shim to reduce changes
+#ifndef __PDCURSES_LIMIT_H
+#define __PDCURSES_LIMIT_H
+
+#include <linux/kernel.h>
+
+#endif
diff --git a/lib/PDCursesMod/include/wchar.h b/lib/PDCursesMod/include/wchar.h
new file mode 100644
index 00000000000..20ef8aadb31
--- /dev/null
+++ b/lib/PDCursesMod/include/wchar.h
@@ -0,0 +1,7 @@
+// Shim to reduce changes
+#ifndef __PDCURSES_WCHAR_H
+#define __PDCURSES_WCHAR_H
+
+#include <inttypes.h>
+
+#endif
diff --git a/lib/PDCursesMod/pdcurses/addch.c b/lib/PDCursesMod/pdcurses/addch.c
index 75011ace198..89201fed4d7 100644
--- a/lib/PDCursesMod/pdcurses/addch.c
+++ b/lib/PDCursesMod/pdcurses/addch.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -376,8 +376,8 @@ int waddch( WINDOW *win, const chtype ch)
     chtype text, attr;
     bool xlat;
 
-    PDC_LOG(("waddch() - called: win=%p ch=%x (text=%c attr=0x%x)\n",
-             win, ch, ch & A_CHARTEXT, ch & A_ATTRIBUTES));
+    PDC_LOG("waddch() - called: win=%p ch=%x (text=%c attr=0x%x)\n",
+             win, ch, ch & A_CHARTEXT, ch & A_ATTRIBUTES);
 
     assert( SP);
     assert( win);
@@ -559,14 +559,14 @@ int waddch( WINDOW *win, const chtype ch)
 
 int addch(const chtype ch)
 {
-    PDC_LOG(("addch() - called: ch=%x\n", ch));
+    PDC_LOG("addch() - called: ch=%x\n", ch);
 
     return waddch(stdscr, ch);
 }
 
 int mvaddch(int y, int x, const chtype ch)
 {
-    PDC_LOG(("mvaddch() - called: y=%d x=%d ch=%x\n", y, x, ch));
+    PDC_LOG("mvaddch() - called: y=%d x=%d ch=%x\n", y, x, ch);
 
     if (move(y,x) == ERR)
         return ERR;
@@ -576,7 +576,7 @@ int mvaddch(int y, int x, const chtype ch)
 
 int mvwaddch(WINDOW *win, int y, int x, const chtype ch)
 {
-    PDC_LOG(("mvwaddch() - called: win=%p y=%d x=%d ch=%d\n", win, y, x, ch));
+    PDC_LOG("mvwaddch() - called: win=%p y=%d x=%d ch=%d\n", win, y, x, ch);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -586,14 +586,14 @@ int mvwaddch(WINDOW *win, int y, int x, const chtype ch)
 
 int echochar(const chtype ch)
 {
-    PDC_LOG(("echochar() - called: ch=%x\n", ch));
+    PDC_LOG("echochar() - called: ch=%x\n", ch);
 
     return wechochar(stdscr, ch);
 }
 
 int wechochar(WINDOW *win, const chtype ch)
 {
-    PDC_LOG(("wechochar() - called: win=%p ch=%x\n", win, ch));
+    PDC_LOG("wechochar() - called: win=%p ch=%x\n", win, ch);
 
     if (waddch(win, ch) == ERR)
         return ERR;
@@ -603,8 +603,8 @@ int wechochar(WINDOW *win, const chtype ch)
 
 int waddrawch(WINDOW *win, chtype ch)
 {
-    PDC_LOG(("waddrawch() - called: win=%p ch=%x (text=%c attr=0x%x)\n",
-             win, ch, ch & A_CHARTEXT, ch & A_ATTRIBUTES));
+    PDC_LOG("waddrawch() - called: win=%p ch=%x (text=%c attr=0x%x)\n",
+             win, ch, ch & A_CHARTEXT, ch & A_ATTRIBUTES);
 
     if ((ch & A_CHARTEXT) < ' ' || (ch & A_CHARTEXT) == 0x7f)
         ch |= A_ALTCHARSET;
@@ -614,14 +614,14 @@ int waddrawch(WINDOW *win, chtype ch)
 
 int addrawch(chtype ch)
 {
-    PDC_LOG(("addrawch() - called: ch=%x\n", ch));
+    PDC_LOG("addrawch() - called: ch=%x\n", ch);
 
     return waddrawch(stdscr, ch);
 }
 
 int mvaddrawch(int y, int x, chtype ch)
 {
-    PDC_LOG(("mvaddrawch() - called: y=%d x=%d ch=%d\n", y, x, ch));
+    PDC_LOG("mvaddrawch() - called: y=%d x=%d ch=%d\n", y, x, ch);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -631,8 +631,8 @@ int mvaddrawch(int y, int x, chtype ch)
 
 int mvwaddrawch(WINDOW *win, int y, int x, chtype ch)
 {
-    PDC_LOG(("mvwaddrawch() - called: win=%p y=%d x=%d ch=%d\n",
-             win, y, x, ch));
+    PDC_LOG("mvwaddrawch() - called: win=%p y=%d x=%d ch=%d\n",
+             win, y, x, ch);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -643,7 +643,7 @@ int mvwaddrawch(WINDOW *win, int y, int x, chtype ch)
 #ifdef PDC_WIDE
 int wadd_wch(WINDOW *win, const cchar_t *wch)
 {
-    PDC_LOG(("wadd_wch() - called: win=%p wch=%x\n", win, *wch));
+    PDC_LOG("wadd_wch() - called: win=%p wch=%x\n", win, *wch);
 
     assert( wch);
     return wch ? waddch(win, *wch) : ERR;
@@ -651,14 +651,14 @@ int wadd_wch(WINDOW *win, const cchar_t *wch)
 
 int add_wch(const cchar_t *wch)
 {
-    PDC_LOG(("add_wch() - called: wch=%x\n", *wch));
+    PDC_LOG("add_wch() - called: wch=%x\n", *wch);
 
     return wadd_wch(stdscr, wch);
 }
 
 int mvadd_wch(int y, int x, const cchar_t *wch)
 {
-    PDC_LOG(("mvaddch() - called: y=%d x=%d wch=%x\n", y, x, *wch));
+    PDC_LOG("mvaddch() - called: y=%d x=%d wch=%x\n", y, x, *wch);
 
     if (move(y,x) == ERR)
         return ERR;
@@ -668,8 +668,8 @@ int mvadd_wch(int y, int x, const cchar_t *wch)
 
 int mvwadd_wch(WINDOW *win, int y, int x, const cchar_t *wch)
 {
-    PDC_LOG(("mvwaddch() - called: win=%p y=%d x=%d wch=%d\n",
-             win, y, x, *wch));
+    PDC_LOG("mvwaddch() - called: win=%p y=%d x=%d wch=%d\n",
+             win, y, x, *wch);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -679,14 +679,14 @@ int mvwadd_wch(WINDOW *win, int y, int x, const cchar_t *wch)
 
 int echo_wchar(const cchar_t *wch)
 {
-    PDC_LOG(("echo_wchar() - called: wch=%x\n", *wch));
+    PDC_LOG("echo_wchar() - called: wch=%x\n", *wch);
 
     return wecho_wchar(stdscr, wch);
 }
 
 int wecho_wchar(WINDOW *win, const cchar_t *wch)
 {
-    PDC_LOG(("wecho_wchar() - called: win=%p wch=%x\n", win, *wch));
+    PDC_LOG("wecho_wchar() - called: win=%p wch=%x\n", win, *wch);
 
     assert( wch);
     if (!wch || (wadd_wch(win, wch) == ERR))
diff --git a/lib/PDCursesMod/pdcurses/addchstr.c b/lib/PDCursesMod/pdcurses/addchstr.c
index 9f2f7642138..b4f1d1d8975 100644
--- a/lib/PDCursesMod/pdcurses/addchstr.c
+++ b/lib/PDCursesMod/pdcurses/addchstr.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -73,7 +73,7 @@ int waddchnstr(WINDOW *win, const chtype *ch, int n)
     int y, x, maxx, minx;
     chtype *ptr;
 
-    PDC_LOG(("waddchnstr() - called: win=%p n=%d\n", win, n));
+    PDC_LOG("waddchnstr() - called: win=%p n=%d\n", win, n);
 
     assert( win);
     assert( ch);
@@ -100,10 +100,10 @@ int waddchnstr(WINDOW *win, const chtype *ch, int n)
             if (x > maxx)
                 maxx = x;
 
-            PDC_LOG(("y %d x %d minx %d maxx %d *ptr %x *ch"
+            PDC_LOG("y %d x %d minx %d maxx %d *ptr %x *ch"
                      " %x firstch: %d lastch: %d\n",
                      y, x, minx, maxx, *ptr, *ch,
-                     win->_firstch[y], win->_lastch[y]));
+                     win->_firstch[y], win->_lastch[y]);
 
             *ptr = *ch;
         }
@@ -117,28 +117,28 @@ int waddchnstr(WINDOW *win, const chtype *ch, int n)
 
 int addchstr(const chtype *ch)
 {
-    PDC_LOG(("addchstr() - called\n"));
+    PDC_LOG("addchstr() - called\n");
 
     return waddchnstr(stdscr, ch, -1);
 }
 
 int addchnstr(const chtype *ch, int n)
 {
-    PDC_LOG(("addchnstr() - called\n"));
+    PDC_LOG("addchnstr() - called\n");
 
     return waddchnstr(stdscr, ch, n);
 }
 
 int waddchstr(WINDOW *win, const chtype *ch)
 {
-    PDC_LOG(("waddchstr() - called: win=%p\n", win));
+    PDC_LOG("waddchstr() - called: win=%p\n", win);
 
     return waddchnstr(win, ch, -1);
 }
 
 int mvaddchstr(int y, int x, const chtype *ch)
 {
-    PDC_LOG(("mvaddchstr() - called: y %d x %d\n", y, x));
+    PDC_LOG("mvaddchstr() - called: y %d x %d\n", y, x);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -148,7 +148,7 @@ int mvaddchstr(int y, int x, const chtype *ch)
 
 int mvaddchnstr(int y, int x, const chtype *ch, int n)
 {
-    PDC_LOG(("mvaddchnstr() - called: y %d x %d n %d\n", y, x, n));
+    PDC_LOG("mvaddchnstr() - called: y %d x %d n %d\n", y, x, n);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -158,7 +158,7 @@ int mvaddchnstr(int y, int x, const chtype *ch, int n)
 
 int mvwaddchstr(WINDOW *win, int y, int x, const chtype *ch)
 {
-    PDC_LOG(("mvwaddchstr() - called:\n"));
+    PDC_LOG("mvwaddchstr() - called:\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -168,7 +168,7 @@ int mvwaddchstr(WINDOW *win, int y, int x, const chtype *ch)
 
 int mvwaddchnstr(WINDOW *win, int y, int x, const chtype *ch, int n)
 {
-    PDC_LOG(("mvwaddchnstr() - called: y %d x %d n %d \n", y, x, n));
+    PDC_LOG("mvwaddchnstr() - called: y %d x %d n %d \n", y, x, n);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -179,35 +179,35 @@ int mvwaddchnstr(WINDOW *win, int y, int x, const chtype *ch, int n)
 #ifdef PDC_WIDE
 int wadd_wchnstr(WINDOW *win, const cchar_t *wch, int n)
 {
-    PDC_LOG(("wadd_wchnstr() - called: win=%p n=%d\n", win, n));
+    PDC_LOG("wadd_wchnstr() - called: win=%p n=%d\n", win, n);
 
     return waddchnstr(win, wch, n);
 }
 
 int add_wchstr(const cchar_t *wch)
 {
-    PDC_LOG(("add_wchstr() - called\n"));
+    PDC_LOG("add_wchstr() - called\n");
 
     return wadd_wchnstr(stdscr, wch, -1);
 }
 
 int add_wchnstr(const cchar_t *wch, int n)
 {
-    PDC_LOG(("add_wchnstr() - called\n"));
+    PDC_LOG("add_wchnstr() - called\n");
 
     return wadd_wchnstr(stdscr, wch, n);
 }
 
 int wadd_wchstr(WINDOW *win, const cchar_t *wch)
 {
-    PDC_LOG(("wadd_wchstr() - called: win=%p\n", win));
+    PDC_LOG("wadd_wchstr() - called: win=%p\n", win);
 
     return wadd_wchnstr(win, wch, -1);
 }
 
 int mvadd_wchstr(int y, int x, const cchar_t *wch)
 {
-    PDC_LOG(("mvadd_wchstr() - called: y %d x %d\n", y, x));
+    PDC_LOG("mvadd_wchstr() - called: y %d x %d\n", y, x);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -217,7 +217,7 @@ int mvadd_wchstr(int y, int x, const cchar_t *wch)
 
 int mvadd_wchnstr(int y, int x, const cchar_t *wch, int n)
 {
-    PDC_LOG(("mvadd_wchnstr() - called: y %d x %d n %d\n", y, x, n));
+    PDC_LOG("mvadd_wchnstr() - called: y %d x %d n %d\n", y, x, n);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -227,7 +227,7 @@ int mvadd_wchnstr(int y, int x, const cchar_t *wch, int n)
 
 int mvwadd_wchstr(WINDOW *win, int y, int x, const cchar_t *wch)
 {
-    PDC_LOG(("mvwadd_wchstr() - called:\n"));
+    PDC_LOG("mvwadd_wchstr() - called:\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -237,7 +237,7 @@ int mvwadd_wchstr(WINDOW *win, int y, int x, const cchar_t *wch)
 
 int mvwadd_wchnstr(WINDOW *win, int y, int x, const cchar_t *wch, int n)
 {
-    PDC_LOG(("mvwadd_wchnstr() - called: y %d x %d n %d \n", y, x, n));
+    PDC_LOG("mvwadd_wchnstr() - called: y %d x %d n %d \n", y, x, n);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/addstr.c b/lib/PDCursesMod/pdcurses/addstr.c
index 86151c7055a..7d60b982aee 100644
--- a/lib/PDCursesMod/pdcurses/addstr.c
+++ b/lib/PDCursesMod/pdcurses/addstr.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -68,7 +68,7 @@ int waddnstr(WINDOW *win, const char *str, int n)
 {
     int i = 0;
 
-    PDC_LOG(("waddnstr() - called: string=\"%s\" n %d \n", str, n));
+    PDC_LOG("waddnstr() - called: string=\"%s\" n %d \n", str, n);
 
     assert( win);
     assert( str);
@@ -97,28 +97,28 @@ int waddnstr(WINDOW *win, const char *str, int n)
 
 int addstr(const char *str)
 {
-    PDC_LOG(("addstr() - called: string=\"%s\"\n", str));
+    PDC_LOG("addstr() - called: string=\"%s\"\n", str);
 
     return waddnstr(stdscr, str, -1);
 }
 
 int addnstr(const char *str, int n)
 {
-    PDC_LOG(("addnstr() - called: string=\"%s\" n %d \n", str, n));
+    PDC_LOG("addnstr() - called: string=\"%s\" n %d \n", str, n);
 
     return waddnstr(stdscr, str, n);
 }
 
 int waddstr(WINDOW *win, const char *str)
 {
-    PDC_LOG(("waddstr() - called: string=\"%s\"\n", str));
+    PDC_LOG("waddstr() - called: string=\"%s\"\n", str);
 
     return waddnstr(win, str, -1);
 }
 
 int mvaddstr(int y, int x, const char *str)
 {
-    PDC_LOG(("mvaddstr() - called: y %d x %d string=\"%s\"\n", y, x, str));
+    PDC_LOG("mvaddstr() - called: y %d x %d string=\"%s\"\n", y, x, str);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -128,8 +128,8 @@ int mvaddstr(int y, int x, const char *str)
 
 int mvaddnstr(int y, int x, const char *str, int n)
 {
-    PDC_LOG(("mvaddnstr() - called: y %d x %d string=\"%s\" n %d \n",
-             y, x, str, n));
+    PDC_LOG("mvaddnstr() - called: y %d x %d string=\"%s\" n %d \n",
+             y, x, str, n);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -139,7 +139,7 @@ int mvaddnstr(int y, int x, const char *str, int n)
 
 int mvwaddstr(WINDOW *win, int y, int x, const char *str)
 {
-    PDC_LOG(("mvwaddstr() - called: string=\"%s\"\n", str));
+    PDC_LOG("mvwaddstr() - called: string=\"%s\"\n", str);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -149,8 +149,8 @@ int mvwaddstr(WINDOW *win, int y, int x, const char *str)
 
 int mvwaddnstr(WINDOW *win, int y, int x, const char *str, int n)
 {
-    PDC_LOG(("mvwaddnstr() - called: y %d x %d string=\"%s\" n %d \n",
-             y, x, str, n));
+    PDC_LOG("mvwaddnstr() - called: y %d x %d string=\"%s\" n %d \n",
+             y, x, str, n);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -163,7 +163,7 @@ int waddnwstr(WINDOW *win, const wchar_t *wstr, int n)
 {
     int i = 0;
 
-    PDC_LOG(("waddnwstr() - called\n"));
+    PDC_LOG("waddnwstr() - called\n");
 
     assert( win);
     assert( wstr);
@@ -184,28 +184,28 @@ int waddnwstr(WINDOW *win, const wchar_t *wstr, int n)
 
 int addwstr(const wchar_t *wstr)
 {
-    PDC_LOG(("addwstr() - called\n"));
+    PDC_LOG("addwstr() - called\n");
 
     return waddnwstr(stdscr, wstr, -1);
 }
 
 int addnwstr(const wchar_t *wstr, int n)
 {
-    PDC_LOG(("addnwstr() - called\n"));
+    PDC_LOG("addnwstr() - called\n");
 
     return waddnwstr(stdscr, wstr, n);
 }
 
 int waddwstr(WINDOW *win, const wchar_t *wstr)
 {
-    PDC_LOG(("waddwstr() - called\n"));
+    PDC_LOG("waddwstr() - called\n");
 
     return waddnwstr(win, wstr, -1);
 }
 
 int mvaddwstr(int y, int x, const wchar_t *wstr)
 {
-    PDC_LOG(("mvaddstr() - called\n"));
+    PDC_LOG("mvaddstr() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -215,7 +215,7 @@ int mvaddwstr(int y, int x, const wchar_t *wstr)
 
 int mvaddnwstr(int y, int x, const wchar_t *wstr, int n)
 {
-    PDC_LOG(("mvaddnstr() - called\n"));
+    PDC_LOG("mvaddnstr() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -225,7 +225,7 @@ int mvaddnwstr(int y, int x, const wchar_t *wstr, int n)
 
 int mvwaddwstr(WINDOW *win, int y, int x, const wchar_t *wstr)
 {
-    PDC_LOG(("mvwaddstr() - called\n"));
+    PDC_LOG("mvwaddstr() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -235,7 +235,7 @@ int mvwaddwstr(WINDOW *win, int y, int x, const wchar_t *wstr)
 
 int mvwaddnwstr(WINDOW *win, int y, int x, const wchar_t *wstr, int n)
 {
-    PDC_LOG(("mvwaddnstr() - called\n"));
+    PDC_LOG("mvwaddnstr() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/attr.c b/lib/PDCursesMod/pdcurses/attr.c
index b09e40d7b44..67678d160ae 100644
--- a/lib/PDCursesMod/pdcurses/attr.c
+++ b/lib/PDCursesMod/pdcurses/attr.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -55,7 +55,7 @@ attr
    These functions manipulate the current attributes and/or colors of
    the named window. These attributes can be any combination of
    A_STANDOUT, A_REVERSE, A_BOLD, A_DIM, A_BLINK, A_UNDERLINE. These
-   constants are defined in <curses.h> and can be combined with the
+   constants are defined in <PDCurses/curses.h> and can be combined with the
    bitwise-OR operator (|).
 
    The current attributes of a window are applied to all chtypes that
@@ -132,7 +132,7 @@ attr
 
 int wattroff(WINDOW *win, chtype attrs)
 {
-    PDC_LOG(("wattroff() - called\n"));
+    PDC_LOG("wattroff() - called\n");
 
     assert( win);
     if (!win)
@@ -145,7 +145,7 @@ int wattroff(WINDOW *win, chtype attrs)
 
 int attroff(chtype attrs)
 {
-    PDC_LOG(("attroff() - called\n"));
+    PDC_LOG("attroff() - called\n");
 
     return wattroff(stdscr, attrs);
 }
@@ -154,7 +154,7 @@ int wattron(WINDOW *win, chtype attrs)
 {
     chtype newcolr, oldcolr, newattr, oldattr;
 
-    PDC_LOG(("wattron() - called\n"));
+    PDC_LOG("wattron() - called\n");
 
     assert( win);
     if (!win)
@@ -177,14 +177,14 @@ int wattron(WINDOW *win, chtype attrs)
 
 int attron(chtype attrs)
 {
-    PDC_LOG(("attron() - called\n"));
+    PDC_LOG("attron() - called\n");
 
     return wattron(stdscr, attrs);
 }
 
 int wattrset(WINDOW *win, chtype attrs)
 {
-    PDC_LOG(("wattrset() - called\n"));
+    PDC_LOG("wattrset() - called\n");
 
     assert( win);
     if (!win)
@@ -197,35 +197,35 @@ int wattrset(WINDOW *win, chtype attrs)
 
 int attrset(chtype attrs)
 {
-    PDC_LOG(("attrset() - called\n"));
+    PDC_LOG("attrset() - called\n");
 
     return wattrset(stdscr, attrs);
 }
 
 int standend(void)
 {
-    PDC_LOG(("standend() - called\n"));
+    PDC_LOG("standend() - called\n");
 
     return wattrset(stdscr, A_NORMAL);
 }
 
 int standout(void)
 {
-    PDC_LOG(("standout() - called\n"));
+    PDC_LOG("standout() - called\n");
 
     return wattrset(stdscr, A_STANDOUT);
 }
 
 int wstandend(WINDOW *win)
 {
-    PDC_LOG(("wstandend() - called\n"));
+    PDC_LOG("wstandend() - called\n");
 
     return wattrset(win, A_NORMAL);
 }
 
 int wstandout(WINDOW *win)
 {
-    PDC_LOG(("wstandout() - called\n"));
+    PDC_LOG("wstandout() - called\n");
 
     return wattrset(win, A_STANDOUT);
 }
@@ -238,7 +238,7 @@ chtype getattrs(WINDOW *win)
 
 int wcolor_set(WINDOW *win, short color_pair, void *opts)
 {
-    PDC_LOG(("wcolor_set() - called\n"));
+    PDC_LOG("wcolor_set() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( opts);
     assert( win);
@@ -252,14 +252,14 @@ int wcolor_set(WINDOW *win, short color_pair, void *opts)
 
 int color_set(short color_pair, void *opts)
 {
-    PDC_LOG(("color_set() - called\n"));
+    PDC_LOG("color_set() - called\n");
 
     return wcolor_set(stdscr, color_pair, opts);
 }
 
 int wattr_get(WINDOW *win, attr_t *attrs, short *color_pair, void *opts)
 {
-    PDC_LOG(("wattr_get() - called\n"));
+    PDC_LOG("wattr_get() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( opts);
     assert( win);
@@ -277,14 +277,14 @@ int wattr_get(WINDOW *win, attr_t *attrs, short *color_pair, void *opts)
 
 int attr_get(attr_t *attrs, short *color_pair, void *opts)
 {
-    PDC_LOG(("attr_get() - called\n"));
+    PDC_LOG("attr_get() - called\n");
 
     return wattr_get(stdscr, attrs, color_pair, opts);
 }
 
 int wattr_off(WINDOW *win, attr_t attrs, void *opts)
 {
-    PDC_LOG(("wattr_off() - called\n"));
+    PDC_LOG("wattr_off() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( opts);
     return wattroff(win, attrs);
@@ -292,7 +292,7 @@ int wattr_off(WINDOW *win, attr_t attrs, void *opts)
 
 int attr_off(attr_t attrs, void *opts)
 {
-    PDC_LOG(("attr_off() - called\n"));
+    PDC_LOG("attr_off() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( opts);
     return wattroff(stdscr, attrs);
@@ -300,7 +300,7 @@ int attr_off(attr_t attrs, void *opts)
 
 int wattr_on(WINDOW *win, attr_t attrs, void *opts)
 {
-    PDC_LOG(("wattr_off() - called\n"));
+    PDC_LOG("wattr_off() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( opts);
     return wattron(win, attrs);
@@ -308,7 +308,7 @@ int wattr_on(WINDOW *win, attr_t attrs, void *opts)
 
 int attr_on(attr_t attrs, void *opts)
 {
-    PDC_LOG(("attr_on() - called\n"));
+    PDC_LOG("attr_on() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( opts);
     return wattron(stdscr, attrs);
@@ -316,7 +316,7 @@ int attr_on(attr_t attrs, void *opts)
 
 int wattr_set(WINDOW *win, attr_t attrs, short color_pair, void *opts)
 {
-    PDC_LOG(("wattr_set() - called\n"));
+    PDC_LOG("wattr_set() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( opts);
     assert( win);
@@ -330,7 +330,7 @@ int wattr_set(WINDOW *win, attr_t attrs, short color_pair, void *opts)
 
 int attr_set(attr_t attrs, short color_pair, void *opts)
 {
-    PDC_LOG(("attr_get() - called\n"));
+    PDC_LOG("attr_get() - called\n");
 
     return wattr_set(stdscr, attrs, color_pair, opts);
 }
@@ -341,7 +341,7 @@ int wchgat(WINDOW *win, int n, attr_t attr, short color, const void *opts)
     int startpos, endpos;
 
     INTENTIONALLY_UNUSED_PARAMETER( opts);
-    PDC_LOG(("wchgat() - called\n"));
+    PDC_LOG("wchgat() - called\n");
 
     assert( win);
     if (!win)
@@ -371,14 +371,14 @@ int wchgat(WINDOW *win, int n, attr_t attr, short color, const void *opts)
 
 int chgat(int n, attr_t attr, short color, const void *opts)
 {
-    PDC_LOG(("chgat() - called\n"));
+    PDC_LOG("chgat() - called\n");
 
     return wchgat(stdscr, n, attr, color, opts);
 }
 
 int mvchgat(int y, int x, int n, attr_t attr, short color, const void *opts)
 {
-    PDC_LOG(("mvchgat() - called\n"));
+    PDC_LOG("mvchgat() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -389,7 +389,7 @@ int mvchgat(int y, int x, int n, attr_t attr, short color, const void *opts)
 int mvwchgat(WINDOW *win, int y, int x, int n, attr_t attr, short color,
              const void *opts)
 {
-    PDC_LOG(("mvwchgat() - called\n"));
+    PDC_LOG("mvwchgat() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -399,28 +399,28 @@ int mvwchgat(WINDOW *win, int y, int x, int n, attr_t attr, short color,
 
 int underend(void)
 {
-    PDC_LOG(("underend() - called\n"));
+    PDC_LOG("underend() - called\n");
 
     return wattroff(stdscr, A_UNDERLINE);
 }
 
 int wunderend(WINDOW *win)
 {
-    PDC_LOG(("wunderend() - called\n"));
+    PDC_LOG("wunderend() - called\n");
 
     return wattroff(win, A_UNDERLINE);
 }
 
 int underscore(void)
 {
-    PDC_LOG(("underscore() - called\n"));
+    PDC_LOG("underscore() - called\n");
 
     return wattron(stdscr, A_UNDERLINE);
 }
 
 int wunderscore(WINDOW *win)
 {
-    PDC_LOG(("wunderscore() - called\n"));
+    PDC_LOG("wunderscore() - called\n");
 
     return wattron(win, A_UNDERLINE);
 }
diff --git a/lib/PDCursesMod/pdcurses/beep.c b/lib/PDCursesMod/pdcurses/beep.c
index 21b138adc58..856bff9a3dc 100644
--- a/lib/PDCursesMod/pdcurses/beep.c
+++ b/lib/PDCursesMod/pdcurses/beep.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -35,7 +35,7 @@ beep
 
 int beep(void)
 {
-    PDC_LOG(("beep() - called\n"));
+    PDC_LOG("beep() - called\n");
 
     assert( SP);
     if (!SP)
@@ -53,7 +53,7 @@ int flash(void)
 {
     int z, y, x;
 
-    PDC_LOG(("flash() - called\n"));
+    PDC_LOG("flash() - called\n");
 
     assert( curscr);
     if (!curscr)
diff --git a/lib/PDCursesMod/pdcurses/bkgd.c b/lib/PDCursesMod/pdcurses/bkgd.c
index 0806dce68b0..198a9645e10 100644
--- a/lib/PDCursesMod/pdcurses/bkgd.c
+++ b/lib/PDCursesMod/pdcurses/bkgd.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -71,7 +71,7 @@ int wbkgd(WINDOW *win, chtype ch)
     chtype oldattr = 0, newattr = 0;
     chtype *winptr;
 
-    PDC_LOG(("wbkgd() - called\n"));
+    PDC_LOG("wbkgd() - called\n");
 
     assert( win);
     if (!win)
@@ -145,14 +145,14 @@ int wbkgd(WINDOW *win, chtype ch)
 
 int bkgd(chtype ch)
 {
-    PDC_LOG(("bkgd() - called\n"));
+    PDC_LOG("bkgd() - called\n");
 
     return wbkgd(stdscr, ch);
 }
 
 void wbkgdset(WINDOW *win, chtype ch)
 {
-    PDC_LOG(("wbkgdset() - called\n"));
+    PDC_LOG("wbkgdset() - called\n");
 
     if (win)
     {
@@ -165,14 +165,14 @@ void wbkgdset(WINDOW *win, chtype ch)
 
 void bkgdset(chtype ch)
 {
-    PDC_LOG(("bkgdset() - called\n"));
+    PDC_LOG("bkgdset() - called\n");
 
     wbkgdset(stdscr, ch);
 }
 
 chtype getbkgd(WINDOW *win)
 {
-    PDC_LOG(("getbkgd() - called\n"));
+    PDC_LOG("getbkgd() - called\n");
 
     assert( win);
     return win ? win->_bkgd : (chtype)ERR;
@@ -181,7 +181,7 @@ chtype getbkgd(WINDOW *win)
 #ifdef PDC_WIDE
 int wbkgrnd(WINDOW *win, const cchar_t *wch)
 {
-    PDC_LOG(("wbkgrnd() - called\n"));
+    PDC_LOG("wbkgrnd() - called\n");
 
     assert( wch);
     return wch ? wbkgd(win, *wch) : ERR;
@@ -189,14 +189,14 @@ int wbkgrnd(WINDOW *win, const cchar_t *wch)
 
 int bkgrnd(const cchar_t *wch)
 {
-    PDC_LOG(("bkgrnd() - called\n"));
+    PDC_LOG("bkgrnd() - called\n");
 
     return wbkgrnd(stdscr, wch);
 }
 
 void wbkgrndset(WINDOW *win, const cchar_t *wch)
 {
-    PDC_LOG(("wbkgdset() - called\n"));
+    PDC_LOG("wbkgdset() - called\n");
 
     if (wch)
         wbkgdset(win, *wch);
@@ -204,14 +204,14 @@ void wbkgrndset(WINDOW *win, const cchar_t *wch)
 
 void bkgrndset(const cchar_t *wch)
 {
-    PDC_LOG(("bkgrndset() - called\n"));
+    PDC_LOG("bkgrndset() - called\n");
 
     wbkgrndset(stdscr, wch);
 }
 
 int wgetbkgrnd(WINDOW *win, cchar_t *wch)
 {
-    PDC_LOG(("wgetbkgrnd() - called\n"));
+    PDC_LOG("wgetbkgrnd() - called\n");
 
     assert( win);
     assert( wch);
@@ -225,7 +225,7 @@ int wgetbkgrnd(WINDOW *win, cchar_t *wch)
 
 int getbkgrnd(cchar_t *wch)
 {
-    PDC_LOG(("getbkgrnd() - called\n"));
+    PDC_LOG("getbkgrnd() - called\n");
 
     return wgetbkgrnd(stdscr, wch);
 }
diff --git a/lib/PDCursesMod/pdcurses/border.c b/lib/PDCursesMod/pdcurses/border.c
index b234b7831c4..92b9ca52faa 100644
--- a/lib/PDCursesMod/pdcurses/border.c
+++ b/lib/PDCursesMod/pdcurses/border.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -140,7 +140,7 @@ int wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, chtype bs,
 {
     int i, ymax, xmax;
 
-    PDC_LOG(("wborder() - called\n"));
+    PDC_LOG("wborder() - called\n");
 
     assert( win);
     if (!win)
@@ -189,14 +189,14 @@ int wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, chtype bs,
 int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl,
            chtype tr, chtype bl, chtype br)
 {
-    PDC_LOG(("border() - called\n"));
+    PDC_LOG("border() - called\n");
 
     return wborder(stdscr, ls, rs, ts, bs, tl, tr, bl, br);
 }
 
 int box(WINDOW *win, chtype verch, chtype horch)
 {
-    PDC_LOG(("box() - called\n"));
+    PDC_LOG("box() - called\n");
 
     return wborder(win, verch, verch, horch, horch, 0, 0, 0, 0);
 }
@@ -206,7 +206,7 @@ int whline(WINDOW *win, chtype ch, int n)
     chtype *dest;
     int startpos, endpos;
 
-    PDC_LOG(("whline() - called\n"));
+    PDC_LOG("whline() - called\n");
 
     assert( win);
     if (!win || n < 1)
@@ -235,14 +235,14 @@ int whline(WINDOW *win, chtype ch, int n)
 
 int hline(chtype ch, int n)
 {
-    PDC_LOG(("hline() - called\n"));
+    PDC_LOG("hline() - called\n");
 
     return whline(stdscr, ch, n);
 }
 
 int mvhline(int y, int x, chtype ch, int n)
 {
-    PDC_LOG(("mvhline() - called\n"));
+    PDC_LOG("mvhline() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -252,7 +252,7 @@ int mvhline(int y, int x, chtype ch, int n)
 
 int mvwhline(WINDOW *win, int y, int x, chtype ch, int n)
 {
-    PDC_LOG(("mvwhline() - called\n"));
+    PDC_LOG("mvwhline() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -264,7 +264,7 @@ int wvline(WINDOW *win, chtype ch, int n)
 {
     int endpos, x;
 
-    PDC_LOG(("wvline() - called\n"));
+    PDC_LOG("wvline() - called\n");
 
     assert( win);
     if (!win || n < 1)
@@ -293,14 +293,14 @@ int wvline(WINDOW *win, chtype ch, int n)
 
 int vline(chtype ch, int n)
 {
-    PDC_LOG(("vline() - called\n"));
+    PDC_LOG("vline() - called\n");
 
     return wvline(stdscr, ch, n);
 }
 
 int mvvline(int y, int x, chtype ch, int n)
 {
-    PDC_LOG(("mvvline() - called\n"));
+    PDC_LOG("mvvline() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -310,7 +310,7 @@ int mvvline(int y, int x, chtype ch, int n)
 
 int mvwvline(WINDOW *win, int y, int x, chtype ch, int n)
 {
-    PDC_LOG(("mvwvline() - called\n"));
+    PDC_LOG("mvwvline() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -323,7 +323,7 @@ int wborder_set(WINDOW *win, const cchar_t *ls, const cchar_t *rs,
                 const cchar_t *ts, const cchar_t *bs, const cchar_t *tl,
                 const cchar_t *tr, const cchar_t *bl, const cchar_t *br)
 {
-    PDC_LOG(("wborder_set() - called\n"));
+    PDC_LOG("wborder_set() - called\n");
 
     return wborder(win, ls ? *ls : 0, rs ? *rs : 0, ts ? *ts : 0,
                         bs ? *bs : 0, tl ? *tl : 0, tr ? *tr : 0,
@@ -334,14 +334,14 @@ int border_set(const cchar_t *ls, const cchar_t *rs, const cchar_t *ts,
                const cchar_t *bs, const cchar_t *tl, const cchar_t *tr,
                const cchar_t *bl, const cchar_t *br)
 {
-    PDC_LOG(("border_set() - called\n"));
+    PDC_LOG("border_set() - called\n");
 
     return wborder_set(stdscr, ls, rs, ts, bs, tl, tr, bl, br);
 }
 
 int box_set(WINDOW *win, const cchar_t *verch, const cchar_t *horch)
 {
-    PDC_LOG(("box_set() - called\n"));
+    PDC_LOG("box_set() - called\n");
 
     return wborder_set(win, verch, verch, horch, horch,
                        (const cchar_t *)NULL, (const cchar_t *)NULL,
@@ -350,7 +350,7 @@ int box_set(WINDOW *win, const cchar_t *verch, const cchar_t *horch)
 
 int whline_set(WINDOW *win, const cchar_t *wch, int n)
 {
-    PDC_LOG(("whline_set() - called\n"));
+    PDC_LOG("whline_set() - called\n");
 
     assert( wch);
     return wch ? whline(win, *wch, n) : ERR;
@@ -358,14 +358,14 @@ int whline_set(WINDOW *win, const cchar_t *wch, int n)
 
 int hline_set(const cchar_t *wch, int n)
 {
-    PDC_LOG(("hline_set() - called\n"));
+    PDC_LOG("hline_set() - called\n");
 
     return whline_set(stdscr, wch, n);
 }
 
 int mvhline_set(int y, int x, const cchar_t *wch, int n)
 {
-    PDC_LOG(("mvhline_set() - called\n"));
+    PDC_LOG("mvhline_set() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -375,7 +375,7 @@ int mvhline_set(int y, int x, const cchar_t *wch, int n)
 
 int mvwhline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n)
 {
-    PDC_LOG(("mvwhline_set() - called\n"));
+    PDC_LOG("mvwhline_set() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -385,7 +385,7 @@ int mvwhline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n)
 
 int wvline_set(WINDOW *win, const cchar_t *wch, int n)
 {
-    PDC_LOG(("wvline_set() - called\n"));
+    PDC_LOG("wvline_set() - called\n");
 
     assert( wch);
     return wch ? wvline(win, *wch, n) : ERR;
@@ -393,14 +393,14 @@ int wvline_set(WINDOW *win, const cchar_t *wch, int n)
 
 int vline_set(const cchar_t *wch, int n)
 {
-    PDC_LOG(("vline_set() - called\n"));
+    PDC_LOG("vline_set() - called\n");
 
     return wvline_set(stdscr, wch, n);
 }
 
 int mvvline_set(int y, int x, const cchar_t *wch, int n)
 {
-    PDC_LOG(("mvvline_set() - called\n"));
+    PDC_LOG("mvvline_set() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -410,7 +410,7 @@ int mvvline_set(int y, int x, const cchar_t *wch, int n)
 
 int mvwvline_set(WINDOW *win, int y, int x, const cchar_t *wch, int n)
 {
-    PDC_LOG(("mvwvline_set() - called\n"));
+    PDC_LOG("mvwvline_set() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/clear.c b/lib/PDCursesMod/pdcurses/clear.c
index 9b6ccae783c..b5949584bc6 100644
--- a/lib/PDCursesMod/pdcurses/clear.c
+++ b/lib/PDCursesMod/pdcurses/clear.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -56,8 +56,8 @@ int wclrtoeol(WINDOW *win)
     int x, y, minx;
     chtype blank, *ptr;
 
-    PDC_LOG(("wclrtoeol() - called: Row: %d Col: %d\n",
-             win->_cury, win->_curx));
+    PDC_LOG("wclrtoeol() - called: Row: %d Col: %d\n",
+             win->_cury, win->_curx);
 
     assert( win);
     if (!win)
@@ -84,7 +84,7 @@ int wclrtoeol(WINDOW *win)
 
 int clrtoeol(void)
 {
-    PDC_LOG(("clrtoeol() - called\n"));
+    PDC_LOG("clrtoeol() - called\n");
 
     return wclrtoeol(stdscr);
 }
@@ -93,7 +93,7 @@ int wclrtobot(WINDOW *win)
 {
     int savey, savex;
 
-    PDC_LOG(("wclrtobot() - called\n"));
+    PDC_LOG("wclrtobot() - called\n");
 
     assert( win);
     if (!win)
@@ -121,14 +121,14 @@ int wclrtobot(WINDOW *win)
 
 int clrtobot(void)
 {
-    PDC_LOG(("clrtobot() - called\n"));
+    PDC_LOG("clrtobot() - called\n");
 
     return wclrtobot(stdscr);
 }
 
 int werase(WINDOW *win)
 {
-    PDC_LOG(("werase() - called\n"));
+    PDC_LOG("werase() - called\n");
 
     if (wmove(win, 0, 0) == ERR)
         return ERR;
@@ -138,14 +138,14 @@ int werase(WINDOW *win)
 
 int erase(void)
 {
-    PDC_LOG(("erase() - called\n"));
+    PDC_LOG("erase() - called\n");
 
     return werase(stdscr);
 }
 
 int wclear(WINDOW *win)
 {
-    PDC_LOG(("wclear() - called\n"));
+    PDC_LOG("wclear() - called\n");
 
     assert( win);
     if (!win)
@@ -157,7 +157,7 @@ int wclear(WINDOW *win)
 
 int clear(void)
 {
-    PDC_LOG(("clear() - called\n"));
+    PDC_LOG("clear() - called\n");
 
     return wclear(stdscr);
 }
diff --git a/lib/PDCursesMod/pdcurses/color.c b/lib/PDCursesMod/pdcurses/color.c
index bd15e70e1fe..a10429e204f 100644
--- a/lib/PDCursesMod/pdcurses/color.c
+++ b/lib/PDCursesMod/pdcurses/color.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 
 /*man-start**************************************************************
 
@@ -123,7 +123,7 @@ static int first_col = 0;
 
 int start_color(void)
 {
-    PDC_LOG(("start_color() - called\n"));
+    PDC_LOG("start_color() - called\n");
 
     assert( SP);
     if (!SP || SP->mono)
@@ -133,7 +133,9 @@ int start_color(void)
 
     PDC_set_blink(FALSE);   /* Also sets COLORS */
 
+#ifndef __U_BOOT__
     if (!default_colors && SP->orig_attr && getenv("PDC_ORIGINAL_COLORS"))
+#endif
         default_colors = TRUE;
 
     PDC_init_atrtab();
@@ -215,7 +217,7 @@ static void _init_pair_core(int pair, int fg, int bg)
 
 int init_extended_pair(int pair, int fg, int bg)
 {
-    PDC_LOG(("init_pair() - called: pair %d fg %d bg %d\n", pair, fg, bg));
+    PDC_LOG("init_pair() - called: pair %d fg %d bg %d\n", pair, fg, bg);
 
     assert( SP);
     if (!SP || !SP->color_started || pair < 1 || pair >= COLOR_PAIRS ||
@@ -229,7 +231,7 @@ int init_extended_pair(int pair, int fg, int bg)
 
 bool has_colors(void)
 {
-    PDC_LOG(("has_colors() - called\n"));
+    PDC_LOG("has_colors() - called\n");
 
     assert( SP);
     return SP ? !(SP->mono) : FALSE;
@@ -237,7 +239,7 @@ bool has_colors(void)
 
 int init_extended_color(int color, int red, int green, int blue)
 {
-    PDC_LOG(("init_color() - called\n"));
+    PDC_LOG("init_color() - called\n");
 
     assert( SP);
     if (!SP || color < 0 || color >= COLORS || !PDC_can_change_color() ||
@@ -252,7 +254,7 @@ int init_extended_color(int color, int red, int green, int blue)
 
 int extended_color_content(int color, int *red, int *green, int *blue)
 {
-    PDC_LOG(("color_content() - called\n"));
+    PDC_LOG("color_content() - called\n");
 
     if (color < 0 || color >= COLORS || !red || !green || !blue)
         return ERR;
@@ -276,14 +278,14 @@ int extended_color_content(int color, int *red, int *green, int *blue)
 
 bool can_change_color(void)
 {
-    PDC_LOG(("can_change_color() - called\n"));
+    PDC_LOG("can_change_color() - called\n");
 
     return PDC_can_change_color();
 }
 
 int extended_pair_content(int pair, int *fg, int *bg)
 {
-    PDC_LOG(("pair_content() - called\n"));
+    PDC_LOG("pair_content() - called\n");
 
     if (pair < 0 || pair >= COLOR_PAIRS || !fg || !bg)
         return ERR;
@@ -303,7 +305,7 @@ int extended_pair_content(int pair, int *fg, int *bg)
 
 int assume_default_colors(int f, int b)
 {
-    PDC_LOG(("assume_default_colors() - called: f %d b %d\n", f, b));
+    PDC_LOG("assume_default_colors() - called: f %d b %d\n", f, b);
 
     if (f < -1 || f >= COLORS || b < -1 || b >= COLORS)
         return ERR;
@@ -319,7 +321,7 @@ int assume_default_colors(int f, int b)
 
 int use_default_colors(void)
 {
-    PDC_LOG(("use_default_colors() - called\n"));
+    PDC_LOG("use_default_colors() - called\n");
 
     default_colors = TRUE;
     first_col = -1;
@@ -329,7 +331,7 @@ int use_default_colors(void)
 
 int PDC_set_line_color(short color)
 {
-    PDC_LOG(("PDC_set_line_color() - called: %d\n", color));
+    PDC_LOG("PDC_set_line_color() - called: %d\n", color);
 
     assert( SP);
     if (!SP || color < -1 || color >= COLORS)
diff --git a/lib/PDCursesMod/pdcurses/debug.c b/lib/PDCursesMod/pdcurses/debug.c
index 2aaff6c722b..56cdf4b9344 100644
--- a/lib/PDCursesMod/pdcurses/debug.c
+++ b/lib/PDCursesMod/pdcurses/debug.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -35,15 +35,20 @@ debug
 
 **man-end****************************************************************/
 
+#ifndef __U_BOOT__
 #include <stdlib.h>
 #include <string.h>
 #include <sys/types.h>
 #include <time.h>
+#endif
 
+#ifndef __U_BOOT__
 static bool want_fflush = FALSE;
+#endif
 
 void PDC_debug(const char *fmt, ...)
 {
+#ifndef __U_BOOT__
     va_list args;
     char hms[9];
     time_t now;
@@ -71,10 +76,12 @@ void PDC_debug(const char *fmt, ...)
        crashes, you may need to add a platform-dependent mechanism to
        flush the OS buffers as well (such as fsync() on POSIX) -- but
        expect terrible performance. */
+#endif
 }
 
 void traceon(void)
 {
+#ifndef __U_BOOT__
     assert( SP);
     if (!SP)
         return;
@@ -93,18 +100,21 @@ void traceon(void)
     if (getenv("PDC_TRACE_FLUSH"))
         want_fflush = TRUE;
 
-    PDC_LOG(("traceon() - called\n"));
+    PDC_LOG("traceon() - called\n");
+#endif
 }
 
 void traceoff(void)
 {
+#ifndef __U_BOOT__
     assert( SP);
     if (!SP || !SP->dbfp)
         return;
 
-    PDC_LOG(("traceoff() - called\n"));
+    PDC_LOG("traceoff() - called\n");
 
     fclose(SP->dbfp);
     SP->dbfp = NULL;
     want_fflush = FALSE;
+#endif
 }
diff --git a/lib/PDCursesMod/pdcurses/delch.c b/lib/PDCursesMod/pdcurses/delch.c
index 3f9219c623b..0abedced4df 100644
--- a/lib/PDCursesMod/pdcurses/delch.c
+++ b/lib/PDCursesMod/pdcurses/delch.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -43,7 +43,7 @@ int wdelch(WINDOW *win)
     int y, x, maxx;
     chtype *temp1;
 
-    PDC_LOG(("wdelch() - called\n"));
+    PDC_LOG("wdelch() - called\n");
 
     assert( win);
     if (!win)
@@ -72,14 +72,14 @@ int wdelch(WINDOW *win)
 
 int delch(void)
 {
-    PDC_LOG(("delch() - called\n"));
+    PDC_LOG("delch() - called\n");
 
     return wdelch(stdscr);
 }
 
 int mvdelch(int y, int x)
 {
-    PDC_LOG(("mvdelch() - called\n"));
+    PDC_LOG("mvdelch() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -89,7 +89,7 @@ int mvdelch(int y, int x)
 
 int mvwdelch(WINDOW *win, int y, int x)
 {
-    PDC_LOG(("mvwdelch() - called\n"));
+    PDC_LOG("mvwdelch() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/deleteln.c b/lib/PDCursesMod/pdcurses/deleteln.c
index 68072bca133..f80c36794bb 100644
--- a/lib/PDCursesMod/pdcurses/deleteln.c
+++ b/lib/PDCursesMod/pdcurses/deleteln.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -59,7 +59,7 @@ int wdeleteln(WINDOW *win)
     chtype blank, *temp, *ptr;
     int y;
 
-    PDC_LOG(("wdeleteln() - called\n"));
+    PDC_LOG("wdeleteln() - called\n");
 
     assert( win);
     if (!win)
@@ -93,14 +93,14 @@ int wdeleteln(WINDOW *win)
 
 int deleteln(void)
 {
-    PDC_LOG(("deleteln() - called\n"));
+    PDC_LOG("deleteln() - called\n");
 
     return wdeleteln(stdscr);
 }
 
 int mvdeleteln(int y, int x)
 {
-    PDC_LOG(("mvdeleteln() - called\n"));
+    PDC_LOG("mvdeleteln() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -110,7 +110,7 @@ int mvdeleteln(int y, int x)
 
 int mvwdeleteln(WINDOW *win, int y, int x)
 {
-    PDC_LOG(("mvwdeleteln() - called\n"));
+    PDC_LOG("mvwdeleteln() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -122,7 +122,7 @@ int winsdelln(WINDOW *win, int n)
 {
     int i;
 
-    PDC_LOG(("winsdelln() - called\n"));
+    PDC_LOG("winsdelln() - called\n");
 
     assert( win);
     if (!win)
@@ -147,7 +147,7 @@ int winsdelln(WINDOW *win, int n)
 
 int insdelln(int n)
 {
-    PDC_LOG(("insdelln() - called\n"));
+    PDC_LOG("insdelln() - called\n");
 
     return winsdelln(stdscr, n);
 }
@@ -157,7 +157,7 @@ int winsertln(WINDOW *win)
     chtype blank, *temp, *end;
     int y;
 
-    PDC_LOG(("winsertln() - called\n"));
+    PDC_LOG("winsertln() - called\n");
 
     assert( win);
     if (!win)
@@ -189,14 +189,14 @@ int winsertln(WINDOW *win)
 
 int insertln(void)
 {
-    PDC_LOG(("insertln() - called\n"));
+    PDC_LOG("insertln() - called\n");
 
     return winsertln(stdscr);
 }
 
 int mvinsertln(int y, int x)
 {
-    PDC_LOG(("mvinsertln() - called\n"));
+    PDC_LOG("mvinsertln() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -206,7 +206,7 @@ int mvinsertln(int y, int x)
 
 int mvwinsertln(WINDOW *win, int y, int x)
 {
-    PDC_LOG(("mvwinsertln() - called\n"));
+    PDC_LOG("mvwinsertln() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/getch.c b/lib/PDCursesMod/pdcurses/getch.c
index 7efac0cf96c..835accf57eb 100644
--- a/lib/PDCursesMod/pdcurses/getch.c
+++ b/lib/PDCursesMod/pdcurses/getch.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -39,7 +39,7 @@ getch
 
    If keypad() is TRUE, and a function key is pressed, the token for
    that function key will be returned instead of the raw characters.
-   Possible function keys are defined in <curses.h> with integers
+   Possible function keys are defined in <PDCurses/curses.h> with integers
    beginning with 0401, whose names begin with KEY_.
 
    If nodelay(win, TRUE) has been called on the window and no input is
@@ -341,7 +341,7 @@ int wgetch(WINDOW *win)
 {
     int key, remaining_millisecs;
 
-    PDC_LOG(("wgetch() - called\n"));
+    PDC_LOG("wgetch() - called\n");
 
     assert( SP);
     assert( win);
@@ -477,7 +477,7 @@ int wgetch(WINDOW *win)
 
 int mvgetch(int y, int x)
 {
-    PDC_LOG(("mvgetch() - called\n"));
+    PDC_LOG("mvgetch() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -487,7 +487,7 @@ int mvgetch(int y, int x)
 
 int mvwgetch(WINDOW *win, int y, int x)
 {
-    PDC_LOG(("mvwgetch() - called\n"));
+    PDC_LOG("mvwgetch() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -497,7 +497,7 @@ int mvwgetch(WINDOW *win, int y, int x)
 
 int PDC_ungetch(int ch)
 {
-    PDC_LOG(("ungetch() - called\n"));
+    PDC_LOG("ungetch() - called\n");
 
     if (SP->c_ungind >= SP->c_ungmax)   /* pushback stack full */
         return ERR;
@@ -509,7 +509,7 @@ int PDC_ungetch(int ch)
 
 int flushinp(void)
 {
-    PDC_LOG(("flushinp() - called\n"));
+    PDC_LOG("flushinp() - called\n");
 
     assert( SP);
     if (!SP)
@@ -526,7 +526,7 @@ int flushinp(void)
 
 unsigned long PDC_get_key_modifiers(void)
 {
-    PDC_LOG(("PDC_get_key_modifiers() - called\n"));
+    PDC_LOG("PDC_get_key_modifiers() - called\n");
 
     assert( SP);
     if (!SP)
@@ -537,7 +537,7 @@ unsigned long PDC_get_key_modifiers(void)
 
 int PDC_return_key_modifiers(bool flag)
 {
-    PDC_LOG(("PDC_return_key_modifiers() - called\n"));
+    PDC_LOG("PDC_return_key_modifiers() - called\n");
 
     assert( SP);
     if (!SP)
@@ -552,7 +552,7 @@ int wget_wch(WINDOW *win, wint_t *wch)
 {
     int key;
 
-    PDC_LOG(("wget_wch() - called\n"));
+    PDC_LOG("wget_wch() - called\n");
 
     assert( wch);
     if (!wch)
@@ -570,14 +570,14 @@ int wget_wch(WINDOW *win, wint_t *wch)
 
 int get_wch(wint_t *wch)
 {
-    PDC_LOG(("get_wch() - called\n"));
+    PDC_LOG("get_wch() - called\n");
 
     return wget_wch(stdscr, wch);
 }
 
 int mvget_wch(int y, int x, wint_t *wch)
 {
-    PDC_LOG(("mvget_wch() - called\n"));
+    PDC_LOG("mvget_wch() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -587,7 +587,7 @@ int mvget_wch(int y, int x, wint_t *wch)
 
 int mvwget_wch(WINDOW *win, int y, int x, wint_t *wch)
 {
-    PDC_LOG(("mvwget_wch() - called\n"));
+    PDC_LOG("mvwget_wch() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/getstr.c b/lib/PDCursesMod/pdcurses/getstr.c
index f909b4182ab..dd4734678e8 100644
--- a/lib/PDCursesMod/pdcurses/getstr.c
+++ b/lib/PDCursesMod/pdcurses/getstr.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -86,7 +86,7 @@ int wgetnstr(WINDOW *win, char *str, int n)
     char *p;
     bool stop, oldecho, oldcbreak, oldnodelay;
 
-    PDC_LOG(("wgetnstr() - called\n"));
+    PDC_LOG("wgetnstr() - called\n");
 
     assert( win);
     assert( str);
@@ -220,21 +220,21 @@ int wgetnstr(WINDOW *win, char *str, int n)
 
 int getstr(char *str)
 {
-    PDC_LOG(("getstr() - called\n"));
+    PDC_LOG("getstr() - called\n");
 
     return wgetnstr(stdscr, str, MAXLINE);
 }
 
 int wgetstr(WINDOW *win, char *str)
 {
-    PDC_LOG(("wgetstr() - called\n"));
+    PDC_LOG("wgetstr() - called\n");
 
     return wgetnstr(win, str, MAXLINE);
 }
 
 int mvgetstr(int y, int x, char *str)
 {
-    PDC_LOG(("mvgetstr() - called\n"));
+    PDC_LOG("mvgetstr() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -244,7 +244,7 @@ int mvgetstr(int y, int x, char *str)
 
 int mvwgetstr(WINDOW *win, int y, int x, char *str)
 {
-    PDC_LOG(("mvwgetstr() - called\n"));
+    PDC_LOG("mvwgetstr() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -254,14 +254,14 @@ int mvwgetstr(WINDOW *win, int y, int x, char *str)
 
 int getnstr(char *str, int n)
 {
-    PDC_LOG(("getnstr() - called\n"));
+    PDC_LOG("getnstr() - called\n");
 
     return wgetnstr(stdscr, str, n);
 }
 
 int mvgetnstr(int y, int x, char *str, int n)
 {
-    PDC_LOG(("mvgetnstr() - called\n"));
+    PDC_LOG("mvgetnstr() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -271,7 +271,7 @@ int mvgetnstr(int y, int x, char *str, int n)
 
 int mvwgetnstr(WINDOW *win, int y, int x, char *str, int n)
 {
-    PDC_LOG(("mvwgetnstr() - called\n"));
+    PDC_LOG("mvwgetnstr() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -286,7 +286,7 @@ int wgetn_wstr(WINDOW *win, wint_t *wstr, int n)
     wint_t *p;
     bool stop, oldecho, oldcbreak, oldnodelay;
 
-    PDC_LOG(("wgetn_wstr() - called\n"));
+    PDC_LOG("wgetn_wstr() - called\n");
 
     assert( win);
     assert( wstr);
@@ -419,21 +419,21 @@ int wgetn_wstr(WINDOW *win, wint_t *wstr, int n)
 
 int get_wstr(wint_t *wstr)
 {
-    PDC_LOG(("get_wstr() - called\n"));
+    PDC_LOG("get_wstr() - called\n");
 
     return wgetn_wstr(stdscr, wstr, MAXLINE);
 }
 
 int wget_wstr(WINDOW *win, wint_t *wstr)
 {
-    PDC_LOG(("wget_wstr() - called\n"));
+    PDC_LOG("wget_wstr() - called\n");
 
     return wgetn_wstr(win, wstr, MAXLINE);
 }
 
 int mvget_wstr(int y, int x, wint_t *wstr)
 {
-    PDC_LOG(("mvget_wstr() - called\n"));
+    PDC_LOG("mvget_wstr() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -443,7 +443,7 @@ int mvget_wstr(int y, int x, wint_t *wstr)
 
 int mvwget_wstr(WINDOW *win, int y, int x, wint_t *wstr)
 {
-    PDC_LOG(("mvwget_wstr() - called\n"));
+    PDC_LOG("mvwget_wstr() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -453,14 +453,14 @@ int mvwget_wstr(WINDOW *win, int y, int x, wint_t *wstr)
 
 int getn_wstr(wint_t *wstr, int n)
 {
-    PDC_LOG(("getn_wstr() - called\n"));
+    PDC_LOG("getn_wstr() - called\n");
 
     return wgetn_wstr(stdscr, wstr, n);
 }
 
 int mvgetn_wstr(int y, int x, wint_t *wstr, int n)
 {
-    PDC_LOG(("mvgetn_wstr() - called\n"));
+    PDC_LOG("mvgetn_wstr() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -470,7 +470,7 @@ int mvgetn_wstr(int y, int x, wint_t *wstr, int n)
 
 int mvwgetn_wstr(WINDOW *win, int y, int x, wint_t *wstr, int n)
 {
-    PDC_LOG(("mvwgetn_wstr() - called\n"));
+    PDC_LOG("mvwgetn_wstr() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/getyx.c b/lib/PDCursesMod/pdcurses/getyx.c
index 0f9b7c8cd3e..7312276f664 100644
--- a/lib/PDCursesMod/pdcurses/getyx.c
+++ b/lib/PDCursesMod/pdcurses/getyx.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -75,7 +75,7 @@ getyx
 
 int getbegy(WINDOW *win)
 {
-    PDC_LOG(("getbegy() - called\n"));
+    PDC_LOG("getbegy() - called\n");
 
     assert( win);
     return win ? win->_begy : ERR;
@@ -83,7 +83,7 @@ int getbegy(WINDOW *win)
 
 int getbegx(WINDOW *win)
 {
-    PDC_LOG(("getbegx() - called\n"));
+    PDC_LOG("getbegx() - called\n");
 
     assert( win);
     return win ? win->_begx : ERR;
@@ -91,7 +91,7 @@ int getbegx(WINDOW *win)
 
 int getcury(WINDOW *win)
 {
-    PDC_LOG(("getcury() - called\n"));
+    PDC_LOG("getcury() - called\n");
 
     assert( win);
     return win ? win->_cury : ERR;
@@ -99,7 +99,7 @@ int getcury(WINDOW *win)
 
 int getcurx(WINDOW *win)
 {
-    PDC_LOG(("getcurx() - called\n"));
+    PDC_LOG("getcurx() - called\n");
 
     assert( win);
     return win ? win->_curx : ERR;
@@ -107,7 +107,7 @@ int getcurx(WINDOW *win)
 
 int getpary(WINDOW *win)
 {
-    PDC_LOG(("getpary() - called\n"));
+    PDC_LOG("getpary() - called\n");
 
     assert( win);
     return win ? win->_pary : ERR;
@@ -115,7 +115,7 @@ int getpary(WINDOW *win)
 
 int getparx(WINDOW *win)
 {
-    PDC_LOG(("getparx() - called\n"));
+    PDC_LOG("getparx() - called\n");
 
     assert( win);
     return win ? win->_parx : ERR;
@@ -123,7 +123,7 @@ int getparx(WINDOW *win)
 
 int getmaxy(WINDOW *win)
 {
-    PDC_LOG(("getmaxy() - called\n"));
+    PDC_LOG("getmaxy() - called\n");
 
     assert( win);
     return win ? win->_maxy : ERR;
@@ -131,7 +131,7 @@ int getmaxy(WINDOW *win)
 
 int getmaxx(WINDOW *win)
 {
-    PDC_LOG(("getmaxx() - called\n"));
+    PDC_LOG("getmaxx() - called\n");
 
     assert( win);
     return win ? win->_maxx : ERR;
@@ -139,7 +139,7 @@ int getmaxx(WINDOW *win)
 
 void setsyx(int y, int x)
 {
-    PDC_LOG(("setsyx() - called\n"));
+    PDC_LOG("setsyx() - called\n");
 
     if (curscr)
     {
diff --git a/lib/PDCursesMod/pdcurses/inch.c b/lib/PDCursesMod/pdcurses/inch.c
index c5293bcd691..c2bb4b115a6 100644
--- a/lib/PDCursesMod/pdcurses/inch.c
+++ b/lib/PDCursesMod/pdcurses/inch.c
@@ -1,7 +1,7 @@
 /* PDCurses */
 
 #include <assert.h>
-#include <curspriv.h>
+#include "../curspriv.h"
 
 /*man-start**************************************************************
 
@@ -46,7 +46,7 @@ inch
 
 chtype winch(WINDOW *win)
 {
-    PDC_LOG(("winch() - called\n"));
+    PDC_LOG("winch() - called\n");
 
     assert( win);
     if (!win)
@@ -57,14 +57,14 @@ chtype winch(WINDOW *win)
 
 chtype inch(void)
 {
-    PDC_LOG(("inch() - called\n"));
+    PDC_LOG("inch() - called\n");
 
     return winch(stdscr);
 }
 
 chtype mvinch(int y, int x)
 {
-    PDC_LOG(("mvinch() - called\n"));
+    PDC_LOG("mvinch() - called\n");
 
     if (move(y, x) == ERR)
         return (chtype)ERR;
@@ -74,7 +74,7 @@ chtype mvinch(int y, int x)
 
 chtype mvwinch(WINDOW *win, int y, int x)
 {
-    PDC_LOG(("mvwinch() - called\n"));
+    PDC_LOG("mvwinch() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return (chtype)ERR;
@@ -85,7 +85,7 @@ chtype mvwinch(WINDOW *win, int y, int x)
 #ifdef PDC_WIDE
 int win_wch(WINDOW *win, cchar_t *wcval)
 {
-    PDC_LOG(("win_wch() - called\n"));
+    PDC_LOG("win_wch() - called\n");
 
     assert( win);
     assert( wcval);
@@ -99,14 +99,14 @@ int win_wch(WINDOW *win, cchar_t *wcval)
 
 int in_wch(cchar_t *wcval)
 {
-    PDC_LOG(("in_wch() - called\n"));
+    PDC_LOG("in_wch() - called\n");
 
     return win_wch(stdscr, wcval);
 }
 
 int mvin_wch(int y, int x, cchar_t *wcval)
 {
-    PDC_LOG(("mvin_wch() - called\n"));
+    PDC_LOG("mvin_wch() - called\n");
 
     assert( wcval);
     if (!wcval || (move(y, x) == ERR))
@@ -119,7 +119,7 @@ int mvin_wch(int y, int x, cchar_t *wcval)
 
 int mvwin_wch(WINDOW *win, int y, int x, cchar_t *wcval)
 {
-    PDC_LOG(("mvwin_wch() - called\n"));
+    PDC_LOG("mvwin_wch() - called\n");
 
     assert( wcval);
     if (!wcval || (wmove(win, y, x) == ERR))
diff --git a/lib/PDCursesMod/pdcurses/inchstr.c b/lib/PDCursesMod/pdcurses/inchstr.c
index 6718539504b..81122181a94 100644
--- a/lib/PDCursesMod/pdcurses/inchstr.c
+++ b/lib/PDCursesMod/pdcurses/inchstr.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -64,7 +64,7 @@ int winchnstr(WINDOW *win, chtype *ch, int n)
     chtype *src;
     int i;
 
-    PDC_LOG(("winchnstr() - called\n"));
+    PDC_LOG("winchnstr() - called\n");
 
     assert( win);
     assert( ch);
@@ -86,21 +86,21 @@ int winchnstr(WINDOW *win, chtype *ch, int n)
 
 int inchstr(chtype *ch)
 {
-    PDC_LOG(("inchstr() - called\n"));
+    PDC_LOG("inchstr() - called\n");
 
     return winchnstr(stdscr, ch, stdscr->_maxx - stdscr->_curx);
 }
 
 int winchstr(WINDOW *win, chtype *ch)
 {
-    PDC_LOG(("winchstr() - called\n"));
+    PDC_LOG("winchstr() - called\n");
 
     return winchnstr(win, ch, win->_maxx - win->_curx);
 }
 
 int mvinchstr(int y, int x, chtype *ch)
 {
-    PDC_LOG(("mvinchstr() - called: y %d x %d\n", y, x));
+    PDC_LOG("mvinchstr() - called: y %d x %d\n", y, x);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -110,7 +110,7 @@ int mvinchstr(int y, int x, chtype *ch)
 
 int mvwinchstr(WINDOW *win, int y, int x, chtype *ch)
 {
-    PDC_LOG(("mvwinchstr() - called:\n"));
+    PDC_LOG("mvwinchstr() - called:\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -120,14 +120,14 @@ int mvwinchstr(WINDOW *win, int y, int x, chtype *ch)
 
 int inchnstr(chtype *ch, int n)
 {
-    PDC_LOG(("inchnstr() - called\n"));
+    PDC_LOG("inchnstr() - called\n");
 
     return winchnstr(stdscr, ch, n);
 }
 
 int mvinchnstr(int y, int x, chtype *ch, int n)
 {
-    PDC_LOG(("mvinchnstr() - called: y %d x %d n %d\n", y, x, n));
+    PDC_LOG("mvinchnstr() - called: y %d x %d n %d\n", y, x, n);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -137,7 +137,7 @@ int mvinchnstr(int y, int x, chtype *ch, int n)
 
 int mvwinchnstr(WINDOW *win, int y, int x, chtype *ch, int n)
 {
-    PDC_LOG(("mvwinchnstr() - called: y %d x %d n %d \n", y, x, n));
+    PDC_LOG("mvwinchnstr() - called: y %d x %d n %d \n", y, x, n);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -148,28 +148,28 @@ int mvwinchnstr(WINDOW *win, int y, int x, chtype *ch, int n)
 #ifdef PDC_WIDE
 int win_wchnstr(WINDOW *win, cchar_t *wch, int n)
 {
-    PDC_LOG(("win_wchnstr() - called\n"));
+    PDC_LOG("win_wchnstr() - called\n");
 
     return winchnstr(win, wch, n);
 }
 
 int in_wchstr(cchar_t *wch)
 {
-    PDC_LOG(("in_wchstr() - called\n"));
+    PDC_LOG("in_wchstr() - called\n");
 
     return win_wchnstr(stdscr, wch, stdscr->_maxx - stdscr->_curx);
 }
 
 int win_wchstr(WINDOW *win, cchar_t *wch)
 {
-    PDC_LOG(("win_wchstr() - called\n"));
+    PDC_LOG("win_wchstr() - called\n");
 
     return win_wchnstr(win, wch, win->_maxx - win->_curx);
 }
 
 int mvin_wchstr(int y, int x, cchar_t *wch)
 {
-    PDC_LOG(("mvin_wchstr() - called: y %d x %d\n", y, x));
+    PDC_LOG("mvin_wchstr() - called: y %d x %d\n", y, x);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -179,7 +179,7 @@ int mvin_wchstr(int y, int x, cchar_t *wch)
 
 int mvwin_wchstr(WINDOW *win, int y, int x, cchar_t *wch)
 {
-    PDC_LOG(("mvwin_wchstr() - called:\n"));
+    PDC_LOG("mvwin_wchstr() - called:\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -189,14 +189,14 @@ int mvwin_wchstr(WINDOW *win, int y, int x, cchar_t *wch)
 
 int in_wchnstr(cchar_t *wch, int n)
 {
-    PDC_LOG(("in_wchnstr() - called\n"));
+    PDC_LOG("in_wchnstr() - called\n");
 
     return win_wchnstr(stdscr, wch, n);
 }
 
 int mvin_wchnstr(int y, int x, cchar_t *wch, int n)
 {
-    PDC_LOG(("mvin_wchnstr() - called: y %d x %d n %d\n", y, x, n));
+    PDC_LOG("mvin_wchnstr() - called: y %d x %d n %d\n", y, x, n);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -206,7 +206,7 @@ int mvin_wchnstr(int y, int x, cchar_t *wch, int n)
 
 int mvwin_wchnstr(WINDOW *win, int y, int x, cchar_t *wch, int n)
 {
-    PDC_LOG(("mvwinchnstr() - called: y %d x %d n %d \n", y, x, n));
+    PDC_LOG("mvwinchnstr() - called: y %d x %d n %d \n", y, x, n);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/initscr.c b/lib/PDCursesMod/pdcurses/initscr.c
index ed443558ba4..118ccefe2b0 100644
--- a/lib/PDCursesMod/pdcurses/initscr.c
+++ b/lib/PDCursesMod/pdcurses/initscr.c
@@ -1,9 +1,15 @@
 /* PDCurses */
 
-#include <curspriv.h>
-#include <panel.h>
+#include "../curspriv.h"
+#include <PDCurses/panel.h>
 #include <assert.h>
 
+#ifdef __U_BOOT__
+static void exit(int ret) {
+    printf("in %s; exit with %d.\n", __FILE__, ret);
+}
+#endif
+
 /*man-start**************************************************************
 
 initscr
@@ -153,7 +159,7 @@ WINDOW *initscr(void)
 {
     int i;
 
-    PDC_LOG(("initscr() - called\n"));
+    PDC_LOG("initscr() - called\n");
 
     if (SP && SP->alive)
         return NULL;
@@ -164,7 +170,7 @@ WINDOW *initscr(void)
 
     if (PDC_scr_open() == ERR)
     {
-        fprintf(stderr, "initscr(): Unable to create SP\n");
+        PDC_perror("initscr(): Unable to create SP\n");
         exit(8);
     }
 
@@ -183,7 +189,9 @@ WINDOW *initscr(void)
     SP->delaytenths = 0;
     SP->line_color = -1;
     SP->lastscr = (WINDOW *)NULL;
+#ifndef __U_BOOT__
     SP->dbfp = NULL;
+#endif
     SP->color_started = FALSE;
     SP->dirty = FALSE;
     SP->sel_start = -1;
@@ -196,7 +204,7 @@ WINDOW *initscr(void)
 
     if (LINES < 2 || COLS < 2)
     {
-        fprintf(stderr, "initscr(): LINES=%d COLS=%d: too small.\n",
+        PDC_perror("initscr(): LINES=%d COLS=%d: too small.\n",
                 LINES, COLS);
         exit(4);
     }
@@ -204,15 +212,19 @@ WINDOW *initscr(void)
     curscr = newwin(LINES, COLS, 0, 0);
     if (!curscr)
     {
-        fprintf(stderr, "initscr(): Unable to create curscr.\n");
+        PDC_perror("initscr(): Unable to create curscr.\n");
         exit(2);
+
+        return NULL;
     }
 
     SP->lastscr = newwin(LINES, COLS, 0, 0);
     if (!SP->lastscr)
     {
-        fprintf(stderr, "initscr(): Unable to create SP->lastscr.\n");
+        PDC_perror("initscr(): Unable to create SP->lastscr.\n");
         exit(2);
+
+        return NULL;
     }
 
     wattrset(SP->lastscr, (chtype)(-1));
@@ -241,8 +253,10 @@ WINDOW *initscr(void)
     stdscr = newwin(LINES, COLS, SP->linesrippedoffontop, 0);
     if (!stdscr)
     {
-        fprintf(stderr, "initscr(): Unable to create stdscr.\n");
+        PDC_perror("initscr(): Unable to create stdscr.\n");
         exit(1);
+
+        return NULL;
     }
 
     wclrtobot(stdscr);
@@ -292,7 +306,7 @@ WINDOW *initscr(void)
 #ifdef XCURSES
 WINDOW *Xinitscr(int argc, char **argv)
 {
-    PDC_LOG(("Xinitscr() - called\n"));
+    PDC_LOG("Xinitscr() - called\n");
 
     PDC_set_args(argc, argv);
     return initscr();
@@ -301,7 +315,7 @@ WINDOW *Xinitscr(int argc, char **argv)
 
 int endwin(void)
 {
-    PDC_LOG(("endwin() - called\n"));
+    PDC_LOG("endwin() - called\n");
 
     /* Allow temporary exit from curses using endwin() */
 
@@ -316,25 +330,27 @@ int endwin(void)
 
 bool isendwin(void)
 {
-    PDC_LOG(("isendwin() - called\n"));
+    PDC_LOG("isendwin() - called\n");
 
     assert( SP);
     return SP ? !(SP->alive) : FALSE;
 }
 
+#ifndef __U_BOOT__
 SCREEN *newterm(const char *type, FILE *outfd, FILE *infd)
 {
-    PDC_LOG(("newterm() - called\n"));
+    PDC_LOG("newterm() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( type);
     INTENTIONALLY_UNUSED_PARAMETER( outfd);
     INTENTIONALLY_UNUSED_PARAMETER( infd);
     return initscr() ? SP : NULL;
 }
+#endif
 
 SCREEN *set_term(SCREEN *new)
 {
-    PDC_LOG(("set_term() - called\n"));
+    PDC_LOG("set_term() - called\n");
 
     /* We only support one screen */
 
@@ -343,7 +359,7 @@ SCREEN *set_term(SCREEN *new)
 
 void delscreen(SCREEN *sp)
 {
-    PDC_LOG(("delscreen() - called\n"));
+    PDC_LOG("delscreen() - called\n");
 
     assert( SP);
     if (!SP || sp != SP)
@@ -374,7 +390,7 @@ int resize_term(int nlines, int ncols)
 {
     PANEL *panel_ptr = NULL;
 
-    PDC_LOG(("resize_term() - called: nlines %d\n", nlines));
+    PDC_LOG("resize_term() - called: nlines %d\n", nlines);
 
     if( PDC_resize_screen(nlines, ncols) == ERR)
         return ERR;
@@ -425,7 +441,7 @@ int resize_term(int nlines, int ncols)
 
 bool is_termresized(void)
 {
-    PDC_LOG(("is_termresized() - called\n"));
+    PDC_LOG("is_termresized() - called\n");
 
     return SP->resized;
 }
@@ -472,7 +488,7 @@ void PDC_get_version(PDC_VERSION *ver)
 
 int set_tabsize(int tabsize)
 {
-    PDC_LOG(("set_tabsize() - called: tabsize %d\n", tabsize));
+    PDC_LOG("set_tabsize() - called: tabsize %d\n", tabsize);
 
     if (tabsize < 1)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/inopts.c b/lib/PDCursesMod/pdcurses/inopts.c
index 13b7d120ab6..ab42af487fb 100644
--- a/lib/PDCursesMod/pdcurses/inopts.c
+++ b/lib/PDCursesMod/pdcurses/inopts.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -127,7 +127,7 @@ inopts
 
 int cbreak(void)
 {
-    PDC_LOG(("cbreak() - called\n"));
+    PDC_LOG("cbreak() - called\n");
 
     assert( SP);
     if (!SP)
@@ -140,7 +140,7 @@ int cbreak(void)
 
 int nocbreak(void)
 {
-    PDC_LOG(("nocbreak() - called\n"));
+    PDC_LOG("nocbreak() - called\n");
 
     assert( SP);
     if (!SP)
@@ -154,7 +154,7 @@ int nocbreak(void)
 
 int echo(void)
 {
-    PDC_LOG(("echo() - called\n"));
+    PDC_LOG("echo() - called\n");
 
     assert( SP);
     if (!SP)
@@ -167,7 +167,7 @@ int echo(void)
 
 int noecho(void)
 {
-    PDC_LOG(("noecho() - called\n"));
+    PDC_LOG("noecho() - called\n");
 
     assert( SP);
     if (!SP)
@@ -180,7 +180,7 @@ int noecho(void)
 
 int halfdelay(int tenths)
 {
-    PDC_LOG(("halfdelay() - called\n"));
+    PDC_LOG("halfdelay() - called\n");
 
     assert( SP);
     if (!SP || tenths < 1 || tenths > 255)
@@ -193,7 +193,7 @@ int halfdelay(int tenths)
 
 int intrflush(WINDOW *win, bool bf)
 {
-    PDC_LOG(("intrflush() - called\n"));
+    PDC_LOG("intrflush() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( win);
     INTENTIONALLY_UNUSED_PARAMETER( bf);
@@ -202,7 +202,7 @@ int intrflush(WINDOW *win, bool bf)
 
 int keypad(WINDOW *win, bool bf)
 {
-    PDC_LOG(("keypad() - called\n"));
+    PDC_LOG("keypad() - called\n");
 
     assert( win);
     if (!win)
@@ -215,7 +215,7 @@ int keypad(WINDOW *win, bool bf)
 
 int meta(WINDOW *win, bool bf)
 {
-    PDC_LOG(("meta() - called\n"));
+    PDC_LOG("meta() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( win);
     assert( SP);
@@ -229,7 +229,7 @@ int meta(WINDOW *win, bool bf)
 
 int nl(void)
 {
-    PDC_LOG(("nl() - called\n"));
+    PDC_LOG("nl() - called\n");
 
     assert( SP);
     if (!SP)
@@ -242,7 +242,7 @@ int nl(void)
 
 int nonl(void)
 {
-    PDC_LOG(("nonl() - called\n"));
+    PDC_LOG("nonl() - called\n");
 
     assert( SP);
     if (!SP)
@@ -255,7 +255,7 @@ int nonl(void)
 
 int nodelay(WINDOW *win, bool flag)
 {
-    PDC_LOG(("nodelay() - called\n"));
+    PDC_LOG("nodelay() - called\n");
 
     assert( win);
     if (!win)
@@ -268,7 +268,7 @@ int nodelay(WINDOW *win, bool flag)
 
 int notimeout(WINDOW *win, bool flag)
 {
-    PDC_LOG(("notimeout() - called\n"));
+    PDC_LOG("notimeout() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( win);
     INTENTIONALLY_UNUSED_PARAMETER( flag);
@@ -277,7 +277,7 @@ int notimeout(WINDOW *win, bool flag)
 
 int raw(void)
 {
-    PDC_LOG(("raw() - called\n"));
+    PDC_LOG("raw() - called\n");
 
     assert( SP);
     if (!SP)
@@ -291,7 +291,7 @@ int raw(void)
 
 int noraw(void)
 {
-    PDC_LOG(("noraw() - called\n"));
+    PDC_LOG("noraw() - called\n");
 
     assert( SP);
     if (!SP)
@@ -305,25 +305,25 @@ int noraw(void)
 
 void noqiflush(void)
 {
-    PDC_LOG(("noqiflush() - called\n"));
+    PDC_LOG("noqiflush() - called\n");
 }
 
 void qiflush(void)
 {
-    PDC_LOG(("qiflush() - called\n"));
+    PDC_LOG("qiflush() - called\n");
 }
 
 int typeahead(int fildes)
 {
     INTENTIONALLY_UNUSED_PARAMETER( fildes);
-    PDC_LOG(("typeahead() - called\n"));
+    PDC_LOG("typeahead() - called\n");
 
     return OK;
 }
 
 void wtimeout(WINDOW *win, int delay)
 {
-    PDC_LOG(("wtimeout() - called\n"));
+    PDC_LOG("wtimeout() - called\n");
 
     assert( win);
     if (!win)
@@ -358,28 +358,28 @@ void wtimeout(WINDOW *win, int delay)
 
 void timeout(int delay)
 {
-    PDC_LOG(("timeout() - called\n"));
+    PDC_LOG("timeout() - called\n");
 
     wtimeout(stdscr, delay);
 }
 
 int crmode(void)
 {
-    PDC_LOG(("crmode() - called\n"));
+    PDC_LOG("crmode() - called\n");
 
     return cbreak();
 }
 
 int nocrmode(void)
 {
-    PDC_LOG(("nocrmode() - called\n"));
+    PDC_LOG("nocrmode() - called\n");
 
     return nocbreak();
 }
 
 bool is_keypad(const WINDOW *win)
 {
-    PDC_LOG(("is_keypad() - called\n"));
+    PDC_LOG("is_keypad() - called\n");
 
     assert( win);
     if (!win)
diff --git a/lib/PDCursesMod/pdcurses/insch.c b/lib/PDCursesMod/pdcurses/insch.c
index cf829fe2134..3107eef373a 100644
--- a/lib/PDCursesMod/pdcurses/insch.c
+++ b/lib/PDCursesMod/pdcurses/insch.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -69,8 +69,8 @@ int winsch(WINDOW *win, chtype ch)
     chtype attr;
     bool xlat;
 
-    PDC_LOG(("winsch() - called: win=%p ch=%x (text=%c attr=0x%x)\n",
-             win, ch, ch & A_CHARTEXT, ch & A_ATTRIBUTES));
+    PDC_LOG("winsch() - called: win=%p ch=%x (text=%c attr=0x%x)\n",
+             win, ch, ch & A_CHARTEXT, ch & A_ATTRIBUTES);
 
     assert( win);
     if (!win)
@@ -171,14 +171,14 @@ int winsch(WINDOW *win, chtype ch)
 
 int insch(chtype ch)
 {
-    PDC_LOG(("insch() - called\n"));
+    PDC_LOG("insch() - called\n");
 
     return winsch(stdscr, ch);
 }
 
 int mvinsch(int y, int x, chtype ch)
 {
-    PDC_LOG(("mvinsch() - called\n"));
+    PDC_LOG("mvinsch() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -188,7 +188,7 @@ int mvinsch(int y, int x, chtype ch)
 
 int mvwinsch(WINDOW *win, int y, int x, chtype ch)
 {
-    PDC_LOG(("mvwinsch() - called\n"));
+    PDC_LOG("mvwinsch() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -198,9 +198,9 @@ int mvwinsch(WINDOW *win, int y, int x, chtype ch)
 
 int winsrawch(WINDOW *win, chtype ch)
 {
-    PDC_LOG(("winsrawch() - called: win=%p ch=%x "
+    PDC_LOG("winsrawch() - called: win=%p ch=%x "
              "(char=%c attr=0x%x)\n", win, ch,
-             ch & A_CHARTEXT, ch & A_ATTRIBUTES));
+             ch & A_CHARTEXT, ch & A_ATTRIBUTES);
 
     if ((ch & A_CHARTEXT) < ' ' || (ch & A_CHARTEXT) == 0x7f)
         ch |= A_ALTCHARSET;
@@ -210,14 +210,14 @@ int winsrawch(WINDOW *win, chtype ch)
 
 int insrawch(chtype ch)
 {
-    PDC_LOG(("insrawch() - called\n"));
+    PDC_LOG("insrawch() - called\n");
 
     return winsrawch(stdscr, ch);
 }
 
 int mvinsrawch(int y, int x, chtype ch)
 {
-    PDC_LOG(("mvinsrawch() - called\n"));
+    PDC_LOG("mvinsrawch() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -227,7 +227,7 @@ int mvinsrawch(int y, int x, chtype ch)
 
 int mvwinsrawch(WINDOW *win, int y, int x, chtype ch)
 {
-    PDC_LOG(("mvwinsrawch() - called\n"));
+    PDC_LOG("mvwinsrawch() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -238,7 +238,7 @@ int mvwinsrawch(WINDOW *win, int y, int x, chtype ch)
 #ifdef PDC_WIDE
 int wins_wch(WINDOW *win, const cchar_t *wch)
 {
-    PDC_LOG(("wins_wch() - called\n"));
+    PDC_LOG("wins_wch() - called\n");
 
     assert( win);
     assert( wch);
@@ -247,14 +247,14 @@ int wins_wch(WINDOW *win, const cchar_t *wch)
 
 int ins_wch(const cchar_t *wch)
 {
-    PDC_LOG(("ins_wch() - called\n"));
+    PDC_LOG("ins_wch() - called\n");
 
     return wins_wch(stdscr, wch);
 }
 
 int mvins_wch(int y, int x, const cchar_t *wch)
 {
-    PDC_LOG(("mvins_wch() - called\n"));
+    PDC_LOG("mvins_wch() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -264,7 +264,7 @@ int mvins_wch(int y, int x, const cchar_t *wch)
 
 int mvwins_wch(WINDOW *win, int y, int x, const cchar_t *wch)
 {
-    PDC_LOG(("mvwins_wch() - called\n"));
+    PDC_LOG("mvwins_wch() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/insstr.c b/lib/PDCursesMod/pdcurses/insstr.c
index e35d850b532..62d5ee014c7 100644
--- a/lib/PDCursesMod/pdcurses/insstr.c
+++ b/lib/PDCursesMod/pdcurses/insstr.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -76,7 +76,7 @@ int winsnstr(WINDOW *win, const char *str, int n)
 #endif
     int len;
 
-    PDC_LOG(("winsnstr() - called: string=\"%s\" n %d \n", str, n));
+    PDC_LOG("winsnstr() - called: string=\"%s\" n %d \n", str, n);
 
     assert( win);
     assert( str);
@@ -118,21 +118,21 @@ int winsnstr(WINDOW *win, const char *str, int n)
 
 int insstr(const char *str)
 {
-    PDC_LOG(("insstr() - called: string=\"%s\"\n", str));
+    PDC_LOG("insstr() - called: string=\"%s\"\n", str);
 
     return winsnstr(stdscr, str, -1);
 }
 
 int winsstr(WINDOW *win, const char *str)
 {
-    PDC_LOG(("winsstr() - called: string=\"%s\"\n", str));
+    PDC_LOG("winsstr() - called: string=\"%s\"\n", str);
 
     return winsnstr(win, str, -1);
 }
 
 int mvinsstr(int y, int x, const char *str)
 {
-    PDC_LOG(("mvinsstr() - called: y %d x %d string=\"%s\"\n", y, x, str));
+    PDC_LOG("mvinsstr() - called: y %d x %d string=\"%s\"\n", y, x, str);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -142,7 +142,7 @@ int mvinsstr(int y, int x, const char *str)
 
 int mvwinsstr(WINDOW *win, int y, int x, const char *str)
 {
-    PDC_LOG(("mvwinsstr() - called: string=\"%s\"\n", str));
+    PDC_LOG("mvwinsstr() - called: string=\"%s\"\n", str);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -152,15 +152,15 @@ int mvwinsstr(WINDOW *win, int y, int x, const char *str)
 
 int insnstr(const char *str, int n)
 {
-    PDC_LOG(("insnstr() - called: string=\"%s\" n %d \n", str, n));
+    PDC_LOG("insnstr() - called: string=\"%s\" n %d \n", str, n);
 
     return winsnstr(stdscr, str, n);
 }
 
 int mvinsnstr(int y, int x, const char *str, int n)
 {
-    PDC_LOG(("mvinsnstr() - called: y %d x %d string=\"%s\" n %d \n",
-             y, x, str, n));
+    PDC_LOG("mvinsnstr() - called: y %d x %d string=\"%s\" n %d \n",
+             y, x, str, n);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -170,8 +170,8 @@ int mvinsnstr(int y, int x, const char *str, int n)
 
 int mvwinsnstr(WINDOW *win, int y, int x, const char *str, int n)
 {
-    PDC_LOG(("mvwinsnstr() - called: y %d x %d string=\"%s\" n %d \n",
-             y, x, str, n));
+    PDC_LOG("mvwinsnstr() - called: y %d x %d string=\"%s\" n %d \n",
+             y, x, str, n);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -185,7 +185,7 @@ int wins_nwstr(WINDOW *win, const wchar_t *wstr, int n)
     const wchar_t *p;
     int len;
 
-    PDC_LOG(("wins_nwstr() - called\n"));
+    PDC_LOG("wins_nwstr() - called\n");
 
     assert( win);
     assert( wstr);
@@ -207,21 +207,21 @@ int wins_nwstr(WINDOW *win, const wchar_t *wstr, int n)
 
 int ins_wstr(const wchar_t *wstr)
 {
-    PDC_LOG(("ins_wstr() - called\n"));
+    PDC_LOG("ins_wstr() - called\n");
 
     return wins_nwstr(stdscr, wstr, -1);
 }
 
 int wins_wstr(WINDOW *win, const wchar_t *wstr)
 {
-    PDC_LOG(("wins_wstr() - called\n"));
+    PDC_LOG("wins_wstr() - called\n");
 
     return wins_nwstr(win, wstr, -1);
 }
 
 int mvins_wstr(int y, int x, const wchar_t *wstr)
 {
-    PDC_LOG(("mvins_wstr() - called\n"));
+    PDC_LOG("mvins_wstr() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -231,7 +231,7 @@ int mvins_wstr(int y, int x, const wchar_t *wstr)
 
 int mvwins_wstr(WINDOW *win, int y, int x, const wchar_t *wstr)
 {
-    PDC_LOG(("mvwinsstr() - called\n"));
+    PDC_LOG("mvwinsstr() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -241,14 +241,14 @@ int mvwins_wstr(WINDOW *win, int y, int x, const wchar_t *wstr)
 
 int ins_nwstr(const wchar_t *wstr, int n)
 {
-    PDC_LOG(("ins_nwstr() - called\n"));
+    PDC_LOG("ins_nwstr() - called\n");
 
     return wins_nwstr(stdscr, wstr, n);
 }
 
 int mvins_nwstr(int y, int x, const wchar_t *wstr, int n)
 {
-    PDC_LOG(("mvinsnstr() - called\n"));
+    PDC_LOG("mvinsnstr() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -258,7 +258,7 @@ int mvins_nwstr(int y, int x, const wchar_t *wstr, int n)
 
 int mvwins_nwstr(WINDOW *win, int y, int x, const wchar_t *wstr, int n)
 {
-    PDC_LOG(("mvwinsnstr() - called\n"));
+    PDC_LOG("mvwinsnstr() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/instr.c b/lib/PDCursesMod/pdcurses/instr.c
index 42194a9ac9e..dcf29db9cf9 100644
--- a/lib/PDCursesMod/pdcurses/instr.c
+++ b/lib/PDCursesMod/pdcurses/instr.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -83,7 +83,7 @@ int winnstr(WINDOW *win, char *str, int n)
 
     assert( win);
     assert( str);
-    PDC_LOG(("winnstr() - called: n %d \n", n));
+    PDC_LOG("winnstr() - called: n %d \n", n);
 
     if (!win || !str)
         return ERR;
@@ -104,21 +104,21 @@ int winnstr(WINDOW *win, char *str, int n)
 
 int instr(char *str)
 {
-    PDC_LOG(("instr() - called: string=\"%s\"\n", str));
+    PDC_LOG("instr() - called: string=\"%s\"\n", str);
 
     return (ERR == winnstr(stdscr, str, stdscr->_maxx)) ? ERR : OK;
 }
 
 int winstr(WINDOW *win, char *str)
 {
-    PDC_LOG(("winstr() - called: \n"));
+    PDC_LOG("winstr() - called: \n");
 
     return (ERR == winnstr(win, str, win->_maxx)) ? ERR : OK;
 }
 
 int mvinstr(int y, int x, char *str)
 {
-    PDC_LOG(("mvinstr() - called: y %d x %d \n", y, x));
+    PDC_LOG("mvinstr() - called: y %d x %d \n", y, x);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -128,7 +128,7 @@ int mvinstr(int y, int x, char *str)
 
 int mvwinstr(WINDOW *win, int y, int x, char *str)
 {
-    PDC_LOG(("mvwinstr() - called: y %d x %d \n", y, x));
+    PDC_LOG("mvwinstr() - called: y %d x %d \n", y, x);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -138,14 +138,14 @@ int mvwinstr(WINDOW *win, int y, int x, char *str)
 
 int innstr(char *str, int n)
 {
-    PDC_LOG(("innstr() - called: n %d \n", n));
+    PDC_LOG("innstr() - called: n %d \n", n);
 
     return winnstr(stdscr, str, n);
 }
 
 int mvinnstr(int y, int x, char *str, int n)
 {
-    PDC_LOG(("mvinnstr() - called: y %d x %d n %d \n", y, x, n));
+    PDC_LOG("mvinnstr() - called: y %d x %d n %d \n", y, x, n);
 
     if (move(y, x) == ERR)
         return ERR;
@@ -155,7 +155,7 @@ int mvinnstr(int y, int x, char *str, int n)
 
 int mvwinnstr(WINDOW *win, int y, int x, char *str, int n)
 {
-    PDC_LOG(("mvwinnstr() - called: y %d x %d n %d \n", y, x, n));
+    PDC_LOG("mvwinnstr() - called: y %d x %d n %d \n", y, x, n);
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -169,7 +169,7 @@ int winnwstr(WINDOW *win, wchar_t *wstr, int n)
     chtype *src;
     int i;
 
-    PDC_LOG(("winnstr() - called: n %d \n", n));
+    PDC_LOG("winnstr() - called: n %d \n", n);
 
     assert( win);
     assert( wstr);
@@ -191,21 +191,21 @@ int winnwstr(WINDOW *win, wchar_t *wstr, int n)
 
 int inwstr(wchar_t *wstr)
 {
-    PDC_LOG(("inwstr() - called\n"));
+    PDC_LOG("inwstr() - called\n");
 
     return (ERR == winnwstr(stdscr, wstr, stdscr->_maxx)) ? ERR : OK;
 }
 
 int winwstr(WINDOW *win, wchar_t *wstr)
 {
-    PDC_LOG(("winwstr() - called\n"));
+    PDC_LOG("winwstr() - called\n");
 
     return (ERR == winnwstr(win, wstr, win->_maxx)) ? ERR : OK;
 }
 
 int mvinwstr(int y, int x, wchar_t *wstr)
 {
-    PDC_LOG(("mvinwstr() - called\n"));
+    PDC_LOG("mvinwstr() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -215,7 +215,7 @@ int mvinwstr(int y, int x, wchar_t *wstr)
 
 int mvwinwstr(WINDOW *win, int y, int x, wchar_t *wstr)
 {
-    PDC_LOG(("mvwinstr() - called\n"));
+    PDC_LOG("mvwinstr() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -225,14 +225,14 @@ int mvwinwstr(WINDOW *win, int y, int x, wchar_t *wstr)
 
 int innwstr(wchar_t *wstr, int n)
 {
-    PDC_LOG(("innwstr() - called\n"));
+    PDC_LOG("innwstr() - called\n");
 
     return winnwstr(stdscr, wstr, n);
 }
 
 int mvinnwstr(int y, int x, wchar_t *wstr, int n)
 {
-    PDC_LOG(("mvinnstr() - called\n"));
+    PDC_LOG("mvinnstr() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -242,7 +242,7 @@ int mvinnwstr(int y, int x, wchar_t *wstr, int n)
 
 int mvwinnwstr(WINDOW *win, int y, int x, wchar_t *wstr, int n)
 {
-    PDC_LOG(("mvwinnwstr() - called\n"));
+    PDC_LOG("mvwinnwstr() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
diff --git a/lib/PDCursesMod/pdcurses/kernel.c b/lib/PDCursesMod/pdcurses/kernel.c
index 67efff4cb56..5b76b1605b7 100644
--- a/lib/PDCursesMod/pdcurses/kernel.c
+++ b/lib/PDCursesMod/pdcurses/kernel.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -139,7 +139,7 @@ static int _restore_mode(int i)
 
 int def_prog_mode(void)
 {
-    PDC_LOG(("def_prog_mode() - called\n"));
+    PDC_LOG("def_prog_mode() - called\n");
 
     assert( SP);
     if (!SP)
@@ -152,7 +152,7 @@ int def_prog_mode(void)
 
 int def_shell_mode(void)
 {
-    PDC_LOG(("def_shell_mode() - called\n"));
+    PDC_LOG("def_shell_mode() - called\n");
 
     assert( SP);
     if (!SP)
@@ -165,7 +165,7 @@ int def_shell_mode(void)
 
 int reset_prog_mode(void)
 {
-    PDC_LOG(("reset_prog_mode() - called\n"));
+    PDC_LOG("reset_prog_mode() - called\n");
 
     assert( SP);
     if (!SP)
@@ -179,7 +179,7 @@ int reset_prog_mode(void)
 
 int reset_shell_mode(void)
 {
-    PDC_LOG(("reset_shell_mode() - called\n"));
+    PDC_LOG("reset_shell_mode() - called\n");
 
     assert( SP);
     if (!SP)
@@ -193,7 +193,7 @@ int reset_shell_mode(void)
 
 int resetty(void)
 {
-    PDC_LOG(("resetty() - called\n"));
+    PDC_LOG("resetty() - called\n");
 
     assert( SP);
     if (!SP)
@@ -204,7 +204,7 @@ int resetty(void)
 
 int savetty(void)
 {
-    PDC_LOG(("savetty() - called\n"));
+    PDC_LOG("savetty() - called\n");
 
     assert( SP);
     if (!SP)
@@ -219,7 +219,7 @@ int curs_set(int visibility)
 {
     int ret_vis;
 
-    PDC_LOG(("curs_set() - called: visibility=%d\n", visibility));
+    PDC_LOG("curs_set() - called: visibility=%d\n", visibility);
 
     if ((visibility < 0) || (visibility > 0x10000))
         return ERR;
@@ -240,7 +240,7 @@ on some platforms,  but is it true for all?  */
 
 int napms(int ms)
 {
-    PDC_LOG(("napms() - called: ms=%d\n", ms));
+    PDC_LOG("napms() - called: ms=%d\n", ms);
 
     assert( SP);
     if (!SP)
@@ -269,7 +269,7 @@ int napms(int ms)
 
 int ripoffline(int line, int (*init)(WINDOW *, int))
 {
-    PDC_LOG(("ripoffline() - called: line=%d\n", line));
+    PDC_LOG("ripoffline() - called: line=%d\n", line);
 
     assert( init);
     if (linesrippedoff < 5 && line && init)
@@ -285,28 +285,28 @@ int ripoffline(int line, int (*init)(WINDOW *, int))
 
 int draino(int ms)
 {
-    PDC_LOG(("draino() - called\n"));
+    PDC_LOG("draino() - called\n");
 
     return napms(ms);
 }
 
 int resetterm(void)
 {
-    PDC_LOG(("resetterm() - called\n"));
+    PDC_LOG("resetterm() - called\n");
 
     return reset_shell_mode();
 }
 
 int fixterm(void)
 {
-    PDC_LOG(("fixterm() - called\n"));
+    PDC_LOG("fixterm() - called\n");
 
     return reset_prog_mode();
 }
 
 int saveterm(void)
 {
-    PDC_LOG(("saveterm() - called\n"));
+    PDC_LOG("saveterm() - called\n");
 
     return def_prog_mode();
 }
diff --git a/lib/PDCursesMod/pdcurses/keyname.c b/lib/PDCursesMod/pdcurses/keyname.c
index f81c83384f1..ec3d12b94f0 100644
--- a/lib/PDCursesMod/pdcurses/keyname.c
+++ b/lib/PDCursesMod/pdcurses/keyname.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 
 /*man-start**************************************************************
 
@@ -114,7 +114,7 @@ char *keyname(int key)
               "LAUNCH_APP5", "LAUNCH_APP6", "LAUNCH_APP7", "LAUNCH_APP8",
               "LAUNCH_APP9", "LAUNCH_APP10" };
 
-    PDC_LOG(("keyname() - called: key %d\n", key));
+    PDC_LOG("keyname() - called: key %d\n", key);
 
     strcpy(_keyname, ((key >= 0) && (key < 0x80)) ? unctrl((chtype)key) :
            has_key(key) ? key_names[key - KEY_MIN] : "UNKNOWN KEY");
@@ -124,7 +124,7 @@ char *keyname(int key)
 
 bool has_key(int key)
 {
-    PDC_LOG(("has_key() - called: key %d\n", key));
+    PDC_LOG("has_key() - called: key %d\n", key);
 
     return (key >= KEY_MIN && key <= KEY_MAX);
 }
@@ -132,7 +132,7 @@ bool has_key(int key)
 #ifdef PDC_WIDE
 char *key_name(wchar_t c)
 {
-    PDC_LOG(("key_name() - called\n"));
+    PDC_LOG("key_name() - called\n");
 
     return keyname((int)c);
 }
diff --git a/lib/PDCursesMod/pdcurses/mouse.c b/lib/PDCursesMod/pdcurses/mouse.c
index c09d843857c..921f82c19d2 100644
--- a/lib/PDCursesMod/pdcurses/mouse.c
+++ b/lib/PDCursesMod/pdcurses/mouse.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -145,7 +145,7 @@ static bool ungot = FALSE;
 
 int mouse_set(mmask_t mbe)
 {
-    PDC_LOG(("mouse_set() - called: event %x\n", mbe));
+    PDC_LOG("mouse_set() - called: event %x\n", mbe);
 
     assert( SP);
     if (!SP)
@@ -157,7 +157,7 @@ int mouse_set(mmask_t mbe)
 
 int mouse_on(mmask_t mbe)
 {
-    PDC_LOG(("mouse_on() - called: event %x\n", mbe));
+    PDC_LOG("mouse_on() - called: event %x\n", mbe);
 
     assert( SP);
     if (!SP)
@@ -169,7 +169,7 @@ int mouse_on(mmask_t mbe)
 
 int mouse_off(mmask_t mbe)
 {
-    PDC_LOG(("mouse_off() - called: event %x\n", mbe));
+    PDC_LOG("mouse_off() - called: event %x\n", mbe);
 
     assert( SP);
     if (!SP)
@@ -181,7 +181,7 @@ int mouse_off(mmask_t mbe)
 
 int request_mouse_pos(void)
 {
-    PDC_LOG(("request_mouse_pos() - called\n"));
+    PDC_LOG("request_mouse_pos() - called\n");
 
     Mouse_status = SP->mouse_status;
 
@@ -190,7 +190,7 @@ int request_mouse_pos(void)
 
 void wmouse_position(WINDOW *win, int *y, int *x)
 {
-    PDC_LOG(("wmouse_position() - called\n"));
+    PDC_LOG("wmouse_position() - called\n");
 
     if (win && wenclose(win, MOUSE_Y_POS, MOUSE_X_POS))
     {
@@ -210,7 +210,7 @@ void wmouse_position(WINDOW *win, int *y, int *x)
 
 mmask_t getmouse(void)
 {
-    PDC_LOG(("getmouse() - called\n"));
+    PDC_LOG("getmouse() - called\n");
 
     assert( SP);
     return SP ? SP->_trap_mbe : (mmask_t)0;
@@ -224,7 +224,7 @@ int mouseinterval(int wait)
 {
     int old_wait;
 
-    PDC_LOG(("mouseinterval() - called: %d\n", wait));
+    PDC_LOG("mouseinterval() - called: %d\n", wait);
 
     if (!SP)
         return max_mouse_interval;
@@ -239,7 +239,7 @@ int mouseinterval(int wait)
 
 bool wenclose(const WINDOW *win, int y, int x)
 {
-    PDC_LOG(("wenclose() - called: %p %d %d\n", win, y, x));
+    PDC_LOG("wenclose() - called: %p %d %d\n", win, y, x);
 
     assert( win);
     return (win && y >= win->_begy && y < win->_begy + win->_maxy
@@ -250,7 +250,7 @@ bool wmouse_trafo(const WINDOW *win, int *y, int *x, bool to_screen)
 {
     int newy, newx;
 
-    PDC_LOG(("wmouse_trafo() - called\n"));
+    PDC_LOG("wmouse_trafo() - called\n");
 
     assert( win);
     assert( x);
@@ -288,14 +288,14 @@ bool wmouse_trafo(const WINDOW *win, int *y, int *x, bool to_screen)
 
 bool mouse_trafo(int *y, int *x, bool to_screen)
 {
-    PDC_LOG(("mouse_trafo() - called\n"));
+    PDC_LOG("mouse_trafo() - called\n");
 
     return wmouse_trafo(stdscr, y, x, to_screen);
 }
 
 mmask_t mousemask(mmask_t mask, mmask_t *oldmask)
 {
-    PDC_LOG(("mousemask() - called\n"));
+    PDC_LOG("mousemask() - called\n");
 
     assert( SP);
     if (!SP)
@@ -321,7 +321,7 @@ int nc_getmouse(MEVENT *event)
     int i;
     mmask_t bstate = 0;
 
-    PDC_LOG(("nc_getmouse() - called\n"));
+    PDC_LOG("nc_getmouse() - called\n");
 
     assert( SP);
     assert( event);
@@ -390,7 +390,7 @@ int ungetmouse(MEVENT *event)
     int i;
     mmask_t bstate;
 
-    PDC_LOG(("ungetmouse() - called\n"));
+    PDC_LOG("ungetmouse() - called\n");
 
     assert( event);
     if (!event || ungot)
diff --git a/lib/PDCursesMod/pdcurses/move.c b/lib/PDCursesMod/pdcurses/move.c
index db2bc9512a0..4f3b9b4648e 100644
--- a/lib/PDCursesMod/pdcurses/move.c
+++ b/lib/PDCursesMod/pdcurses/move.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -38,7 +38,7 @@ move
 
 int move(int y, int x)
 {
-    PDC_LOG(("move() - called: y=%d x=%d\n", y, x));
+    PDC_LOG("move() - called: y=%d x=%d\n", y, x);
 
     assert( stdscr);
     if (!stdscr || x < 0 || y < 0 || x >= stdscr->_maxx || y >= stdscr->_maxy)
@@ -52,8 +52,8 @@ int move(int y, int x)
 
 int mvcur(int oldrow, int oldcol, int newrow, int newcol)
 {
-    PDC_LOG(("mvcur() - called: oldrow %d oldcol %d newrow %d newcol %d\n",
-             oldrow, oldcol, newrow, newcol));
+    PDC_LOG("mvcur() - called: oldrow %d oldcol %d newrow %d newcol %d\n",
+             oldrow, oldcol, newrow, newcol);
 
     assert( SP);
     INTENTIONALLY_UNUSED_PARAMETER( oldrow);
@@ -70,7 +70,7 @@ int mvcur(int oldrow, int oldcol, int newrow, int newcol)
 
 int wmove(WINDOW *win, int y, int x)
 {
-    PDC_LOG(("wmove() - called: y=%d x=%d\n", y, x));
+    PDC_LOG("wmove() - called: y=%d x=%d\n", y, x);
 
     assert( win);
     if (!win || x < 0 || y < 0 || x >= win->_maxx || y >= win->_maxy)
diff --git a/lib/PDCursesMod/pdcurses/outopts.c b/lib/PDCursesMod/pdcurses/outopts.c
index 5e4110f4226..70c376f2e7a 100644
--- a/lib/PDCursesMod/pdcurses/outopts.c
+++ b/lib/PDCursesMod/pdcurses/outopts.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -74,7 +74,7 @@ outopts
 
 int clearok(WINDOW *win, bool bf)
 {
-    PDC_LOG(("clearok() - called\n"));
+    PDC_LOG("clearok() - called\n");
 
     assert( win);
     if (!win)
@@ -89,7 +89,7 @@ int idlok(WINDOW *win, bool bf)
 {
     INTENTIONALLY_UNUSED_PARAMETER( win);
     INTENTIONALLY_UNUSED_PARAMETER( bf);
-    PDC_LOG(("idlok() - called\n"));
+    PDC_LOG("idlok() - called\n");
 
     return OK;
 }
@@ -98,12 +98,12 @@ void idcok(WINDOW *win, bool bf)
 {
     INTENTIONALLY_UNUSED_PARAMETER( win);
     INTENTIONALLY_UNUSED_PARAMETER( bf);
-    PDC_LOG(("idcok() - called\n"));
+    PDC_LOG("idcok() - called\n");
 }
 
 void immedok(WINDOW *win, bool bf)
 {
-    PDC_LOG(("immedok() - called\n"));
+    PDC_LOG("immedok() - called\n");
 
     if (win)
         win->_immed = bf;
@@ -111,7 +111,7 @@ void immedok(WINDOW *win, bool bf)
 
 int leaveok(WINDOW *win, bool bf)
 {
-    PDC_LOG(("leaveok() - called\n"));
+    PDC_LOG("leaveok() - called\n");
 
     assert( win);
     if (!win)
@@ -126,14 +126,14 @@ int leaveok(WINDOW *win, bool bf)
 
 int setscrreg(int top, int bottom)
 {
-    PDC_LOG(("setscrreg() - called: top %d bottom %d\n", top, bottom));
+    PDC_LOG("setscrreg() - called: top %d bottom %d\n", top, bottom);
 
     return wsetscrreg(stdscr, top, bottom);
 }
 
 int wsetscrreg(WINDOW *win, int top, int bottom)
 {
-    PDC_LOG(("wsetscrreg() - called: top %d bottom %d\n", top, bottom));
+    PDC_LOG("wsetscrreg() - called: top %d bottom %d\n", top, bottom);
 
     assert( win);
     if (win && 0 <= top && top <= win->_cury &&
@@ -150,7 +150,7 @@ int wsetscrreg(WINDOW *win, int top, int bottom)
 
 int scrollok(WINDOW *win, bool bf)
 {
-    PDC_LOG(("scrollok() - called\n"));
+    PDC_LOG("scrollok() - called\n");
 
     assert( win);
     if (!win)
@@ -163,7 +163,7 @@ int scrollok(WINDOW *win, bool bf)
 
 int raw_output(bool bf)
 {
-    PDC_LOG(("raw_output() - called\n"));
+    PDC_LOG("raw_output() - called\n");
 
     assert( SP);
     if (!SP)
@@ -176,7 +176,7 @@ int raw_output(bool bf)
 
 bool is_leaveok(const WINDOW *win)
 {
-    PDC_LOG(("is_leaveok() - called\n"));
+    PDC_LOG("is_leaveok() - called\n");
 
     assert( win);
     if (!win)
diff --git a/lib/PDCursesMod/pdcurses/overlay.c b/lib/PDCursesMod/pdcurses/overlay.c
index 5b3b317085c..eb1b4431293 100644
--- a/lib/PDCursesMod/pdcurses/overlay.c
+++ b/lib/PDCursesMod/pdcurses/overlay.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -178,14 +178,14 @@ int _copy_overlap(const WINDOW *src_w, WINDOW *dst_w, bool overlay)
 
 int overlay(const WINDOW *src_w, WINDOW *dst_w)
 {
-    PDC_LOG(("overlay() - called\n"));
+    PDC_LOG("overlay() - called\n");
 
     return _copy_overlap(src_w, dst_w, TRUE);
 }
 
 int overwrite(const WINDOW *src_w, WINDOW *dst_w)
 {
-    PDC_LOG(("overwrite() - called\n"));
+    PDC_LOG("overwrite() - called\n");
 
     return _copy_overlap(src_w, dst_w, FALSE);
 }
@@ -197,7 +197,7 @@ int copywin(const WINDOW *src_w, WINDOW *dst_w, int src_tr, int src_tc,
     int src_rows, src_cols, dst_rows, dst_cols;
     int min_rows, min_cols;
 
-    PDC_LOG(("copywin() - called\n"));
+    PDC_LOG("copywin() - called\n");
 
     assert( src_w);
     assert( dst_w);
diff --git a/lib/PDCursesMod/pdcurses/pad.c b/lib/PDCursesMod/pdcurses/pad.c
index 53efc8bf0b6..2931a5a0e75 100644
--- a/lib/PDCursesMod/pdcurses/pad.c
+++ b/lib/PDCursesMod/pdcurses/pad.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -85,7 +85,7 @@ WINDOW *newpad(int nlines, int ncols)
 {
     WINDOW *win;
 
-    PDC_LOG(("newpad() - called: lines=%d cols=%d\n", nlines, ncols));
+    PDC_LOG("newpad() - called: lines=%d cols=%d\n", nlines, ncols);
 
     win = PDC_makenew(nlines, ncols, 0, 0);
     if (win)
@@ -116,8 +116,8 @@ WINDOW *subpad(WINDOW *orig, int nlines, int ncols, int begy, int begx)
     WINDOW *win;
     int i;
 
-    PDC_LOG(("subpad() - called: lines=%d cols=%d begy=%d begx=%d\n",
-             nlines, ncols, begy, begx));
+    PDC_LOG("subpad() - called: lines=%d cols=%d begy=%d begx=%d\n",
+             nlines, ncols, begy, begx);
 
     assert( orig);
     if (!orig || !(orig->_flags & _PAD))
@@ -169,7 +169,7 @@ WINDOW *subpad(WINDOW *orig, int nlines, int ncols, int begy, int begx)
 
 int prefresh(WINDOW *win, int py, int px, int sy1, int sx1, int sy2, int sx2)
 {
-    PDC_LOG(("prefresh() - called\n"));
+    PDC_LOG("prefresh() - called\n");
 
     if (pnoutrefresh(win, py, px, sy1, sx1, sy2, sx2) == ERR)
         return ERR;
@@ -184,7 +184,7 @@ int pnoutrefresh(WINDOW *w, int py, int px, int sy1, int sx1, int sy2, int sx2)
     int sline = sy1;
     int pline = py;
 
-    PDC_LOG(("pnoutrefresh() - called\n"));
+    PDC_LOG("pnoutrefresh() - called\n");
 
     assert( w);
     if (!w || !(w->_flags & (_PAD|_SUBPAD)) || (sy2 >= LINES) || (sx2 >= COLS))
@@ -248,7 +248,7 @@ int pnoutrefresh(WINDOW *w, int py, int px, int sy1, int sx1, int sy2, int sx2)
 
 int pechochar(WINDOW *pad, chtype ch)
 {
-    PDC_LOG(("pechochar() - called\n"));
+    PDC_LOG("pechochar() - called\n");
 
     if (waddch(pad, ch) == ERR)
         return ERR;
@@ -260,7 +260,7 @@ int pechochar(WINDOW *pad, chtype ch)
 #ifdef PDC_WIDE
 int pecho_wchar(WINDOW *pad, const cchar_t *wch)
 {
-    PDC_LOG(("pecho_wchar() - called\n"));
+    PDC_LOG("pecho_wchar() - called\n");
 
     assert( wch);
     if (!wch || (waddch(pad, *wch) == ERR))
@@ -273,7 +273,7 @@ int pecho_wchar(WINDOW *pad, const cchar_t *wch)
 
 bool is_pad(const WINDOW *pad)
 {
-    PDC_LOG(("is_pad() - called\n"));
+    PDC_LOG("is_pad() - called\n");
 
     assert( pad);
     if (!pad)
diff --git a/lib/PDCursesMod/pdcurses/panel.c b/lib/PDCursesMod/pdcurses/panel.c
index 15ddba5c33d..9b54960a474 100644
--- a/lib/PDCursesMod/pdcurses/panel.c
+++ b/lib/PDCursesMod/pdcurses/panel.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -127,7 +127,7 @@ panel
 
 **man-end****************************************************************/
 
-#include <panel.h>
+#include <PDCurses/panel.h>
 #include <stdlib.h>
 
 PANEL *_bottom_panel = (PANEL *)0;
@@ -138,10 +138,10 @@ PANEL _stdscr_pseudo_panel;
 
 static void dPanel(char *text, PANEL *pan)
 {
-    PDC_LOG(("%s id=%s b=%s a=%s y=%d x=%d", text, pan->user,
+    PDC_LOG("%s id=%s b=%s a=%s y=%d x=%d", text, pan->user,
              pan->below ? pan->below->user : "--",
              pan->above ? pan->above->user : "--",
-             pan->wstarty, pan->wstartx));
+             pan->wstarty, pan->wstartx);
 }
 
 static void dStack(char *fmt, int num, PANEL *pan)
@@ -149,11 +149,11 @@ static void dStack(char *fmt, int num, PANEL *pan)
     char s80[80];
 
     sprintf(s80, fmt, num, pan);
-    PDC_LOG(("%s b=%s t=%s", s80, _bottom_panel ? _bottom_panel->user : "--",
-             _top_panel    ? _top_panel->user    : "--"));
+    PDC_LOG("%s b=%s t=%s", s80, _bottom_panel ? _bottom_panel->user : "--",
+             _top_panel    ? _top_panel->user    : "--");
 
     if (pan)
-        PDC_LOG(("pan id=%s", pan->user));
+        PDC_LOG("pan id=%s", pan->user);
 
     pan = _bottom_panel;
 
@@ -575,7 +575,7 @@ const void *panel_userptr(const PANEL *pan)
 
 WINDOW *panel_window(const PANEL *pan)
 {
-    PDC_LOG(("panel_window() - called\n"));
+    PDC_LOG("panel_window() - called\n");
 
     assert( pan);
     if (!pan)
@@ -645,7 +645,7 @@ void update_panels(void)
 {
     PANEL *pan;
 
-    PDC_LOG(("update_panels() - called\n"));
+    PDC_LOG("update_panels() - called\n");
 
     pan = _bottom_panel;
 
diff --git a/lib/PDCursesMod/pdcurses/printw.c b/lib/PDCursesMod/pdcurses/printw.c
index 7d19a9978ea..7a89f6056b8 100644
--- a/lib/PDCursesMod/pdcurses/printw.c
+++ b/lib/PDCursesMod/pdcurses/printw.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 
 /*man-start**************************************************************
 
@@ -49,7 +49,7 @@ int vwprintw(WINDOW *win, const char *fmt, va_list varglist)
     char printbuf[513];
     int len;
 
-    PDC_LOG(("vwprintw() - called\n"));
+    PDC_LOG("vwprintw() - called\n");
 
 #ifdef HAVE_VSNPRINTF
     len = vsnprintf(printbuf, 512, fmt, varglist);
@@ -64,7 +64,7 @@ int printw(const char *fmt, ...)
     va_list args;
     int retval;
 
-    PDC_LOG(("printw() - called\n"));
+    PDC_LOG("printw() - called\n");
 
     va_start(args, fmt);
     retval = vwprintw(stdscr, fmt, args);
@@ -78,7 +78,7 @@ int wprintw(WINDOW *win, const char *fmt, ...)
     va_list args;
     int retval;
 
-    PDC_LOG(("wprintw() - called\n"));
+    PDC_LOG("wprintw() - called\n");
 
     va_start(args, fmt);
     retval = vwprintw(win, fmt, args);
@@ -92,7 +92,7 @@ int mvprintw(int y, int x, const char *fmt, ...)
     va_list args;
     int retval;
 
-    PDC_LOG(("mvprintw() - called\n"));
+    PDC_LOG("mvprintw() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -109,7 +109,7 @@ int mvwprintw(WINDOW *win, int y, int x, const char *fmt, ...)
     va_list args;
     int retval;
 
-    PDC_LOG(("mvwprintw() - called\n"));
+    PDC_LOG("mvwprintw() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -123,7 +123,7 @@ int mvwprintw(WINDOW *win, int y, int x, const char *fmt, ...)
 
 int vw_printw(WINDOW *win, const char *fmt, va_list varglist)
 {
-    PDC_LOG(("vw_printw() - called\n"));
+    PDC_LOG("vw_printw() - called\n");
 
     return vwprintw(win, fmt, varglist);
 }
diff --git a/lib/PDCursesMod/pdcurses/refresh.c b/lib/PDCursesMod/pdcurses/refresh.c
index 9531abce76f..4a075eeb47a 100644
--- a/lib/PDCursesMod/pdcurses/refresh.c
+++ b/lib/PDCursesMod/pdcurses/refresh.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -75,7 +75,7 @@ int wnoutrefresh(WINDOW *win)
     int begy, begx;     /* window's place on screen   */
     int i, j;
 
-    PDC_LOG(("wnoutrefresh() - called: win=%p\n", win));
+    PDC_LOG("wnoutrefresh() - called: win=%p\n", win);
 
     assert( win);
     if ( !win || (win->_flags & (_PAD|_SUBPAD)) )
@@ -150,7 +150,7 @@ int doupdate(void)
     int y;
     bool clearall;
 
-    PDC_LOG(("doupdate() - called\n"));
+    PDC_LOG("doupdate() - called\n");
 
     assert( SP);
     assert( curscr);
@@ -168,9 +168,9 @@ int doupdate(void)
 
     for (y = 0; y < SP->lines; y++)
     {
-        PDC_LOG(("doupdate() - Transforming line %d of %d: %s\n",
+        PDC_LOG("doupdate() - Transforming line %d of %d: %s\n",
                  y, SP->lines, (curscr->_firstch[y] != _NO_CHANGE) ?
-                 "Yes" : "No"));
+                 "Yes" : "No");
 
         if (clearall || curscr->_firstch[y] != _NO_CHANGE)
         {
@@ -246,7 +246,7 @@ int wrefresh(WINDOW *win)
 {
     bool save_clear;
 
-    PDC_LOG(("wrefresh() - called\n"));
+    PDC_LOG("wrefresh() - called\n");
 
     assert( win);
     if ( !win || (win->_flags & (_PAD|_SUBPAD)) )
@@ -267,7 +267,7 @@ int wrefresh(WINDOW *win)
 
 int refresh(void)
 {
-    PDC_LOG(("refresh() - called\n"));
+    PDC_LOG("refresh() - called\n");
 
     return wrefresh(stdscr);
 }
@@ -276,8 +276,8 @@ int wredrawln(WINDOW *win, int start, int num)
 {
     int i;
 
-    PDC_LOG(("wredrawln() - called: win=%p start=%d num=%d\n",
-        win, start, num));
+    PDC_LOG("wredrawln() - called: win=%p start=%d num=%d\n",
+        win, start, num);
 
     assert( win);
     if (!win || start > win->_maxy || start + num > win->_maxy)
@@ -294,7 +294,7 @@ int wredrawln(WINDOW *win, int start, int num)
 
 int redrawwin(WINDOW *win)
 {
-    PDC_LOG(("redrawwin() - called: win=%p\n", win));
+    PDC_LOG("redrawwin() - called: win=%p\n", win);
 
     assert( win);
     if (!win)
diff --git a/lib/PDCursesMod/pdcurses/scanw.c b/lib/PDCursesMod/pdcurses/scanw.c
index 23a2d412a3a..9fff6dd5d81 100644
--- a/lib/PDCursesMod/pdcurses/scanw.c
+++ b/lib/PDCursesMod/pdcurses/scanw.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 
 /*man-start**************************************************************
 
@@ -57,7 +57,7 @@ int vwscanw(WINDOW *win, const char *fmt, va_list varglist)
 {
     char scanbuf[256];
 
-    PDC_LOG(("vwscanw() - called\n"));
+    PDC_LOG("vwscanw() - called\n");
 
     if (wgetnstr(win, scanbuf, 255) == ERR)
         return ERR;
@@ -70,7 +70,7 @@ int scanw(const char *fmt, ...)
     va_list args;
     int retval;
 
-    PDC_LOG(("scanw() - called\n"));
+    PDC_LOG("scanw() - called\n");
 
     va_start(args, fmt);
     retval = vwscanw(stdscr, fmt, args);
@@ -84,7 +84,7 @@ int wscanw(WINDOW *win, const char *fmt, ...)
     va_list args;
     int retval;
 
-    PDC_LOG(("wscanw() - called\n"));
+    PDC_LOG("wscanw() - called\n");
 
     va_start(args, fmt);
     retval = vwscanw(win, fmt, args);
@@ -98,7 +98,7 @@ int mvscanw(int y, int x, const char *fmt, ...)
     va_list args;
     int retval;
 
-    PDC_LOG(("mvscanw() - called\n"));
+    PDC_LOG("mvscanw() - called\n");
 
     if (move(y, x) == ERR)
         return ERR;
@@ -115,7 +115,7 @@ int mvwscanw(WINDOW *win, int y, int x, const char *fmt, ...)
     va_list args;
     int retval;
 
-    PDC_LOG(("mvscanw() - called\n"));
+    PDC_LOG("mvscanw() - called\n");
 
     if (wmove(win, y, x) == ERR)
         return ERR;
@@ -129,7 +129,7 @@ int mvwscanw(WINDOW *win, int y, int x, const char *fmt, ...)
 
 int vw_scanw(WINDOW *win, const char *fmt, va_list varglist)
 {
-    PDC_LOG(("vw_scanw() - called\n"));
+    PDC_LOG("vw_scanw() - called\n");
 
     return vwscanw(win, fmt, varglist);
 }
diff --git a/lib/PDCursesMod/pdcurses/scr_dump.c b/lib/PDCursesMod/pdcurses/scr_dump.c
index 1f413f1a2e2..68307548db7 100644
--- a/lib/PDCursesMod/pdcurses/scr_dump.c
+++ b/lib/PDCursesMod/pdcurses/scr_dump.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 
 /*man-start**************************************************************
 
@@ -63,12 +63,13 @@ scr_dump
 #define DUMPVER 1   /* Should be updated whenever the WINDOW struct is
                        changed */
 
+#ifndef __U_BOOT__
 int putwin(WINDOW *win, FILE *filep)
 {
     static const char *marker = "PDC";
     static const unsigned char version = DUMPVER;
 
-    PDC_LOG(("putwin() - called\n"));
+    PDC_LOG("putwin() - called\n");
 
     /* write the marker and the WINDOW struct */
 
@@ -96,7 +97,7 @@ WINDOW *getwin(FILE *filep)
     char marker[4];
     int i, nlines, ncols;
 
-    PDC_LOG(("getwin() - called\n"));
+    PDC_LOG("getwin() - called\n");
 
     win = malloc(sizeof(WINDOW));
     if (!win)
@@ -161,7 +162,7 @@ int scr_dump(const char *filename)
 {
     FILE *filep;
 
-    PDC_LOG(("scr_dump() - called: filename %s\n", filename));
+    PDC_LOG("scr_dump() - called: filename %s\n", filename);
 
     if (filename && (filep = fopen(filename, "wb")) != NULL)
     {
@@ -172,20 +173,22 @@ int scr_dump(const char *filename)
 
     return ERR;
 }
+#endif
 
 int scr_init(const char *filename)
 {
-    PDC_LOG(("scr_init() - called: filename %s\n", filename));
+    PDC_LOG("scr_init() - called: filename %s\n", filename);
 
     INTENTIONALLY_UNUSED_PARAMETER( filename);
     return OK;
 }
 
+#ifndef __U_BOOT__
 int scr_restore(const char *filename)
 {
     FILE *filep;
 
-    PDC_LOG(("scr_restore() - called: filename %s\n", filename));
+    PDC_LOG("scr_restore() - called: filename %s\n", filename);
 
     if (filename && (filep = fopen(filename, "rb")) != NULL)
     {
@@ -202,10 +205,13 @@ int scr_restore(const char *filename)
 
     return ERR;
 }
+#endif
 
+#ifndef __U_BOOT__
 int scr_set(const char *filename)
 {
-    PDC_LOG(("scr_set() - called: filename %s\n", filename));
+    PDC_LOG("scr_set() - called: filename %s\n", filename);
 
     return scr_restore(filename);
 }
+#endif
diff --git a/lib/PDCursesMod/pdcurses/scroll.c b/lib/PDCursesMod/pdcurses/scroll.c
index 87b07dcd0c8..7af8810e181 100644
--- a/lib/PDCursesMod/pdcurses/scroll.c
+++ b/lib/PDCursesMod/pdcurses/scroll.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -90,14 +90,14 @@ int wscrl(WINDOW *win, int n)
 
 int scrl(int n)
 {
-    PDC_LOG(("scrl() - called\n"));
+    PDC_LOG("scrl() - called\n");
 
     return wscrl(stdscr, n);
 }
 
 int scroll(WINDOW *win)
 {
-    PDC_LOG(("scroll() - called\n"));
+    PDC_LOG("scroll() - called\n");
 
     return wscrl(win, 1);
 }
diff --git a/lib/PDCursesMod/pdcurses/slk.c b/lib/PDCursesMod/pdcurses/slk.c
index cfc48c6df8d..3721b7d2010 100644
--- a/lib/PDCursesMod/pdcurses/slk.c
+++ b/lib/PDCursesMod/pdcurses/slk.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -120,7 +120,7 @@ int slk_init(int fmt)
 {
     int i;
 
-    PDC_LOG(("slk_init() - called\n"));
+    PDC_LOG("slk_init() - called\n");
 
     switch (fmt)
     {
@@ -153,12 +153,12 @@ int slk_init(int fmt)
     for( i = abs( label_fmt); i; i /= 16)
        labels += i % 16;
 
-    PDC_LOG(("slk_init: fmt %d, %d labels, %p\n",
-               fmt, labels, slk));
+    PDC_LOG("slk_init: fmt %d, %d labels, %p\n",
+               fmt, labels, slk);
     if( slk)
         free( slk);
     slk = calloc(labels, sizeof(struct SLK));
-    PDC_LOG(( "New slk: %p; SP = %p\n", slk, SP));
+    PDC_LOG( "New slk: %p; SP = %p\n", slk, SP);
 
     if (!slk)
         labels = 0;
@@ -249,7 +249,7 @@ int slk_set(int labnum, const char *label, int justify)
     PDC_mbstowcs(wlabel, label, MAX_LABEL_LENGTH - 1);
     return slk_wset(labnum, wlabel, justify);
 #else
-    PDC_LOG(("slk_set() - called\n"));
+    PDC_LOG("slk_set() - called\n");
 
     if (labnum < 1 || labnum > labels || justify < 0 || justify > 2)
         return ERR;
@@ -296,14 +296,14 @@ int slk_set(int labnum, const char *label, int justify)
 
 int slk_refresh(void)
 {
-    PDC_LOG(("slk_refresh() - called\n"));
+    PDC_LOG("slk_refresh() - called\n");
 
     return (slk_noutrefresh() == ERR) ? ERR : doupdate();
 }
 
 int slk_noutrefresh(void)
 {
-    PDC_LOG(("slk_noutrefresh() - called\n"));
+    PDC_LOG("slk_noutrefresh() - called\n");
 
     assert( SP);
     if (!SP)
@@ -323,7 +323,7 @@ char *slk_label(int labnum)
     chtype *p;
     int i;
 
-    PDC_LOG(("slk_label() - called\n"));
+    PDC_LOG("slk_label() - called\n");
 
     if (labnum < 1 || labnum > labels)
         return (char *)0;
@@ -338,7 +338,7 @@ char *slk_label(int labnum)
 
 int slk_clear(void)
 {
-    PDC_LOG(("slk_clear() - called\n"));
+    PDC_LOG("slk_clear() - called\n");
 
     assert( SP);
     if (!SP)
@@ -351,7 +351,7 @@ int slk_clear(void)
 
 int slk_restore(void)
 {
-    PDC_LOG(("slk_restore() - called\n"));
+    PDC_LOG("slk_restore() - called\n");
 
     assert( SP);
     if (!SP)
@@ -364,7 +364,7 @@ int slk_restore(void)
 
 int slk_touch(void)
 {
-    PDC_LOG(("slk_touch() - called\n"));
+    PDC_LOG("slk_touch() - called\n");
 
     assert( SP);
     if (!SP)
@@ -377,7 +377,7 @@ int slk_attron(const chtype attrs)
 {
     int rc;
 
-    PDC_LOG(("slk_attron() - called\n"));
+    PDC_LOG("slk_attron() - called\n");
 
     assert( SP);
     if (!SP)
@@ -391,7 +391,7 @@ int slk_attron(const chtype attrs)
 
 int slk_attr_on(const attr_t attrs, void *opts)
 {
-    PDC_LOG(("slk_attr_on() - called\n"));
+    PDC_LOG("slk_attr_on() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( opts);
     return slk_attron(attrs);
@@ -401,7 +401,7 @@ int slk_attroff(const chtype attrs)
 {
     int rc;
 
-    PDC_LOG(("slk_attroff() - called\n"));
+    PDC_LOG("slk_attroff() - called\n");
 
     assert( SP);
     if (!SP)
@@ -415,7 +415,7 @@ int slk_attroff(const chtype attrs)
 
 int slk_attr_off(const attr_t attrs, void *opts)
 {
-    PDC_LOG(("slk_attr_off() - called\n"));
+    PDC_LOG("slk_attr_off() - called\n");
 
     INTENTIONALLY_UNUSED_PARAMETER( opts);
     return slk_attroff(attrs);
@@ -425,7 +425,7 @@ int slk_attrset(const chtype attrs)
 {
     int rc;
 
-    PDC_LOG(("slk_attrset() - called\n"));
+    PDC_LOG("slk_attrset() - called\n");
 
     assert( SP);
     if (!SP)
@@ -441,7 +441,7 @@ int slk_color(short color_pair)
 {
     int rc;
 
-    PDC_LOG(("slk_color() - called\n"));
+    PDC_LOG("slk_color() - called\n");
 
     assert( SP);
     if (!SP)
@@ -456,7 +456,7 @@ int slk_color(short color_pair)
 int slk_attr_set(const attr_t attrs, short color_pair, void *opts)
 {
     INTENTIONALLY_UNUSED_PARAMETER( opts);
-    PDC_LOG(("slk_attr_set() - called\n"));
+    PDC_LOG("slk_attr_set() - called\n");
 
     return slk_attrset(attrs | COLOR_PAIR(color_pair));
 }
@@ -546,7 +546,7 @@ int PDC_mouse_in_slk(int y, int x)
 {
     int i;
 
-    PDC_LOG(("PDC_mouse_in_slk() - called: y->%d x->%d\n", y, x));
+    PDC_LOG("PDC_mouse_in_slk() - called: y->%d x->%d\n", y, x);
 
     /* If the line on which the mouse was clicked is NOT the last line
        of the screen, or the SLKs are hidden,  we are not interested in it. */
@@ -566,7 +566,7 @@ int PDC_mouse_in_slk(int y, int x)
 #ifdef PDC_WIDE
 int slk_wset(int labnum, const wchar_t *label, int justify)
 {
-    PDC_LOG(("slk_wset() - called\n"));
+    PDC_LOG("slk_wset() - called\n");
 
     if (labnum < 1 || labnum > labels || justify < 0 || justify > 2)
         return ERR;
@@ -616,7 +616,7 @@ wchar_t *slk_wlabel(int labnum)
     chtype *p;
     int i;
 
-    PDC_LOG(("slk_wlabel() - called\n"));
+    PDC_LOG("slk_wlabel() - called\n");
 
     if (labnum < 1 || labnum > labels)
         return (wchar_t *)0;
diff --git a/lib/PDCursesMod/pdcurses/termattr.c b/lib/PDCursesMod/pdcurses/termattr.c
index 20e7ae534bc..8e7fda637d8 100644
--- a/lib/PDCursesMod/pdcurses/termattr.c
+++ b/lib/PDCursesMod/pdcurses/termattr.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -76,42 +76,42 @@ termattr
 
 int baudrate(void)
 {
-    PDC_LOG(("baudrate() - called\n"));
+    PDC_LOG("baudrate() - called\n");
 
     return INT_MAX;
 }
 
 char erasechar(void)
 {
-    PDC_LOG(("erasechar() - called\n"));
+    PDC_LOG("erasechar() - called\n");
 
     return _ECHAR;      /* character delete char (^H) */
 }
 
 bool has_ic(void)
 {
-    PDC_LOG(("has_ic() - called\n"));
+    PDC_LOG("has_ic() - called\n");
 
     return TRUE;
 }
 
 bool has_il(void)
 {
-    PDC_LOG(("has_il() - called\n"));
+    PDC_LOG("has_il() - called\n");
 
     return TRUE;
 }
 
 char killchar(void)
 {
-    PDC_LOG(("killchar() - called\n"));
+    PDC_LOG("killchar() - called\n");
 
     return _DLCHAR;     /* line delete char (^U) */
 }
 
 char *longname(void)
 {
-    PDC_LOG(("longname() - called\n"));
+    PDC_LOG("longname() - called\n");
 
     sprintf(ttytype, "pdcurses|PDCurses for %s", PDC_sysname());
     return ttytype + 9; /* skip "pdcurses|" */
@@ -119,14 +119,14 @@ char *longname(void)
 
 chtype termattrs(void)
 {
-    PDC_LOG(("termattrs() - called\n"));
+    PDC_LOG("termattrs() - called\n");
 
     return SP ? SP->termattrs : (chtype)0;
 }
 
 attr_t term_attrs(void)
 {
-    PDC_LOG(("term_attrs() - called\n"));
+    PDC_LOG("term_attrs() - called\n");
 
     return SP ? SP->termattrs : (attr_t)0;
 }
@@ -135,14 +135,14 @@ char *termname(void)
 {
     static char _termname[14] = "pdcurses";
 
-    PDC_LOG(("termname() - called\n"));
+    PDC_LOG("termname() - called\n");
 
     return _termname;
 }
 
 char wordchar(void)
 {
-    PDC_LOG(("wordchar() - called\n"));
+    PDC_LOG("wordchar() - called\n");
 
     return _DWCHAR;         /* word delete char */
 }
@@ -150,7 +150,7 @@ char wordchar(void)
 #ifdef PDC_WIDE
 int erasewchar(wchar_t *ch)
 {
-    PDC_LOG(("erasewchar() - called\n"));
+    PDC_LOG("erasewchar() - called\n");
 
     assert( ch);
     if (!ch)
@@ -163,7 +163,7 @@ int erasewchar(wchar_t *ch)
 
 int killwchar(wchar_t *ch)
 {
-    PDC_LOG(("killwchar() - called\n"));
+    PDC_LOG("killwchar() - called\n");
 
     assert( ch);
     if (!ch)
diff --git a/lib/PDCursesMod/pdcurses/touch.c b/lib/PDCursesMod/pdcurses/touch.c
index 56cfa605f74..76635228c30 100644
--- a/lib/PDCursesMod/pdcurses/touch.c
+++ b/lib/PDCursesMod/pdcurses/touch.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -65,7 +65,7 @@ int touchwin(WINDOW *win)
 {
     int i;
 
-    PDC_LOG(("touchwin() - called: Win=%x\n", win));
+    PDC_LOG("touchwin() - called: Win=%x\n", win);
 
     assert( win);
     if (!win)
@@ -84,8 +84,8 @@ int touchline(WINDOW *win, int start, int count)
 {
     int i;
 
-    PDC_LOG(("touchline() - called: win=%p start %d count %d\n",
-             win, start, count));
+    PDC_LOG("touchline() - called: win=%p start %d count %d\n",
+             win, start, count);
 
     assert( win);
     if (!win || start > win->_maxy || start + count > win->_maxy)
@@ -104,7 +104,7 @@ int untouchwin(WINDOW *win)
 {
     int i;
 
-    PDC_LOG(("untouchwin() - called: win=%p", win));
+    PDC_LOG("untouchwin() - called: win=%p", win);
 
     assert( win);
     if (!win)
@@ -123,8 +123,8 @@ int wtouchln(WINDOW *win, int y, int n, int changed)
 {
     int i;
 
-    PDC_LOG(("wtouchln() - called: win=%p y=%d n=%d changed=%d\n",
-             win, y, n, changed));
+    PDC_LOG("wtouchln() - called: win=%p y=%d n=%d changed=%d\n",
+             win, y, n, changed);
 
     assert( win);
     if (!win || y > win->_maxy || y + n > win->_maxy)
@@ -149,7 +149,7 @@ int wtouchln(WINDOW *win, int y, int n, int changed)
 
 bool is_linetouched(WINDOW *win, int line)
 {
-    PDC_LOG(("is_linetouched() - called: win=%p line=%d\n", win, line));
+    PDC_LOG("is_linetouched() - called: win=%p line=%d\n", win, line);
 
     assert( win);
     if (!win || line > win->_maxy || line < 0)
@@ -162,7 +162,7 @@ bool is_wintouched(WINDOW *win)
 {
     int i;
 
-    PDC_LOG(("is_wintouched() - called: win=%p\n", win));
+    PDC_LOG("is_wintouched() - called: win=%p\n", win);
 
     assert( win);
     if (win)
@@ -177,7 +177,7 @@ int touchoverlap(const WINDOW *win1, WINDOW *win2)
 {
     int y, endy, endx, starty, startx;
 
-    PDC_LOG(("touchoverlap() - called: win1=%p win2=%p\n", win1, win2));
+    PDC_LOG("touchoverlap() - called: win1=%p win2=%p\n", win1, win2);
 
     assert( win1);
     assert( win2);
diff --git a/lib/PDCursesMod/pdcurses/util.c b/lib/PDCursesMod/pdcurses/util.c
index 2197370eaaf..5095de7a550 100644
--- a/lib/PDCursesMod/pdcurses/util.c
+++ b/lib/PDCursesMod/pdcurses/util.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -90,7 +90,7 @@ char *unctrl(chtype c)
 
     chtype ic;
 
-    PDC_LOG(("unctrl() - called\n"));
+    PDC_LOG("unctrl() - called\n");
 
     ic = c & A_CHARTEXT;
 
@@ -113,24 +113,37 @@ char *unctrl(chtype c)
 
 void filter(void)
 {
-    PDC_LOG(("filter() - called\n"));
+    PDC_LOG("filter() - called\n");
 }
 
 void use_env(bool x)
 {
     INTENTIONALLY_UNUSED_PARAMETER( x);
-    PDC_LOG(("use_env() - called: x %d\n", x));
+    PDC_LOG("use_env() - called: x %d\n", x);
 }
 
 int delay_output(int ms)
 {
-    PDC_LOG(("delay_output() - called: ms %d\n", ms));
+    PDC_LOG("delay_output() - called: ms %d\n", ms);
 
     return napms(ms);
 }
 
 int PDC_wc_to_utf8( char *dest, const int32_t code)
 {
+#ifdef __U_BOOT__
+   int n_bytes_out;
+
+   // Assumes all chars are already correct
+   // This is because we're working in a weird setup.
+   // The video console (cfb_console) is CP37.
+   // The serial console is *probably* UTF-8.
+   // So transmitting the raw chars is better.
+   dest[0] = (char)code;
+   n_bytes_out = 1;
+
+   return n_bytes_out;
+#else
    int n_bytes_out;
 
    if (code < 0x80)
@@ -161,6 +174,7 @@ int PDC_wc_to_utf8( char *dest, const int32_t code)
            n_bytes_out = 4;
        }
    return( n_bytes_out);
+#endif
 }
 
 #ifdef PDC_WIDE
@@ -212,7 +226,7 @@ wchar_t *wunctrl(cchar_t *wc)
 
     cchar_t ic;
 
-    PDC_LOG(("wunctrl() - called\n"));
+    PDC_LOG("wunctrl() - called\n");
 
     assert( wc);
     if (!wc)
diff --git a/lib/PDCursesMod/pdcurses/window.c b/lib/PDCursesMod/pdcurses/window.c
index 60c7a092384..1112d6b829f 100644
--- a/lib/PDCursesMod/pdcurses/window.c
+++ b/lib/PDCursesMod/pdcurses/window.c
@@ -1,6 +1,6 @@
 /* PDCurses */
 
-#include <curspriv.h>
+#include "../curspriv.h"
 #include <assert.h>
 
 /*man-start**************************************************************
@@ -138,8 +138,8 @@ WINDOW *PDC_makenew(int nlines, int ncols, int begy, int begx)
 {
     WINDOW *win;
 
-    PDC_LOG(("PDC_makenew() - called: lines %d cols %d begy %d begx %d\n",
-             nlines, ncols, begy, begx));
+    PDC_LOG("PDC_makenew() - called: lines %d cols %d begy %d begx %d\n",
+             nlines, ncols, begy, begx);
 
     /* allocate the window structure itself */
 
@@ -190,7 +190,7 @@ WINDOW *PDC_makelines(WINDOW *win)
 {
     int i, nlines, ncols;
 
-    PDC_LOG(("PDC_makelines() - called\n"));
+    PDC_LOG("PDC_makelines() - called\n");
 
     assert( win);
     if (!win)
@@ -218,7 +218,7 @@ WINDOW *PDC_makelines(WINDOW *win)
 
 void PDC_sync(WINDOW *win)
 {
-    PDC_LOG(("PDC_sync() - called:\n"));
+    PDC_LOG("PDC_sync() - called:\n");
 
     if (win->_immed)
         wrefresh(win);
@@ -230,8 +230,8 @@ WINDOW *newwin(int nlines, int ncols, int begy, int begx)
 {
     WINDOW *win;
 
-    PDC_LOG(("newwin() - called:lines=%d cols=%d begy=%d begx=%d\n",
-             nlines, ncols, begy, begx));
+    PDC_LOG("newwin() - called:lines=%d cols=%d begy=%d begx=%d\n",
+             nlines, ncols, begy, begx);
 
     if (!nlines)
         nlines = LINES - begy;
@@ -254,7 +254,7 @@ WINDOW *newwin(int nlines, int ncols, int begy, int begx)
 
 int delwin(WINDOW *win)
 {
-    PDC_LOG(("delwin() - called\n"));
+    PDC_LOG("delwin() - called\n");
 
     assert( win);
     if (!win)
@@ -275,7 +275,7 @@ int delwin(WINDOW *win)
 
 int mvwin(WINDOW *win, int y, int x)
 {
-    PDC_LOG(("mvwin() - called\n"));
+    PDC_LOG("mvwin() - called\n");
 
     assert( win);
     if (!win || (y + win->_maxy > LINES || y < 0)
@@ -294,8 +294,8 @@ WINDOW *subwin(WINDOW *orig, int nlines, int ncols, int begy, int begx)
     WINDOW *win;
     int i, j, k;
 
-    PDC_LOG(("subwin() - called: lines %d cols %d begy %d begx %d\n",
-             nlines, ncols, begy, begx));
+    PDC_LOG("subwin() - called: lines %d cols %d begy %d begx %d\n",
+             nlines, ncols, begy, begx);
 
     /* make sure window fits inside the original one */
 
@@ -435,8 +435,8 @@ WINDOW *resize_window(WINDOW *win, int nlines, int ncols)
     WINDOW *new;
     int save_cury, save_curx, new_begy, new_begx;
 
-    PDC_LOG(("resize_window() - called: nlines %d ncols %d\n",
-             nlines, ncols));
+    PDC_LOG("resize_window() - called: nlines %d ncols %d\n",
+             nlines, ncols);
 
     assert( SP);
     assert( win);
@@ -528,7 +528,7 @@ void wsyncup(WINDOW *win)
 {
     WINDOW *tmp;
 
-    PDC_LOG(("wsyncup() - called\n"));
+    PDC_LOG("wsyncup() - called\n");
 
     for (tmp = win; tmp; tmp = tmp->_parent)
         touchwin(tmp);
@@ -536,7 +536,7 @@ void wsyncup(WINDOW *win)
 
 int syncok(WINDOW *win, bool bf)
 {
-    PDC_LOG(("syncok() - called\n"));
+    PDC_LOG("syncok() - called\n");
 
     assert( win);
     if (!win)
@@ -551,7 +551,7 @@ void wcursyncup(WINDOW *win)
 {
     WINDOW *tmp;
 
-    PDC_LOG(("wcursyncup() - called\n"));
+    PDC_LOG("wcursyncup() - called\n");
 
     for (tmp = win; tmp && tmp->_parent; tmp = tmp->_parent)
         wmove(tmp->_parent, tmp->_pary + tmp->_cury, tmp->_parx + tmp->_curx);
@@ -561,7 +561,7 @@ void wsyncdown(WINDOW *win)
 {
     WINDOW *tmp;
 
-    PDC_LOG(("wsyncdown() - called\n"));
+    PDC_LOG("wsyncdown() - called\n");
 
     for (tmp = win; tmp; tmp = tmp->_parent)
     {
-- 
2.35.1

